// Устанавливаются снаружи
Перем мКонфигурация Экспорт;

Перем мСтараяСтраницаПанелиЧасти Экспорт;
Перем мСтараяСтраницаПанелиОсновная Экспорт;
Перем мТекущаяСтрокаСвязи;
Перем мТекущаяСтрокаУсловияСвязи;
Перем мТекущаяСтрокаВыбранногоПоля;
Перем мТекущаяСтрокаУсловия;
Перем мТекущаяСтрокаПараметраТаблицы;
Перем мТекущаяСтрокаЧастиОбъединения;
Перем мТекущаяСтрокаЗапросыПакета;
Перем мТекущаяСтрокаВыбранныеТаблицы;
Перем мТекущаяСтрокаГруппируемогоПоля;
Перем мТекущееИмяВременнойТаблицы;
Перем мТекущееИмяВыбраннойТаблицы;
Перем мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей;
Перем мЧислоСтатическихКолонокТППоляПсевдонимовПолей;
Перем мРежимРедактированияТекста Экспорт;
Перем мТерминалыЯзыкаЗапросов Экспорт;
Перем ПараметрыДиалектаSQL;
Перем мСравнительТабличныхДокументов;
Перем мМаркерИндексаЗапросаПакета;
Перем мИмяТекущегоПараметра;

// +++.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
Перем ПолеТекстовогоДокументаСКонтекстнойПодсказкой;
// ---.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой

// @@@.КЛАСС.ПолеТекстоввогоДокументаСКонтекстнойПодсказкой
// Транслятор обработки событий нажатия на кнопки командной панели в компоненту.
//
// Параметры:
//  Кнопка       – КнопкаКоманднойПанели.
//
Процедура КлсПолеТекстовогоДокументаСКонтекстнойПодсказкойНажатие(Кнопка)
	
	// Специальная обработка команд компоненты ДО
	ЭкземплярКомпоненты = ПолучитьТекущуюКомпонентуКонтекстнойПодсказки(Кнопка);
	Если ЭкземплярКомпоненты <> Неопределено Тогда
		Результат = ЭкземплярКомпоненты.Нажатие(Кнопка);
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьТекущуюКомпонентуКонтекстнойПодсказки(Кнопка = Неопределено)

	Если ПолеТекстовогоДокументаСКонтекстнойПодсказкой.Свойство(ТекущийЭлемент.Имя) Тогда
		ЭкземплярКомпоненты = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ТекущийЭлемент.Имя];
	КонецЕсли;
	Возврат ЭкземплярКомпоненты;

КонецФункции

////////////////////////////

Процедура УстановитьДанные(НачальныйТокен = Неопределено, ТаблицаТекстаРасширения = Неопределено, БылиПотери = Неопределено) Экспорт
	
	Если ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
		ЗаполнитьДоступныеТаблицыWQL();
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
		ЗаполнитьДоступныеТаблицы1С();
	Иначе
		ЗаполнитьДоступныеТаблицыADO();
		КопияТаблицы = ДоступныеТаблицы.Выгрузить(, "Тип");
		КопияТаблицы.Свернуть("Тип");
		ЭлементыФормы.ДоступныеТаблицы.Колонки.Тип.Видимость = КопияТаблицы.Количество() > 1;
	КонецЕсли; 
	Состояние("Анализ дерева запроса...");
	ОчиститьДанные();
	ЭтаФорма.ТабличноеПолеКорневогоПакета = ЭлементыФормы.ЗапросыПакета;
	Если БылиПотери = Неопределено Тогда
		БылиПотери = Ложь;
	КонецЕсли; 
	Если НачальныйТокен = Неопределено Тогда
		ЗапросПакета = ДобавитьЗапросПакета();
		ДобавитьЧастьОбъединения(ЗапросПакета);
	Иначе
		ЗаполнитьПоТокену(НачальныйТокен,,,,,, ТаблицаТекстаРасширения);
		БылиПотери = СообщитьОНеразобранныхКомментариях(ТаблицаТекстаРасширения) Или БылиПотери;
	КонецЕсли;
	БылиПотери = ОбработатьРасширениеЯзыкаЗапросов() Или БылиПотери;
	ДоступныеТаблицы.Сортировать("Имя, Схема, Тип");
	Если БылиПотери Тогда
		Предупреждение("При разборе текста некоторые фрагменты были проигнорированы! Подробнее смотри в окне сообщений.");
	КонецЕсли; 
	ОбновитьРежимПакетногоЗапроса();
	Состояние();
	
КонецПроцедуры

Функция ОбновитьРежимПакетногоЗапроса()

	ЭтаФорма.ЛиПакетныйЗапрос = ЗапросыПакета.Количество() > 1;
	Если ЭтаФорма.Открыта() Тогда
		ИзменитьСвернутостьПанельПакета(ЛиПакетныйЗапрос);
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

// Результат - имелись ли потери при разборе текста
Функция ОбработатьРасширениеЯзыкаЗапросов()
	
	ТекстПакета = СобратьСлужебныйТекстПакетаПостроителя();
	Если ТекстПакета <> "" Тогда
		ТаблицаТекстаРасширения = Неопределено;
		СтартовыйТокен = РазобратьТекстЗапроса(ТекстПакета,,,,, ТаблицаТекстаРасширения);
		Если СтартовыйТокен = Неопределено Тогда
			ВызватьИсключение "Ошибка разбора текста промежуточного запроса";
		КонецЕсли; 
		СлужебноеПолеТекстовогоДокумента.УстановитьТекст(ТекстПакета);
		ЗаполнитьПоТокену(СтартовыйТокен,,,,, Истина, ТаблицаТекстаРасширения);
		Результат = СообщитьОНеразобранныхКомментариях(ТаблицаТекстаРасширения);
	Иначе
		Результат = Ложь;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Результат - имелись ли потери при разборе текста
Функция СообщитьОНеразобранныхКомментариях(ТаблицаТекстаРасширения) Экспорт
	
	Для Каждого СтрокаРасширения Из ТаблицаТекстаРасширения Цикл
		ирОбщий.СообщитьСУчетомМодальностиЛкс("Проигнорирован комментарий """ + СокрЛП(СтрокаРасширения.Текст) + """", , СтатусСообщения.Внимание);
	КонецЦикла;
	Результат = ТаблицаТекстаРасширения.Количество() > 0;
	Возврат Результат;
	
КонецФункции

Функция СобратьСлужебныйТекстПакетаПостроителя(пЗапросыПакета = Неопределено)

	Если пЗапросыПакета = Неопределено Тогда
		пЗапросыПакета = ЗапросыПакета;
	КонецЕсли; 
	ТекстПакета = "";
	Для ИндексЗапроса = 0 По пЗапросыПакета.Количество() - 1 Цикл
		ЗапросПакета = пЗапросыПакета[ИндексЗапроса];
		ТекстЗапросаПакета = "";
		Для ИндексЧасти = 0 По ЗапросПакета.ЧастиОбъединения.Количество() - 1 Цикл
			ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[ИндексЧасти];
			ТекстЧастиОбъединения = ЧастьОбъединения.ТекстРасширения;
			Для Каждого СтрокаВложенногоЗапроса Из ЧастьОбъединения.ВыбранныеТаблицы.НайтиСтроки(Новый Структура("ПолноеИмя", "")) Цикл
				ТекстВложенногоЗапроса = СобратьСлужебныйТекстПакетаПостроителя(СтрокаВложенногоЗапроса.ВложенныйПакет);
				Если ЗначениеЗаполнено(ТекстВложенногоЗапроса) Тогда
					ТекстЧастиОбъединения = ТекстЧастиОбъединения + "
					|#EmbededQuery " + XMLСтрока(ЧастьОбъединения.ВыбранныеТаблицы.Индекс(СтрокаВложенногоЗапроса)) + "
					|(" + ТекстВложенногоЗапроса + ")";
				КонецЕсли; 
			КонецЦикла;
			Если ЗначениеЗаполнено(ТекстЧастиОбъединения) Тогда
				ТекстЗапросаПакета = ТекстЗапросаПакета + "
				|#UnionPart " + XMLСтрока(ИндексЧасти) + "
				|" + ТекстЧастиОбъединения;
			КонецЕсли; 
		КонецЦикла;
		ТекстЗапросаПакета = ТекстЗапросаПакета + "
			|" + ЗапросПакета.ТекстРасширения;
		Если ЗначениеЗаполнено(ТекстЗапросаПакета) Тогда
			Если пЗапросыПакета = ЗапросыПакета Тогда // Пакет
				Если ТекстПакета <> "" Тогда
					ТекстПакета = ТекстПакета + ";";
				КонецЕсли; 
				ТекстПакета = ТекстПакета + "#Root " + XMLСтрока(ИндексЗапроса) + ТекстЗапросаПакета;
			Иначе
				ТекстПакета = ТекстПакета + ТекстЗапросаПакета;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	Возврат ТекстПакета;

КонецФункции

Функция НайтиДобавитьВыбраннуюТаблицуВСвязи(СтрокаВыбраннойТаблицы, ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	СвязьТаблицы = ЧастьОбъединения.СвязиТаблиц.Строки.Найти(СтрокаВыбраннойТаблицы.Имя, "Таблица", Истина);
	Если СвязьТаблицы = Неопределено Тогда
		СвязьТаблицы = ЧастьОбъединения.СвязиТаблиц.Строки.Добавить();
		СвязьТаблицы.Таблица = СтрокаВыбраннойТаблицы.Имя;
	КонецЕсли; 
	Возврат СвязьТаблицы;

КонецФункции // НайтиДобавитьВыбраннуюТаблицуВСвязи()
 
Процедура ОбработатьЗапросПослеУстановкиДанных(ЗапросПакета)

	ОбновитьНаименованиеЗапроса(ЗапросПакета);
	Если Ложь
		Или ЗапросПакета.ТипЗапроса = 0
		Или ЗапросПакета.ТипЗапроса = 1
	Тогда
		ПерваяЧасть = ЗапросПакета.ЧастиОбъединения[0];
		Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
			ОбновитьНаименованиеЧасти(ЧастьОбъединения);
			Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
				Если СтрокаВыбраннойТаблицы.ВложенныйПакет = Неопределено Тогда
					НайтиДобавитьДоступнуюВременнуюТаблицу(СтрокаВыбраннойТаблицы.ПолноеИмя);
				КонецЕсли; 
				НайтиДобавитьВыбраннуюТаблицуВСвязи(СтрокаВыбраннойТаблицы, ЧастьОбъединения);
				//ПолучитьИмяВыбраннойТаблицы(СтрокаВыбраннойТаблицы);
			КонецЦикла;
			ЧастьОбъединения.Автогруппировки = Истина;
			ЕстьАгрегаты = ЧастьОбъединения.ВыбранныеПоля.Найти(Истина, "ЕстьАгрегаты") <> Неопределено;
			ИндексВыбранногоПоля = 0;
			ОбновитьКомпоновщик = Ложь;
			ВыбранныеЗвездочкамиТаблицы = Новый ТаблицаЗначений();
			ВыбранныеЗвездочкамиТаблицы.Колонки.Добавить("ВыбраннаяТаблица");
			ВыбранныеЗвездочкамиТаблицы.Колонки.Добавить("Позиция");
			Пока ИндексВыбранногоПоля < ЧастьОбъединения.ВыбранныеПоля.Количество() Цикл
				ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля[ИндексВыбранногоПоля];
				ИмяПоля = ирОбщий.ПолучитьПоследнийФрагментЛкс(ВыбранноеПоле.Определение);
				Если ИмяПоля = "*" Тогда
					ИмяТаблицы = Лев(ВыбранноеПоле.Определение, СтрДлина(ВыбранноеПоле.Определение) - 2);
					ЧастьОбъединения.ВыбранныеПоля.Удалить(ИндексВыбранногоПоля);
					Если ИмяТаблицы = "" Тогда
						//ИмяТаблицы = ЧастьОбъединения.ВыбранныеТаблицы[0].Имя;
						Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
							СтрокаВыбраннойЗвездочкойТаблицы = ВыбранныеЗвездочкамиТаблицы.Добавить();
							СтрокаВыбраннойЗвездочкойТаблицы.ВыбраннаяТаблица = ВыбраннаяТаблица;
							СтрокаВыбраннойЗвездочкойТаблицы.Позиция = ИндексВыбранногоПоля;
						КонецЦикла;
					Иначе
						СтрокаВыбраннойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(ИмяТаблицы), "НИмя");
						Если СтрокаВыбраннойТаблицы = Неопределено Тогда
							СтрокаВыбраннойТаблицы = ДобавитьВыбраннуюТаблицу(ЧастьОбъединения);
							СтрокаВыбраннойТаблицы.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы,  ИмяТаблицы);
							СтрокаВыбраннойТаблицы.ПолноеИмя = ИмяТаблицы;
							СтрокаВыбраннойТаблицы.Обязательная = Истина;
							ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбраннойТаблицы);
							ОбновитьКомпоновщик = Истина;
						КонецЕсли; 
						СтрокаВыбраннойЗвездочкойТаблицы = ВыбранныеЗвездочкамиТаблицы.Добавить();
						СтрокаВыбраннойЗвездочкойТаблицы.ВыбраннаяТаблица = СтрокаВыбраннойТаблицы;
						СтрокаВыбраннойЗвездочкойТаблицы.Позиция = ИндексВыбранногоПоля;
					КонецЕсли; 
					ИндексВыбранногоПоля = ИндексВыбранногоПоля - 1;
				Иначе
					Если ПерваяЧасть = ЧастьОбъединения Тогда
						Если Не ЗначениеЗаполнено(ВыбранноеПоле.Имя) Тогда
							ВыбранноеПоле.Имя = ПолучитьАвтоПсевдонимПоля(ВыбранноеПоле, ЧастьОбъединения);
						КонецЕсли; 
					КонецЕсли;
				КонецЕсли; 
				Если Истина
					И ЕстьАгрегаты
					И ЧастьОбъединения.Автогруппировки 
				Тогда
					Группировка = ЧастьОбъединения.Группировки.Найти(ВыбранноеПоле.Определение, "Определение"); // Регистр!
					Если Ложь
						Или (Истина
							И ВыбранноеПоле.ЕстьАгрегаты 
							И Группировка <> Неопределено)
						Или (Истина
							И Не ВыбранноеПоле.ЕстьАгрегаты 
							И Группировка = Неопределено)
					Тогда
						ЧастьОбъединения.Автогруппировки = Ложь;
					КонецЕсли; 
				КонецЕсли; 
				ИндексВыбранногоПоля = ИндексВыбранногоПоля + 1;
			КонецЦикла;
			Если ОбновитьКомпоновщик Тогда
				ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения);
			КонецЕсли; 
			Для ИндексТаблицыИзЗвездочки = 1 По ВыбранныеЗвездочкамиТаблицы.Количество() Цикл
				СтрокаВыбраннойЗвездочкойТаблицы = ВыбранныеЗвездочкамиТаблицы[ВыбранныеЗвездочкамиТаблицы.Количество() - ИндексТаблицыИзЗвездочки];
				ВыбраннаяТаблица = СтрокаВыбраннойЗвездочкойТаблицы.ВыбраннаяТаблица;
				ВыбраннаяТаблица.ВсеПоля = Истина;
				КоличествоВыбранныхПолей = ЧастьОбъединения.ВыбранныеПоля.Количество();
				СдвигИндексаПослеДобавления = 0;
				Если КоличествоВыбранныхПолей > 0 Тогда
					СдвигИндексаПослеДобавления = -(КоличествоВыбранныхПолей - СтрокаВыбраннойЗвездочкойТаблицы.Позиция);
				КонецЕсли; 
				ДобавитьВсеПоляТаблицыВВыбранныеПоля(ВыбраннаяТаблица.Имя, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления);
			КонецЦикла;
			Если ПерваяЧасть <> ЧастьОбъединения Тогда
				Для ИндексВыбранногоПоля = 0 По ЧастьОбъединения.ВыбранныеПоля.Количество() - 1 Цикл
					ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля[ИндексВыбранногоПоля];
					ВыбранноеПоле.Имя = ПерваяЧасть.ВыбранныеПоля[ИндексВыбранногоПоля].Имя;
				КонецЦикла;
			КонецЕсли; 
		КонецЦикла;
		ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
		ОбновитьНаименованиеЗапроса(ЗапросПакета);
	КонецЕсли; 

КонецПроцедуры

Функция ДобавитьВсеПоляТаблицыВВыбранныеПоля(ИмяТаблицы, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, СдвигИндексаПослеДобавления = 0,
	КонтролироватьУникальность = Ложь)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
		ДоступноеПолеКомпоновщика = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы.Найти(ИмяТаблицы);
	Иначе
		ДоступноеПолеКомпоновщика = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора;
	КонецЕсли; 
	Если ДоступноеПолеКомпоновщика <> Неопределено Тогда
		ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(ДоступноеПолеКомпоновщика, Истина, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления,
			КонтролироватьУникальность);
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Функция ПолучитьКомментарийИзТокенов(Токен1, Токен2 = Неопределено)
	
	Массив = Новый Массив();
	Если Токен1 <> Неопределено Тогда
		Массив.Добавить(Токен1);
	КонецЕсли; 
	Если Токен2 <> Неопределено Тогда
		Массив.Добавить(Токен2);
	КонецЕсли; 
	ТекстКомментария = "";
	МаркерКомментария = "//";
	Для Каждого Токен Из Массив Цикл
		ТекстТокена = ПолучитьТекстИзТокена(Токен);
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(ТекстТокена);
		Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
			СтрокаТекста = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
			Если ПустаяСтрока(СтрокаТекста) Тогда
				Продолжить;
			КонецЕсли; 
			СтрокаТекста = Сред(СтрокаТекста, Найти(СтрокаТекста, МаркерКомментария) + СтрДлина(МаркерКомментария));
			Если Истина
				И Счетчик = 1
				И (Ложь
					Или Лев(СтрокаТекста, СтрДлина(ПараметрыДиалектаSQL.СтрочныйКомментарий)) = ПараметрыДиалектаSQL.СтрочныйКомментарий
					Или Лев(СтрокаТекста, СтрДлина(мМаркерИндексаЗапросаПакета)) = мМаркерИндексаЗапросаПакета)
			Тогда
				// Пропускаем динамические комментарии
				Продолжить;
			КонецЕсли; 
			Если ТекстКомментария <> "" Тогда
				ТекстКомментария = ТекстКомментария + Символы.ПС;
			КонецЕсли; 
			ТекстКомментария = ТекстКомментария + СтрокаТекста;
		КонецЦикла;
	КонецЦикла;
	Возврат ТекстКомментария;
	
КонецФункции

//
// Индикатор - Неопределено - автоиндикатор, можно передать Null для блокировки автосоздания индикатора
Функция ЗаполнитьПоТокену(Знач Токен, Стек = Неопределено, Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено, Индикатор = Неопределено,
	РазборРасширений = Ложь, ТаблицаТекстаРасширения = Неопределено, Знач ТекущаяСвязьТаблиц = Неопределено) Экспорт
	
	Данные = Токен.Data;
	Если Данные = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Стек = Неопределено Тогда
		Стек = Новый Массив();
	КонецЕсли;
	Если Индикатор = Неопределено Тогда
		ИндикаторБылСоздан = Истина;
		Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(, "Структура запроса");
	КонецЕсли;
	Если Индикатор <> Null Тогда
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
	КонецЕсли; 
	Результат = Неопределено;
	ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
	Стек.Вставить(0, ИмяПравила);
	КоличествоДочерних = Данные.TokenCount;
	Если ИмяПравила = "<EmbededQuery>" Тогда
		ВложенныйПакет = ЗапросыПакета.СкопироватьКолонки();
		ВложенныйЗапрос = ДобавитьЗапросПакета(ВложенныйПакет);
		ДобавленЗапрос = Истина;
		ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
		//Если ТекущийУзел.Параметры <> Неопределено Тогда
		//	ВызватьИсключение "Неверный тип выбранной таблицы для вложенного запроса";
		//КонецЕсли; 
		ТекущийУзел.ВложенныйПакет = ВложенныйПакет;
		ЗаполнитьПоТокену(Токен.Data.Tokens(1),, ВложенныйЗапрос,, Индикатор, РазборРасширений, ТаблицаТекстаРасширения);
	ИначеЕсли ИмяПравила = "<ExtEmbededQuery>" Тогда
		ИндексВложенногоЗапроса = Данные.Tokens(1).Data;
		ИндексВложенногоЗапроса = Число(ИндексВложенногоЗапроса);
		ВложенныйПакет = ЧастьОбъединения.ВыбранныеТаблицы[ИндексВложенногоЗапроса].ВложенныйПакет;
		ЗаполнитьПоТокену(Данные.Tokens(3), , ВложенныйПакет[0],, Индикатор, РазборРасширений, ТаблицаТекстаРасширения);
	ИначеЕсли ИмяПравила = "<Join>" Тогда
		Если ТекущаяСвязьТаблиц = Неопределено Тогда
			ТекущаяСвязьТаблиц = ЧастьОбъединения.СвязиТаблиц;
		КонецЕсли; 
		ЛевыйУзел = ЗаполнитьПоТокену(Данные.Tokens(0).Data.Tokens(0), Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаТекстаРасширения, ТекущаяСвязьТаблиц); //<TableOrJoin>.<TableWithName>
		Если ТипЗнч(ЛевыйУзел) = Тип("Строка") Тогда
			ТекущаяСвязьТаблиц = ТекущаяСвязьТаблиц.Строки.Добавить();
			ТекущаяСвязьТаблиц.Таблица = ЛевыйУзел;
		Иначе
			ТекущаяСвязьТаблиц = ЛевыйУзел;
		КонецЕсли; 
		ПравыйУзел = ЗаполнитьПоТокену(Данные.Tokens(3).Data.Tokens(0), Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаТекстаРасширения, ТекущаяСвязьТаблиц); //<TableOrJoin>.<TableWithName>
		Если ТипЗнч(ПравыйУзел) = Тип("Строка") Тогда
			ТекущаяСвязьТаблиц = ТекущаяСвязьТаблиц.Строки.Добавить();
			ТекущаяСвязьТаблиц.Таблица = ПравыйУзел;
		Иначе
			ТекущаяСвязьТаблиц = ПравыйУзел;
		КонецЕсли; 
		ТипCOMОбъекта = Данные.Tokens(1).Data; //"<JoinType>"
		Если ТипCOMОбъекта.TokenCount > 0 Тогда
			ТипCOMОбъекта = ТипCOMОбъекта.Tokens(0).Name;
		Иначе
			ТипCOMОбъекта = Неопределено;
		КонецЕсли; 
		Если Ложь
			Или ТипCOMОбъекта = "LEFT"
			Или ТипCOMОбъекта = "LEFT OUTER"
		Тогда
			ТекущаяСвязьТаблиц.ТипСвязи = "LEFT";
		ИначеЕсли Ложь
			Или ТипCOMОбъекта = "RIGHT"
			Или ТипCOMОбъекта = "RIGHT OUTER"
		Тогда
			ТекущаяСвязьТаблиц.ТипСвязи = "RIGHT";
		ИначеЕсли Ложь
			Или ТипCOMОбъекта = "OUTER"
			Или ТипCOMОбъекта = "FULL"
		Тогда
			ТекущаяСвязьТаблиц.ТипСвязи = "OUTER";
		ИначеЕсли Ложь
			Или ТипCOMОбъекта = "INNER"
		Тогда
			ТекущаяСвязьТаблиц.ТипСвязи = "INNER";
		Иначе
			ВызватьИсключение "Неизвестный тип связи таблиц """ + ТипCOMОбъекта + """";
		КонецЕсли;
		ТокенУсловия = Данные.Tokens(5);
		НастройкиКомпоновки = Новый НастройкиКомпоновкиДанных;
		ПостроитьДеревоЛогическогоВыражения(НастройкиКомпоновки.Отбор, ТокенУсловия, ЗапросПакета, ЧастьОбъединения);
		ТекущаяСвязьТаблиц.Условие = НастройкиКомпоновки;
		//ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущаяСвязьТаблиц, "Таблица");
		Результат = ТекущаяСвязьТаблиц.Родитель;
	ИначеЕсли ИмяПравила = "<ParameterOfTable>" Тогда
		ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
		ТекущийУзел = ВыбраннаяТаблица.Параметры.Добавить();
		ТекущийУзел.Номер = ВыбраннаяТаблица.Параметры.Количество();
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(Токен,, ЗапросПакета, ЧастьОбъединения);
		ТекущийУзел.Токен = Токен;
	ИначеЕсли ИмяПравила = "<Allowed>" Тогда
		ЗапросПакета.ОпцияРазрешенные = Истина;
	ИначеЕсли ИмяПравила = "<AutoOrder>" Тогда
		Если ПолучитьТекстИзТокена(Токен) <> "" Тогда
			ЗапросПакета.ОпцияАвтоупорядочивание = Истина;
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<Distinct>" Тогда
		ЧастьОбъединения.ОпцияРазличные = Истина;
	ИначеЕсли ИмяПравила = "<Top>" Тогда
		ЗапросПакета.ОпцияПервые = Истина;
		ЗапросПакета.ПервыеКоличество = Число(Данные.Tokens(1).Data);
	//ИначеЕсли ИмяПравила = "<MultiField>" Тогда
	//	ТекущийУзел = ЧастьОбъединения.ВыбранныеПоля[ЧастьОбъединения.ВыбранныеПоля.Количество() - 1];
	//	ТекущийУзел.Определение = ПолучитьТекстИзТокена(Токен);
	ИначеЕсли ИмяПравила = "<Where>" Тогда
		ПостроитьДеревоЛогическогоВыражения(ЧастьОбъединения.Условие.Отбор, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ЧастьОбъединения.КомментарийОтбора = ЧастьОбъединения.КомментарийОтбора + ПолучитьКомментарийИзТокенов(Данные.Tokens(1), Данные.Tokens(Данные.TokenCount - 1));
	ИначеЕсли ИмяПравила = "<Having>" Тогда
		ПостроитьДеревоЛогическогоВыражения(ЧастьОбъединения.Условие.Отбор, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ЧастьОбъединения.КомментарийОтбора = ЧастьОбъединения.КомментарийОтбора + ПолучитьКомментарийИзТокенов(Данные.Tokens(1), Данные.Tokens(Данные.TokenCount - 1));
	ИначеЕсли ИмяПравила = "<SelectExpr>" Тогда
		ТекущийУзел = ЧастьОбъединения.ВыбранныеПоля.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(1);
		ТекущийУзел.ИД = Новый УникальныйИдентификатор();
		ЕстьАгрегаты = Ложь;
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,, ЕстьАгрегаты);
		ТекущийУзел.ЕстьАгрегаты = ЕстьАгрегаты;
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		ТекущийУзел.АгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(ТекущийУзел.Токен);
		ТекущийУзел.ТипЗначения = ПолучитьТипЗначенияВыражения(ТекущийУзел.Токен, ЧастьОбъединения);
		Если КоличествоДочерних = 4 Тогда
			ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Данные.Tokens(2));
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<GroupExpr>" Тогда
		ТекущийУзел = ЧастьОбъединения.Группировки.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(1);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
	ИначеЕсли ИмяПравила = "<TotalsExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ГруппирующиеПоляИтогов.Добавить();
		ДанныеHierExpr = Данные.Tokens(1).Data;
		ТекущийУзел.Токен = ДанныеHierExpr.Tokens(0);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ,,,, Ложь);
		ДанныеHierMode = ДанныеHierExpr.Tokens(1).Data;
		Если ДанныеHierMode.TokenCount = 0 Тогда
			ТипИтогов = "Элементы";
		Иначе
			ПервыйТокен = ДанныеHierMode.Tokens(0);
			Если Истина
				И ПервыйТокен.Kind = 0 
			Тогда 
				ТипИтогов = "ЭлементыИИерархия";
			ИначеЕсли Истина
				И ПервыйТокен.Kind = 1 
				И ПервыйТокен.Name = "ONLY"
			Тогда 
				ТипИтогов = "Иерархия";
			//ИначеЕсли Истина
			//	И ПервыйТокен.Kind = 1 
			//	И ПервыйТокен.Name = "PERIODS"
			//Тогда 
			//	ТипИтогов = "Периодами";
			КонецЕсли; 
		КонецЕсли; 
		ТекущийУзел.ТипИтогов = ТипИтогов;
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Данные.Tokens(2));
	ИначеЕсли ИмяПравила = "<OrderExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ПоляПорядка.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(1);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		ТокенНаправления = Данные.Tokens(Данные.TokenCount - 2);
		Если Истина
			И ТокенНаправления.Kind = 1 
			И ТокенНаправления.Name = "DESC" 
		Тогда
			ТекущийУзел.Направление = НаправлениеСортировки.Убыв;
		Иначе
			ТекущийУзел.Направление = НаправлениеСортировки.Возр;
		КонецЕсли; 
		ТокенИерархии = Данные.Tokens(2);
		Если Истина
			И ТокенИерархии.Kind = 1 
			//И ТокенИерархии.Name = "" 
		Тогда
			ТекущийУзел.Иерархия = Истина;
		Иначе
			ТекущийУзел.Иерархия = Ложь;
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<AgregatExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ГруппируемыеПоляИтогов.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(1);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Данные.Tokens(2));
	ИначеЕсли ИмяПравила = "<IndexExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ПоляИндекса.Добавить();
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(Данные.Tokens(1),, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		//ТекущийУзел.Токен = Токен;
	ИначеЕсли ИмяПравила = "<ExtSelectExpr>" Тогда
		ДанныеПоля = Данные.Tokens(0).Data;
		ТекущийУзел = ЧастьОбъединения.ПоляВыбораПостроителя.Добавить();
		ТекущийУзел.Токен = ДанныеПоля.Tokens(1);
		ТекущийУзел.ИспользоватьДочерние = ТекущийУзел.Токен.Data.Tokens(1).Data.TokenCount > 0;
		Если ТекущийУзел.ИспользоватьДочерние Тогда
			ТекущийУзел.Токен = ТекущийУзел.Токен.Data.Tokens(0);
		КонецЕсли; 
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(ДанныеПоля.Tokens(0), ДанныеПоля.Tokens(ДанныеПоля.TokenCount - 1));
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, ДанныеПоля.Tokens(2));
	ИначеЕсли ИмяПравила = "<ExtWhereExpr>" Тогда
		ДанныеПоля = Данные.Tokens(0).Data;
		ТекущийУзел = ЧастьОбъединения.ПоляОтбораПостроителя.Добавить();
		ТекущийУзел.Токен = ДанныеПоля.Tokens(1);
		ТекущийУзел.ИспользоватьДочерние = ТекущийУзел.Токен.Data.Tokens(1).Data.TokenCount > 0;
		Если ТекущийУзел.ИспользоватьДочерние Тогда
			ТекущийУзел.Токен = ТекущийУзел.Токен.Data.Tokens(0);
		КонецЕсли; 
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(ДанныеПоля.Tokens(0), ДанныеПоля.Tokens(ДанныеПоля.TokenCount - 1));
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, ДанныеПоля.Tokens(2));
	ИначеЕсли ИмяПравила = "<ExtOrderExpr>" Тогда
		ДанныеПоля = Данные.Tokens(0).Data;
		ТекущийУзел = ЗапросПакета.ПоляПорядкаПостроителя.Добавить();
		ТекущийУзел.Токен = ДанныеПоля.Tokens(1);
		ТекущийУзел.ИспользоватьДочерние = ТекущийУзел.Токен.Data.Tokens(1).Data.TokenCount > 0;
		Если ТекущийУзел.ИспользоватьДочерние Тогда
			ТекущийУзел.Токен = ТекущийУзел.Токен.Data.Tokens(0);
		КонецЕсли; 
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета,,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(ДанныеПоля.Tokens(0), ДанныеПоля.Tokens(ДанныеПоля.TokenCount - 1));
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, ДанныеПоля.Tokens(2));
	ИначеЕсли ИмяПравила = "<ExtTotalExpr>" Тогда
		ДанныеПоля = Данные.Tokens(0).Data;
		ТекущийУзел = ЗапросПакета.ПоляИтоговПостроителя.Добавить();
		ТекущийУзел.Токен = ДанныеПоля.Tokens(1);
		ТекущийУзел.ИспользоватьДочерние = ТекущийУзел.Токен.Data.Tokens(1).Data.TokenCount > 0;
		Если ТекущийУзел.ИспользоватьДочерние Тогда
			ТекущийУзел.Токен = ТекущийУзел.Токен.Data.Tokens(0);
		КонецЕсли; 
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета,,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(ДанныеПоля.Tokens(0), ДанныеПоля.Tokens(ДанныеПоля.TokenCount - 1));
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, ДанныеПоля.Tokens(2));
	ИначеЕсли Истина
		И ИмяПравила = "<TablePseudoname>" 
		И (Ложь
			Или Стек[1] = "<TableWithName>"
			Или Стек[1] = "<FromUnion>")
	Тогда
		ТокенПсевдонима = Данные.Tokens(Данные.TokenCount - 1);
		Если ТокенПсевдонима = Неопределено Тогда
			ТекстОпределения = "";
		Иначе
			ТекстОпределения = СобратьВыражениеЗапроса(ТокенПсевдонима,, ЗапросПакета, ЧастьОбъединения);
		КонецЕсли; 
		ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
		ТекущийУзел.Имя = ТекстОпределения;
		ТекущийУзел.Имя = ПолучитьИмяБезКвадратныхСкобок(ТекущийУзел.Имя);
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел);
		Результат = ТекущийУзел.Имя;
	ИначеЕсли Ложь
		Или ИмяПравила = "<CreateQuery>"
		Или ИмяПравила = "<SelectQuery>"
		Или ИмяПравила = "<Query>"
	Тогда
		ЧастьОбъединения.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0));
		Если ИмяПравила = "<CreateQuery>" Тогда  // FromTables
			ИндексТокенаВыбранныхТаблиц = 5;
		Иначе
			ИндексТокенаВыбранныхТаблиц = 4;
		КонецЕсли; 
		ЗаполнитьПоТокену(Данные.Tokens(ИндексТокенаВыбранныхТаблиц), Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаТекстаРасширения);
		ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения);
		Для ИндексТокена = 1 По КоличествоДочерних - 1 Цикл
			Если ИндексТокена = ИндексТокенаВыбранныхТаблиц Тогда
				Продолжить;
			КонецЕсли; 
			ТокенВниз = Данные.Tokens(ИндексТокена);
			Если ТокенВниз.Kind = 0 Тогда
				ЗаполнитьПоТокену(ТокенВниз, Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаТекстаРасширения);
			КонецЕсли;
		КонецЦикла;
	Иначе
		Если Ложь
			Или ИмяПравила = "<SelectRoot>"
			Или ИмяПравила = "<CreateRoot>"
			Или ИмяПравила = "<DropRoot>"
		Тогда
			ОбновитьДоступныеВременныеТаблицы();
			ЗапросПакета = ДобавитьЗапросПакета();
			Если ИмяПравила = "<DropRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 2;
				ЗапросПакета.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0));
				ЗапросПакета.ИмяВременнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(3));
			ИначеЕсли ИмяПравила = "<CreateRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 1;
			КонецЕсли; 
		ИначеЕсли ИмяПравила = "<ExtRoot>" Тогда
			ИндексЗапроса = Данные.Tokens(1).Data;
			ИндексЗапроса = Число(ИндексЗапроса);
			ЗапросПакета = ЗапросыПакета[ИндексЗапроса];
		ИначеЕсли ИмяПравила = "<ExtUnionPart>" Тогда
			ИндексЧасти = Данные.Tokens(1).Data;
			ИндексЧасти = Число(ИндексЧасти);
			ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[ИндексЧасти];
		ИначеЕсли Истина
			И ИмяПравила = "<TableWithName>"
			И КоличествоДочерних > 1
		Тогда
			ТекущийУзел = ДобавитьВыбраннуюТаблицу(ЧастьОбъединения);
			ТекущийУзел.Обязательная = Не РазборРасширений;
			ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		ИначеЕсли Истина
			И ИмяПравила = "<FromUnion>" 
			//И КоличествоДочерних > 1
		Тогда
			ТекущийУзел = ДобавитьВыбраннуюТаблицу(ЧастьОбъединения);
			ТекущийУзел.Обязательная = Не РазборРасширений;
			ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		ИначеЕсли Ложь
			Или ИмяПравила = "<SelectUnion>"
			Или ИмяПравила = "<CreateUnion>"
			Или ИмяПравила = "<SimpleUnion>"
		Тогда
			ЧастьОбъединения = ДобавитьЧастьОбъединения(ЗапросПакета);
		ИначеЕсли Ложь
			Или ИмяПравила = "<UnionPart>"
		Тогда
			ЧастьОбъединения = ДобавитьЧастьОбъединения(ЗапросПакета);
			ЧастьОбъединения.БезДублей = Данные.Tokens(1).Data.TokenCount = 0;
		ИначеЕсли Истина
			И ИмяПравила = "<Table>" 
			И Стек[1] = "<TableWithName>"
		Тогда
			ТекстОпределенияТаблицы = СобратьВыражениеЗапроса(Данные.Tokens(0),, ЗапросПакета, ЧастьОбъединения);
			ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
			//Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ТекстОпределенияТаблицы);
			//ПолноеИмя = "";
			//Для Каждого Фрагмент Из Фрагменты Цикл
			//	Если ПолноеИмя <> "" Тогда
			//		ПолноеИмя = ПолноеИмя + ".";
			//	КонецЕсли; 
			//	ПолноеИмя = ПолноеИмя + ПолучитьИмяБезКвадратныхСкобок(Фрагмент);
			//КонецЦикла;
			Если Найти(ТекстОпределенияТаблицы, ".") = 0 Тогда
				ПолноеИмя = ПолучитьИмяБезКвадратныхСкобок(ТекстОпределенияТаблицы);
			Иначе
				ПолноеИмя = ТекстОпределенияТаблицы;
			КонецЕсли; 
			ТекущийУзел.ПолноеИмя = ирОбщий.ПолучитьПервыйФрагментЛкс(ПолноеИмя, "(");
			//Перейти ~Выход; // Еще параметры виртуальной таблицы надо разбирать
		ИначеЕсли ИмяПравила = "<Into>" Тогда
			//ЗапросПакета.ТипЗапроса = 1;
			ЗапросПакета.ИмяВременнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(2));
			ОбновитьНаименованиеЗапроса(ЗапросПакета);
		КонецЕсли;
		Для ИндексТокена = 0 По КоличествоДочерних - 1 Цикл
			ТокенВниз = Данные.Tokens(ИндексТокена);
			Если ТокенВниз.Kind = 0 Тогда
				// Не терминальный токен
				ПсевдонимСнизу = ЗаполнитьПоТокену(ТокенВниз, Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаТекстаРасширения, ТекущаяСвязьТаблиц);
				Если ПсевдонимСнизу <> Неопределено Тогда 
					Если Ложь
						Или ИмяПравила = "<FromUnion>" 
						Или ИмяПравила = "<JoinSide>" 
						Или ИмяПравила = "<TableWithName>" 
						Или ИмяПравила = "<TablePseudoname>" 
					Тогда 
						Результат = ПсевдонимСнизу;
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если Ложь
		Или ИмяПравила = "<SelectRoot>"
		Или ИмяПравила = "<CreateRoot>"
		Или ИмяПравила = "<DropRoot>"
		Или ИмяПравила = "<EmbededRoot>"
	Тогда
		ОбработатьЗапросПослеУстановкиДанных(ЗапросПакета);
	КонецЕсли; 
	Если ТаблицаТекстаРасширения <> Неопределено Тогда
		// Расширения языка запросов 1С
		Если Ложь
			Или ИмяПравила = "<ParameterOfTable>"
		Тогда
			НачальныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 0);
			Если НачальныйТерминал <> Неопределено Тогда
				КонечныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 1);
				НачальноеКоличество = ТаблицаТекстаРасширения.Количество(); 
				ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(НачальныйТерминал);
				ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(КонечныйТерминал);
				Для СчетчикТаблицаТекстаРасширения = 1 По НачальноеКоличество Цикл
					СтрокаРасширения = ТаблицаТекстаРасширения[НачальноеКоличество - СчетчикТаблицаТекстаРасширения];
					Если Истина
						И СтрокаРасширения.Позиция >= ПозицияНачальногоТокена 
						И СтрокаРасширения.Позиция <= ПозицияКонечногоТокена
					Тогда
						Если ТекущийУзел.ТекстРасширения <> "" Тогда
							//ТекущийУзел.ТекстРасширения = ";" + ТекущийУзел.ТекстРасширения;
							ТекущийУзел.ТекстРасширения = Символы.ПС + ТекущийУзел.ТекстРасширения ;
						КонецЕсли; 
						ТекущийУзел.ТекстРасширения = СтрокаРасширения.Текст + ТекущийУзел.ТекстРасширения;
						ТаблицаТекстаРасширения.Удалить(СтрокаРасширения);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Если Ложь
			Или ИмяПравила = "<FromTables>"
		Тогда
			НачальныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 0);
			Если НачальныйТерминал <> Неопределено Тогда
				КонечныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 1);
				ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(НачальныйТерминал);
				ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(КонечныйТерминал);
				Для Каждого СтрокаРасширения Из ТаблицаТекстаРасширения Цикл
					Если Истина
						И СтрокаРасширения.Позиция >= ПозицияНачальногоТокена 
						И СтрокаРасширения.Позиция <= ПозицияКонечногоТокена
					Тогда
						СтрокаРасширения.Текст = "FROM #FixedTables# КАК FixedTables" + Символы.ПС + СтрокаРасширения.Текст;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Если Ложь
			Или (Истина
				И ИмяПравила = "<TableWithName>"
				И КоличествоДочерних > 1)
			Или (Истина
				И ИмяПравила = "<FromUnion>" 
				//И КоличествоДочерних > 1
				)
		Тогда
			НачальныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 0);
			Если НачальныйТерминал <> Неопределено Тогда
				ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(НачальныйТерминал);
				НачальноеКоличество = ТаблицаТекстаРасширения.Количество(); 
				Для СчетчикРасширения = 1 По НачальноеКоличество Цикл
					СтрокаРасширения = ТаблицаТекстаРасширения[НачальноеКоличество - СчетчикРасширения];
					Если Истина
						И СтрокаРасширения.Позиция <= ПозицияНачальногоТокена 
						И Лев(СтрокаРасширения.Текст, 1) = "#"
					Тогда
						ТекущийУзел.НомерГруппы = Число(Сред(СтрокаРасширения.Текст, 2));
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Если Ложь
			Или ИмяПравила = "<SelectUnion>"
			Или ИмяПравила = "<CreateUnion>"
			Или ИмяПравила = "<SimpleUnion>"
			Или ИмяПравила = "<UnionPart>"
		Тогда
			НачальныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 0);
			КонечныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 1);
			НачальноеКоличество = ТаблицаТекстаРасширения.Количество(); 
			ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(НачальныйТерминал);
			ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(КонечныйТерминал);
			Для СчетчикТаблицаТекстаРасширения = 1 По НачальноеКоличество Цикл
				ИндексРасширения = НачальноеКоличество - СчетчикТаблицаТекстаРасширения;
				СтрокаРасширения = ТаблицаТекстаРасширения[ИндексРасширения];
				Если Истина
					И СтрокаРасширения.Позиция >= ПозицияНачальногоТокена 
					И СтрокаРасширения.Позиция <= ПозицияКонечногоТокена
				Тогда
					Если ЧастьОбъединения.ТекстРасширения <> "" Тогда
						//ЧастьОбъединения.ТекстРасширения = "#" + ЧастьОбъединения.ТекстРасширения;
						ЧастьОбъединения.ТекстРасширения = Символы.ПС + ЧастьОбъединения.ТекстРасширения ;
					КонецЕсли; 
					ЧастьОбъединения.ТекстРасширения = "{#" + ИндексРасширения + "}" + СтрокаРасширения.Текст + ЧастьОбъединения.ТекстРасширения;
					ТаблицаТекстаРасширения.Удалить(СтрокаРасширения);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
		Если Ложь
			Или ИмяПравила = "<SelectRoot>"
			Или ИмяПравила = "<CreateRoot>"
			Или ИмяПравила = "<DropRoot>"
			Или ИмяПравила = "<EmbededRoot>"
		Тогда
			НачальныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 0);
			КонечныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 1);
			НачальноеКоличество = ТаблицаТекстаРасширения.Количество(); 
			ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(НачальныйТерминал);
			ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(КонечныйТерминал);
			Для СчетчикТаблицаТекстаРасширения = 1 По НачальноеКоличество Цикл
				СтрокаРасширения = ТаблицаТекстаРасширения[НачальноеКоличество - СчетчикТаблицаТекстаРасширения];
				Если Истина
					И СтрокаРасширения.Позиция >= ПозицияНачальногоТокена 
					И СтрокаРасширения.Позиция <= ПозицияКонечногоТокена
				Тогда
					Если ЗапросПакета.ТекстРасширения <> "" Тогда
						//ЗапросПакета.ТекстРасширения = "#" + ЗапросПакета.ТекстРасширения;
						ЗапросПакета.ТекстРасширения = Символы.ПС + ЗапросПакета.ТекстРасширения;
					КонецЕсли; 
					ЗапросПакета.ТекстРасширения = СтрокаРасширения.Текст + ЗапросПакета.ТекстРасширения;
					ТаблицаТекстаРасширения.Удалить(СтрокаРасширения);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
		Если Ложь
			Или ИмяПравила = "<ExtUnionPart>"
		Тогда
			СтрокаСлужебнойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти("#FixedTables#", "ПолноеИмя");
			Если СтрокаСлужебнойТаблицы <> Неопределено Тогда
				СтрокиСвязи = ЧастьОбъединения.СвязиТаблиц.НайтиСтроки(Новый Структура("Таблица", СтрокаСлужебнойТаблицы.Имя), Истина);
				Для Каждого СтрокаСвязи Из СтрокиСвязи Цикл
					СтрокаОбязательнойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(Истина, "Обязательная");
					Если СтрокаОбязательнойТаблицы <> Неопределено Тогда
						СтрокаСвязи.Таблица = СтрокаОбязательнойТаблицы.Имя;
					Иначе
						ЧастьОбъединения.СвязиТаблиц.Строки.Удалить(СтрокаСвязи);
					КонецЕсли; 
				КонецЦикла;
				ЧастьОбъединения.ВыбранныеТаблицы.Удалить(СтрокаСлужебнойТаблицы);
			КонецЕсли; 
			КонечныйТерминал = ПолучитьГраничныйТерминалПравила(Данные, 1);
			ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(КонечныйТерминал);
			НачальноеКоличество = ТаблицаТекстаРасширения.Количество(); 
			Для СчетчикРасширения = 1 По НачальноеКоличество Цикл
				СтрокаРасширения = ТаблицаТекстаРасширения[НачальноеКоличество - СчетчикРасширения];
				Если Истина
					И СтрокаРасширения.Позиция <= ПозицияКонечногоТокена 
					И Лев(СтрокаРасширения.Текст, 1) = "#"
				Тогда
					ТаблицаТекстаРасширения.Удалить(СтрокаРасширения);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли; 
	Стек.Удалить(0);
	Если ИндикаторБылСоздан = Истина Тогда
		ирОбщий.ОсвободитьИндикаторПроцессаЛкс(Индикатор);
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Знач Токен)

	Данные = Токен.Data;
	Токен = Данные.Tokens(Данные.TokenCount - 1);
	Если Токен = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Данные = Токен.Data;
	Токен = Данные.Tokens(Данные.TokenCount - 1);
	//ТекстИмени = Данные.Tokens(1).Data.Tokens(0).Data;
	ТекстИмени = ПолучитьТекстИзТокена(Токен);
	ТекущийУзел.Имя = ТекстИмени;
	ТекущийУзел.Имя = ПолучитьИмяБезКвадратныхСкобок(ТекущийУзел.Имя);
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел);

КонецПроцедуры

Функция ПроверитьДобавитьПараметр(выхИмяПараметра, ТипЗначения = Неопределено)

	ТекущийУзел = Параметры.Найти(НРег(выхИмяПараметра), "НИмя");
	Если ТекущийУзел = Неопределено Тогда
		ТекущийУзел = Параметры.Добавить();
		Если Не ЗначениеЗаполнено(выхИмяПараметра) Тогда
			выхИмяПараметра = ПолучитьСловоЯзыкаЗапросов("Parameter") + XMLСтрока(Параметры.Количество());
		КонецЕсли; 
		ТекущийУзел.Имя = выхИмяПараметра;
		ТекущийУзел.ТипЗначения = ТипЗначения;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел);
	КонецЕсли;
	//ТекущийУзел.ЧислоОбращений = ТекущийУзел.ЧислоОбращений + 1;
	Возврат ТекущийУзел;

КонецФункции

// Попытка оптимизации пересборки большого числа выражений
Функция ЛиВыражениеЯвляетсяПолем(ВыражениеЗапроса) Экспорт
	
	ВычислительРегулярныхВыражений = мПлатформа.RegExp;
	ФрагментШаблона = "[" + мПлатформа.шБуква + "][" + мПлатформа.шБуква + "\d]*|\[[^\]]+\]";
	ВычислительРегулярныхВыражений.Pattern = "^(?:" + ФрагментШаблона + "(?:\." + ФрагментШаблона + ")*)$";
	Результат = ВычислительРегулярныхВыражений.Test(ВыражениеЗапроса);
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПредставлениеЗначенияНаЯзыке(Знач Значение) Экспорт
	
	Если ТипЗнч(Значение) = Тип("ПолеКомпоновкиДанных") Тогда
		Результат = "" + Значение;
		ПолеПараметра = Результат;
		МассивСинонимов = Новый Массив();
		МассивСинонимов.Добавить("DataParameters");
		МассивСинонимов.Добавить("ПараметрыДанных");
		Для Каждого Синоним Из МассивСинонимов Цикл
			Если Найти(НРег(ПолеПараметра), НРег(Синоним + ".")) = 1 Тогда
				Результат = ПараметрыДиалектаSQL.ПрефиксПараметра;
				Если ПараметрыДиалектаSQL.ИменованныеПараметры Тогда
					Результат = Результат + Сред(ПолеПараметра, СтрДлина(Синоним + ".") + 1);
				КонецЕсли; 
				Прервать;
			КонецЕсли; 
		КонецЦикла;
		Если Не ЗначениеЗаполнено(Результат) Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("UNDEFINED");
		КонецЕсли; 
	ИначеЕсли ТипЗнч(Значение) = Тип("Неопределено") Тогда
		Результат = ПолучитьСловоЯзыкаЗапросов("UNDEFINED");
	Иначе
		Если ТипЗнч(Значение) = Тип("СтандартнаяДатаНачала") Тогда
			Значение = Значение.Дата;
		КонецЕсли; 
		Если ТипЗнч(Значение) = Тип("Дата") Тогда
			Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				Результат = "ДатаВремя(" + Формат(Значение, "ДФ='yyyy,MM,dd,  HH,mm,ss'; ДП=") + ")";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
				Значение = Значение - СмещениеСтандартногоВремени();
				Результат = "'" + Формат(Значение, "ДФ='yyyyMMdd HH:mm:ss'; ДП=") + "'";
			Иначе// Если ирОбщий.СтрокиРавныЛкс(КодЯзыка, "WQL") Тогда
				Результат = "'" + Формат(Значение, "ДФ='yyyyMMdd HH:mm:ss'; ДП=") + "'";
			КонецЕсли; 
		ИначеЕсли ТипЗнч(Значение) = Тип("Число") Тогда
			Результат = XMLСтрока(Значение);
		ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда
			Если Значение Тогда
				Результат = ПолучитьСловоЯзыкаЗапросов("TRUE");
			Иначе
				Результат = ПолучитьСловоЯзыкаЗапросов("FALSE");
			КонецЕсли; 
		ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда
			Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				Результат = """" + СтрЗаменить(Значение, """", """""") + """";
			Иначе
				Результат = "'" + Значение + "'";
			КонецЕсли; 
		Иначе
			ВызватьИсключение "Для типа значения """ + ТипЗнч(Значение) + """ не определено отображение в язык запросов";
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПредставлениеСравненияНаЯзыке(ПредставлениеЛевогоПоля, Знач ВидСравнения, ДоступноеПолеИлиОписаниеТипов = Неопределено, Отступ = "") Экспорт
	
	Результат = ПредставлениеЛевогоПоля + " ";
	Если ВидСравнения = ВидСравненияКомпоновкиДанных.Равно Тогда
		Результат = Результат + "=";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно Тогда
		Результат = Результат + "<>";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.Больше Тогда
		Результат = Результат + ">";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно Тогда
		Результат = Результат + ">=";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.Меньше Тогда
		Результат = Результат + "<";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно Тогда
		Результат = Результат + "<=";
	ИначеЕсли Ложь
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит 
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.НеСодержит
	Тогда
		Результат = Результат + ПолучитьСловоЯзыкаЗапросов("LIKE");
		Если ВидСравнения = ВидСравненияКомпоновкиДанных.НеСодержит Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("NOT") + " " + Результат;
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено 
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено 
	Тогда
		Если ТипЗнч(ДоступноеПолеИлиОписаниеТипов) = Тип("ОписаниеТипов") Тогда
			ОписаниеТипов = ДоступноеПолеИлиОписаниеТипов;
			ТипыПоля = ОписаниеТипов.Типы();
		Иначе
			ОписаниеТипов = ДоступноеПолеИлиОписаниеТипов.ТипЗначения;
			ТипыПоля = ОписаниеТипов.Типы();
			Если Истина
				И ДоступноеПолеИлиОписаниеТипов.Родитель <> Неопределено 
				И Не ДоступноеПолеИлиОписаниеТипов.Родитель.Папка 
			Тогда
				ТипыПоля.Добавить(Тип("Null"));
			КонецЕсли; 
		КонецЕсли; 
		Смещение = ирОбщий.ПолучитьСтрокуПовторомЛкс(Символы.Таб, Отступ);
		ПредставлениеСписка = "";
		Если ТипыПоля.Количество() > 1 Тогда
			ПредставлениеСписка = ПолучитьСловоЯзыкаЗапросов("UNDEFINED");
		КонецЕсли;
		СписокВыражений = Новый СписокЗначений;
		Для Каждого Тип Из ТипыПоля Цикл
			Если Тип = Тип("Null") Тогда
				Продолжить;
			КонецЕсли; 
			СписокВыражений.Добавить(ирОбщий.ПолучитьКонстантуТипаЗапросаЛкс(Тип, ОписаниеТипов));
		КонецЦикла;
		СписокВыражений.СортироватьПоЗначению();
		Для Каждого ЭлементСписка Из СписокВыражений Цикл
			Если ПредставлениеСписка <> "" Тогда
				ПредставлениеСписка = ПредставлениеСписка + ", " + Символы.ПС + Смещение;
			КонецЕсли; 
			ПредставлениеСписка = ПредставлениеСписка + ЭлементСписка.Значение;
		КонецЦикла;
		Если ТипыПоля.Найти(Тип("Null")) <> Неопределено Тогда
			Результат1 = ПолучитьСловоЯзыкаЗапросов("IS");
			Результат2 = ПолучитьСловоЯзыкаЗапросов("NULL");
			Результат = Результат + Результат1 + " " + Результат2;
			Если ПредставлениеСписка <> "" Тогда
				Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("OR") + " " + ПредставлениеЛевогоПоля + " ";
			КонецЕсли; 
		КонецЕсли; 
		Если ПредставлениеСписка <> "" Тогда
			Результат = Результат + ПолучитьСловоЯзыкаЗапросов("IN") + " (" + ПредставлениеСписка + ")";
		КонецЕсли; 
		Если ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("NOT") + " (" + Результат + ")";
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии 
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии
	Тогда
		Результат1 = ПолучитьСловоЯзыкаЗапросов("IN");
		Результат2 = ПолучитьСловоЯзыкаЗапросов("HIERARCHY");
		Результат = Результат + Результат1 + " " + Результат2;
		Если ВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("NOT") + " " + Результат;
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке 
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке
	Тогда
		Результат1 = ПолучитьСловоЯзыкаЗапросов("IN");
		Результат = Результат + Результат1 + " " + Результат2;
		Если ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("NOT") + " " + Результат;
		КонецЕсли; 
	Иначе
		ВызватьИсключение "Вид сравнения " + ВидСравнения + " компоновки не поддерживается";
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПолноеИмяПоляВВыражении(ИмяПоля, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, СтароеИмяТаблицы = "",
	НовоеИмяТаблицы = "", РазрешитьНормализациюИмен = Истина, НужноПересобратьТокены = Ложь) Экспорт

	Результат = ИмяПоля;
	Если Истина
		И ПараметрыДиалектаSQL.МногоТаблиц
		И ЧастьОбъединения <> Неопределено 
	Тогда // Пока не проверяем другие выражения
		ПозицияТочки = Найти(Результат, ".");
		Если Истина
			И РазрешитьНормализациюИмен
			И ПозицияТочки = 0 
		Тогда
			//ОбновитьДоступныеВременныеТаблицы(); // Неоптимально?
			Для Каждого ГруппаПолей Из ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы Цикл
				ДоступноеПоле = ГруппаПолей.Элементы.Найти("" + ГруппаПолей.Поле + "." + Результат);
				Если ДоступноеПоле <> Неопределено Тогда
					Результат = "" + ДоступноеПоле.Поле;
					// Правильно было бы проверить и другие таблицы для исключения неоднозначности привязки поля к таблице
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		ИначеЕсли ЗначениеЗаполнено(СтароеИмяТаблицы) Тогда
			ИмяТаблицыПоля = Лев(Результат, ПозицияТочки - 1);
			Если ирОбщий.СтрокиРавныЛкс(ИмяТаблицыПоля, СтароеИмяТаблицы) Тогда
				Результат = НовоеИмяТаблицы + "." + Сред(Результат, ПозицияТочки + 1);
				НужноПересобратьТокены = Истина;
			КонецЕсли; 
		КонецЕсли; 
		Если РасширеннаяПроверка Тогда
			ПолеКомпоновки = Новый ПолеКомпоновкиДанных(Результат);
			ДоступноеПоле = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.НайтиПоле(ПолеКомпоновки);
			Если ДоступноеПоле = Неопределено Тогда
				ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = ЗапросПакета;
				ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = ЧастьОбъединения;
				ВызватьИсключение "Поле """ + ИмяПоля + """ не найдено";
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ДобавитьПробелПослеТокена(Текст, ИмяПредыдущегоТокенаВниз)

	Если Истина // После них не ставим пробел
		И ИмяПредыдущегоТокенаВниз <> "."
		И ИмяПредыдущегоТокенаВниз <> "("
		И ИмяПредыдущегоТокенаВниз <> "&"
		И ИмяПредыдущегоТокенаВниз <> "?"
		И ИмяПредыдущегоТокенаВниз <> "@"
	Тогда
		Текст = Текст + " ";
	КонецЕсли; 

КонецПроцедуры

Функция ПолучитьСловоЯзыкаЗапросов(Слово) Экспорт

	Результат = Неопределено;
	Если ирОбщий.СтрокиРавныЛкс("AS", Слово) Тогда
		Если Не ПараметрыДиалектаSQL.КАК Тогда
			Результат = "";
		КонецЕсли;
	КонецЕсли; 
	Если Результат = Неопределено Тогда
		Если Истина
			И ПараметрыДиалектаSQL.Это1С
			И Не Английский1С
		Тогда
			Результат = мТерминалыЯзыкаЗапросов[Слово];
		Иначе
			Результат = Слово;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Параметры:
//   РазрешитьНормализациюИмен - Булево - делать ли преобразование коротких имен полей к длинным (с именем таблицы)
//
Функция СобратьВыражениеЗапроса(Токен, Отступ = 0, Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено,
	СтароеИмяТаблицы = "", НовоеИмяТаблицы = "", выхЕстьАгрегаты = Ложь, РазрешитьНормализациюИмен = Истина, НужноПересобратьТокены = Неопределено) Экспорт
	
	Если НужноПересобратьТокены = Неопределено Тогда
		НужноПересобратьТокены = Ложь;
	КонецЕсли; 
	Данные = Токен.Data;
	Если Данные = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Токен.Kind = 1 Тогда
		Возврат Данные;
	КонецЕсли; 
	ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
	Если Ложь
		Или ИмяПравила = "<Parameter>"
		Или ИмяПравила = "<TableParameter>"
	Тогда
		ВыражениеПараметра = Данные.Tokens(0).Data;
		Если СтароеИмяТаблицы = ВыражениеПараметра Тогда
			ВыражениеПараметра = НовоеИмяТаблицы;
			НужноПересобратьТокены = Истина;
		КонецЕсли; 
		//ИмяПараметра = Данные.Tokens(1).Data.Tokens(0).Data;
		ИмяПараметра = Сред(ВыражениеПараметра, 2);
		ОписаниеТиповПараметра = Неопределено;
		Если ИмяПравила = "<TableParameter>" Тогда
			ОписаниеТиповПараметра = Новый ОписаниеТипов("ТаблицаЗначений");
		КонецЕсли; 
		ПроверитьДобавитьПараметр(ИмяПараметра, ОписаниеТиповПараметра);
		Результат = мПараметрыДиалектаSQL.ПрефиксПараметра + ИмяПараметра;
	Иначе
		Если ИмяПравила = "<Agregate>" Тогда
			выхЕстьАгрегаты = Истина;
		КонецЕсли; 
		ЧислоТокенов = Данные.TokenCount;
		Результат = "";
		ЛевыйОтступ = ирОбщий.ПолучитьСтрокуПовторомЛкс(Символы.Таб, Отступ);
		Если ИмяПравила = "<Case>" Тогда
			ВыражениеВыбора = СобратьВыражениеЗапроса(Данные.Tokens(1), Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
				выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
			Результат = ПолучитьСловоЯзыкаЗапросов("CASE");
			Если ЗначениеЗаполнено(ВыражениеВыбора) Тогда
				Результат = Результат + " " + ВыражениеВыбора;
			КонецЕсли;
			Результат = Результат + СобратьВыражениеЗапроса(Данные.Tokens(2), Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
				выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены) + "
			|" + ЛевыйОтступ + "	" + СобратьВыражениеЗапроса(Данные.Tokens(3), Отступ + 1, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
				выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены) + "
			|" + ЛевыйОтступ + ПолучитьСловоЯзыкаЗапросов("END");
		ИначеЕсли ИмяПравила = "<WhenThen>" Тогда
			Результат = "
			|" + ЛевыйОтступ + "	" + ПолучитьСловоЯзыкаЗапросов("WHEN") + " " + СобратьВыражениеЗапроса(Данные.Tokens(1), Отступ + 1, ЗапросПакета, ЧастьОбъединения,
				СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены) + "
			|" + ЛевыйОтступ + "		" + ПолучитьСловоЯзыкаЗапросов("THEN") + " " + СобратьВыражениеЗапроса(Данные.Tokens(3), Отступ + 1, ЗапросПакета, ЧастьОбъединения,
				СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
			Если ЧислоТокенов > 4 Тогда
				Результат = Результат + СобратьВыражениеЗапроса(Данные.Tokens(4), Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
					выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
			КонецЕсли; 
		ИначеЕсли Ложь
			Или ИмяПравила = "<AndExpr>"
			Или ИмяПравила = "<OrExpr>"
		Тогда
			Результат = СобратьВыражениеЗапроса(Данные.Tokens(0), Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты,
				РазрешитьНормализациюИмен, НужноПересобратьТокены) + "
			|" + ЛевыйОтступ + "	" + Данные.Tokens(1).Data + " " + СобратьВыражениеЗапроса(Данные.Tokens(2), Отступ, ЗапросПакета, ЧастьОбъединения,
				СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
		ИначеЕсли ИмяПравила = "<EmbededQuery>" Тогда
			ВнутреннийТокен = Данные.Tokens(1);
			Если ВнутреннийТокен.Name = "EmbededRoot" Тогда
				Пакет =  ЗапросыПакета.СкопироватьКолонки();
				ЗапросПакета = ДобавитьЗапросПакета(Пакет);
				ЗаполнитьПоТокену(ВнутреннийТокен, , ЗапросПакета, ЧастьОбъединения, Null);
				ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
				Результат = "(" + Символы.ПС + ЛевыйОтступ + Символы.Таб + СобратьТекстПакета(Пакет, Символы.Таб) + ")";
			Иначе
				Результат = "(" + СобратьВыражениеЗапроса(ВнутреннийТокен,,,,,,,, НужноПересобратьТокены) + ")";
			КонецЕсли; 
		Иначе
			ИмяПредыдущегоТокена = Неопределено;
			ЗапретитьПробелы = Ложь
				Или ИмяПравила = "<MultiField>" 
				Или ИмяПравила = "<MultiFieldBody>";
			Для ИндексТокена = 0 По Данные.TokenCount - 1 Цикл
				ТокенВниз = Данные.Tokens(ИндексТокена);
				Если Истина
					И (Ложь
						Или ИмяПравила = "<Exprs>"
						Или ИмяПравила = "<NamedExprs>")
					И ИмяПредыдущегоТокена = ","
				Тогда
					Результат = Результат + Символы.ПС + ЛевыйОтступ;
				КонецЕсли; 
				Если ТокенВниз.Kind = 0 Тогда
					Если Истина 
						И Результат <> "" 
						И Не ЗапретитьПробелы
					Тогда
						ДобавитьПробелПослеТокена(Результат, ИмяПредыдущегоТокена);
					КонецЕсли; 
					// Не терминальный токен
					РезультатСнизу = СобратьВыражениеЗапроса(ТокенВниз, Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
						выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
					ИмяПредыдущегоТокена = Неопределено;
				Иначе
					ИмяТокена = ТокенВниз.Name;
					// Терминальный токен
					Если Ложь // Перед ними не ставим пробел
						Или ИмяТокена = ")"
						Или ИмяТокена = "]"
						Или ИмяТокена = ","
						Или ИмяТокена = "."
						Или ИмяТокена = ".*"
						Или (Истина
							И ИндексТокена = 1
							И ИмяТокена = "(")
					Тогда
						РезультатСнизу = ТокенВниз.Data;
					ИначеЕсли Ложь
						Или ИмяТокена = "id"
						Или ИмяТокена = "BadID"
						Или ИмяТокена = "strLiteral"
						Или ИмяТокена = "numLiteral" 
						Или ИмяТокена = "Parameter" 
						Или ИмяТокена = "MultiCommentLine"
						Или ИмяТокена = "COMP_OPERATOR"
						Или ИмяТокена = "("
						Или ИмяТокена = "["
						Или ИмяТокена = "&"
						Или ИмяТокена = "?"
						Или ИмяТокена = "@"
						Или ИмяТокена = "+"
						Или ИмяТокена = "-"
						Или ИмяТокена = "*"
						Или ИмяТокена = "/"
					Тогда
						Если Результат <> "" Тогда
							ДобавитьПробелПослеТокена(Результат, ИмяПредыдущегоТокена);
						КонецЕсли; 
						РезультатСнизу = ТокенВниз.Data;
					Иначе
						Если Ложь
							Или ИмяПравила = "<ID>"
							Или ИмяПравила = "<SmartAS>"
							Или ИмяПравила = "<TableAS>"
						Тогда
							РезультатСнизу = ТокенВниз.Data;
						Иначе
							Если Результат <> "" Тогда
								ДобавитьПробелПослеТокена(Результат, ИмяПредыдущегоТокена);
							КонецЕсли; 
							РезультатСнизу = ПолучитьСловоЯзыкаЗапросов(ИмяТокена);
						КонецЕсли; 
					КонецЕсли; 
					ИмяПредыдущегоТокена = ИмяТокена;
				КонецЕсли;
				Результат = Результат + РезультатСнизу;
			КонецЦикла;
		КонецЕсли;
		Если ИмяПравила = "<Field>" Тогда
			Результат = ПолучитьПолноеИмяПоляВВыражении(Результат, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, РазрешитьНормализациюИмен,
				НужноПересобратьТокены);
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьАгрегатнуюФункцию(Токен, выхТокенАргументаФункции = Неопределено) Экспорт
	
	Результат = Неопределено;
	Если ТипЗнч(Токен) <> Тип("COMОбъект") Тогда
		Возврат Результат;
	КонецЕсли; 
	Данные = Токен.Data;
	Если Данные = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	выхТокенАргументаФункции = Токен;
	Если Токен.Kind = 0 Тогда
		КоличествоТокенов = Данные.TokenCount;
		ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
		Если ИмяПравила = "<Brackets>" Тогда
			Результат = ПолучитьАгрегатнуюФункцию(Данные.Tokens(1), выхТокенАргументаФункции);
		ИначеЕсли ИмяПравила = "<Agregate>" Тогда
			ТокенВниз = Данные.Tokens(0);
			Если ТокенВниз.Kind = 1 Тогда
				Результат = ТокенВниз.Name + "(";
				выхТокенАргументаФункции = Данные.Tokens(2);
			Иначе
				Результат = ПолучитьАгрегатнуюФункцию(ТокенВниз, выхТокенАргументаФункции);
			КонецЕсли; 
		ИначеЕсли ИмяПравила = "<Count>" Тогда
			ТокенВниз = Данные.Tokens(КоличествоТокенов - 2);
			Если ТокенВниз.Kind = 0 Тогда
				Результат = "COUNT" + "(";
				Если КоличествоТокенов = 5 Тогда 
					Результат = Результат + " DISTINCT";
					выхТокенАргументаФункции = Данные.Tokens(3);
				Иначе
					выхТокенАргументаФункции = Данные.Tokens(2);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли КоличествоТокенов = 1 Тогда
			Результат = ПолучитьАгрегатнуюФункцию(Данные.Tokens(0), выхТокенАргументаФункции);
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен, Отступ = 0, ЧастьОбъединения = Неопределено)
	
	ЕстьАгрегаты = Ложь;
	Представление = СобратьВыражениеЗапроса(Токен, Отступ,,ЧастьОбъединения,,, ЕстьАгрегаты);
	Если ЕстьАгрегаты Тогда
		ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("");
	Иначе
		ЭлементОтбора.ЛевоеЗначение = Неопределено;
	КонецЕсли; 
	ЭлементОтбора.ПравоеЗначение = Токен;
	ЭлементОтбора.Представление = Представление;
	
КонецПроцедуры

Функция ПолучитьВыражениеЭлементаОтбораЛкс(ЭлементОтбора, Знач Отступ = 0, Знач ГруппаИзОдногоЭлемента = Ложь, выхЕстьАгрегаты = Ложь, НастройкиКомпоновки = Неопределено) Экспорт

	Если НастройкиКомпоновки = Неопределено Тогда
		НастройкиКомпоновки = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока.Компоновщик.Настройки;
		#Если _ Тогда
		    НастройкиКомпоновки = Новый НастройкиКомпоновкиДанных;
		#КонецЕсли
	КонецЕсли;
	Если ГруппаИзОдногоЭлемента Тогда
		Отступ = Макс(Отступ - 1, 0);
	КонецЕсли; 
	Смещение = ирОбщий.ПолучитьСтрокуПовторомЛкс(Символы.Таб, Отступ);
	Если ЗначениеЗаполнено(ЭлементОтбора.Представление) Тогда
		Представление = ЭлементОтбора.Представление;
		Если ЭлементОтбора.ПравоеЗначение = Неопределено Тогда
			Токен = РазобратьВыражениеЗапроса(Представление);
			ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен,  Отступ);
		КонецЕсли; 
		ПредставлениеЭлемента = "";
		Если ЭлементОтбора.ЛевоеЗначение <> Неопределено Тогда
			выхЕстьАгрегаты = Истина;
		КонецЕсли;
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ПредставлениеЭлемента, Представление, Смещение);
		Если Истина
			И Не ЛиВыражениеЯвляетсяПолем(Представление)
			И Не ГруппаИзОдногоЭлемента 
		Тогда
			ПредставлениеЭлемента = "(" + ПредставлениеЭлемента + ")";
		КонецЕсли; 
	Иначе
		Если ТипЗнч(ЭлементОтбора.ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
			ДоступноеПолеИлиОписаниеТипов = НастройкиКомпоновки.ДоступныеПоляОтбора.НайтиПоле(ЭлементОтбора.ЛевоеЗначение);
			Если ДоступноеПолеИлиОписаниеТипов = Неопределено Тогда
				ДоступноеПолеИлиОписаниеТипов = Новый ОписаниеТипов("NULL");
			КонецЕсли;
		Иначе
			МассивТипов = Новый Массив();
			МассивТипов.Добавить(ТипЗнч(ЭлементОтбора.ЛевоеЗначение));
			ДоступноеПолеИлиОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
		КонецЕсли; 
		ПредставлениеЛевогоПоля = ПолучитьПредставлениеЗначенияНаЯзыке(ЭлементОтбора.ЛевоеЗначение);
		ПредставлениеЭлемента = ПолучитьПредставлениеСравненияНаЯзыке(ПредставлениеЛевогоПоля, ЭлементОтбора.ВидСравнения, ДоступноеПолеИлиОписаниеТипов, Отступ + 1);
		Если Истина
			И ЭлементОтбора.ВидСравнения <> ВидСравненияКомпоновкиДанных.Заполнено
			И ЭлементОтбора.ВидСравнения <> ВидСравненияКомпоновкиДанных.НеЗаполнено
		Тогда
			ПравоеЗначение = ЭлементОтбора.ПравоеЗначение;
			Если ТипЗнч(ПравоеЗначение) <> Тип("ПолеКомпоновкиДанных") Тогда
				XMLТип = СериализаторXDTO.XMLТипЗнч(ПравоеЗначение);
				Если XMLТип <> Неопределено Тогда
					Если Истина
						И Найти(XMLТип.URIПространстваИмен, "http://v8.1c.ru/8.1/data") > 0
						И Не ирОбщий.СтрокиРавныЛкс(XMLТип.URIПространстваИмен, "StandardBeginningDate")
					Тогда
						СтрокаПараметра = Параметры.Найти(ПравоеЗначение, "Значение");
						Если СтрокаПараметра = Неопределено Тогда
							ИмяПараметра = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Параметры, "" + ПравоеЗначение,,, ПолучитьСловоЯзыкаЗапросов("Parameter"));
							СтрокаПараметра = Параметры.Добавить();
							СтрокаПараметра.Имя = ИмяПараметра;
							СтрокаПараметра.Значение = ПравоеЗначение;
							ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
						КонецЕсли; 
						МассивТипов = Новый Массив();
						МассивТипов.Добавить(ТипЗнч(ПравоеЗначение));
						СтрокаПараметра.ТипЗначения = Новый ОписаниеТипов(СтрокаПараметра.ТипЗначения, МассивТипов);
						//СтрокаПараметра.ЧислоОбращений = СтрокаПараметра.ЧислоОбращений + 1;
						ПравоеЗначение = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + ИмяПараметра);
						ЭлементОтбора.ПравоеЗначение = ПравоеЗначение;
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
			СтрокаПравогоЗначения = ПолучитьПредставлениеЗначенияНаЯзыке(ПравоеЗначение);
			Если Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеСодержит
			Тогда
				Если ТипЗнч(ПравоеЗначение) = Тип("Строка") Тогда
					СтрокаПравогоЗначения = ПолучитьПредставлениеЗначенияНаЯзыке("%" + ПравоеЗначение + "%");
				КонецЕсли; 
			ИначеЕсли Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке 
			Тогда
				СтрокаПравогоЗначения = "(" + СтрокаПравогоЗначения + ")";
			КонецЕсли;
			ПредставлениеЭлемента = ПредставлениеЭлемента + " " + СтрокаПравогоЗначения;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ПредставлениеЭлемента;

КонецФункции

// Параметры:
//  ФильтрацияАгрегатов - 
//		0 - не фильтровать
// 		1 - собирать только элементы без агрегатов
//		2 - собирать только элементы с агрегатами
//
Функция ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ГруппаОтбора, Отступ = 0, ФильтрацияАгрегатов = 0, выхЕстьАгрегаты = Ложь, НастройкиКомпоновки = Неопределено) Экспорт 
	
	#Если _ Тогда
		_Н = Новый НастройкиКомпоновкиДанных;
	    ГруппаОтбора = _Н.Отбор;
	#КонецЕсли
	Если ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		ТипГруппы = ГруппаОтбора.ТипГруппы;
	Иначе
		ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
	КонецЕсли;
	Смещение = ирОбщий.ПолучитьСтрокуПовторомЛкс(Символы.Таб, Отступ);
	СтрокаНе = "NOT";
	ЗначениеXDTO = СериализаторXDTO.ЗаписатьXDTO(ТипГруппы);
	Если ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе Тогда
		ОператорГруппы = "AND";
	Иначе
		ОператорГруппы = ВРег(СтрЗаменить(ЗначениеXDTO.ЛексическоеЗначение, "Group", ""));
	КонецЕсли; 
	ОператорГруппы = ПолучитьСловоЯзыкаЗапросов(ОператорГруппы);
	СтрокаНе = ПолучитьСловоЯзыкаЗапросов(СтрокаНе);
	ТекстГруппы = "";
	ГруппаИзОдногоЭлемента = ГруппаОтбора.Элементы.Количество() = 1;
	выхЕстьАгрегаты = Ложь;
	Для Каждого ЭлементОтбора Из ГруппаОтбора.Элементы Цикл
		Если Не ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли; 
		ПредставлениеЭлемента = "";
		ЕстьАгрегаты = Ложь;
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			ПредставлениеЭлемента = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЭлементОтбора, Отступ + 1, ФильтрацияАгрегатов, ЕстьАгрегаты, НастройкиКомпоновки);
			Если Истина
				И Не ГруппаИзОдногоЭлемента 
				И ЭлементОтбора.ТипГруппы <> ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе
			Тогда
				ПредставлениеЭлемента = "(" + ПредставлениеЭлемента + ")";
			КонецЕсли;
		Иначе
			ПредставлениеЭлемента = ПолучитьВыражениеЭлементаОтбораЛкс(ЭлементОтбора, Отступ + 1, ГруппаИзОдногоЭлемента, ЕстьАгрегаты, НастройкиКомпоновки);
		КонецЕсли; 
		Если Ложь
			Или ТипЗнч(ГруппаОтбора) <> Тип("ОтборКомпоновкиДанных")
			Или ФильтрацияАгрегатов = 0
			Или (Истина
				И ФильтрацияАгрегатов = 1 
				И Не ЕстьАгрегаты)
			Или (Истина
				И ФильтрацияАгрегатов = 2 
				И ЕстьАгрегаты)
		Тогда
			Если ТекстГруппы <> "" Тогда
				ТекстГруппы = ТекстГруппы + Символы.ПС + Смещение + ОператорГруппы + " ";
			КонецЕсли; 
			ТекстГруппы = ТекстГруппы + ПредставлениеЭлемента;
		КонецЕсли;
		выхЕстьАгрегаты = выхЕстьАгрегаты Или ЕстьАгрегаты;
	КонецЦикла;
	Если Истина
		И ТекстГруппы <> "" 
		И (Ложь
			Или Отступ > 0
			Или ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе)
	Тогда
		//ТекстГруппы = "(" + ТекстГруппы + ")";
		Если ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе Тогда
			ТекстГруппы = СтрокаНе + " (" + ТекстГруппы + ")";
		КонецЕсли;
	КонецЕсли;
	Возврат ТекстГруппы;
	
КонецФункции

Функция РазобратьВыражениеЗапроса(ВыражениеЗапроса) Экспорт
	
	ТекстДляРазбора = "ВЫБРАТЬ " + Символы.ПС + ВыражениеЗапроса + " КАК _";
	//НачальныйТокен = РазобратьТекстЗапроса(ТекстДляРазбора, Истина, Ложь); // Сокращенное дерево не даст общими методами строить вложенные запросы
	НачальныйТокен = РазобратьТекстЗапроса(ТекстДляРазбора, , Ложь);
	Если НачальныйТокен = Неопределено Тогда
		ВызватьИсключение "Ошибка синтаксического разбора выражения """ + ВыражениеЗапроса + """";
	КонецЕсли; 
	//НачальныйТокен = НачальныйТокен.Data.Tokens(0).Data.Tokens(3).Data.Tokens(1); // При сокращенном дереве
	НачальныйТокен = НачальныйТокен.Data.Tokens(0).Data.Tokens(0).Data.Tokens(0).Data.Tokens(0).Data.Tokens(3).Data.Tokens(0).Data.Tokens(1);
	Возврат НачальныйТокен;
	
КонецФункции

Функция ДобавитьЧастьОбъединения(ЗапросПакета)

	ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения.Добавить();
	ЧастьОбъединения.Номер = ЗапросПакета.ЧастиОбъединения.Количество();
	ЧастьОбъединения.ВыбранныеТаблицы = ВыбранныеТаблицы.СкопироватьКолонки();
	ЧастьОбъединения.ВыбранныеПоля = ВыбранныеПоля.СкопироватьКолонки();
	ЧастьОбъединения.СвязиТаблиц = ирОбщий.СкопироватьКолонкиДереваЗначенийЛкс(СвязиТаблиц);
	ЧастьОбъединения.Группировки = Группировки.СкопироватьКолонки();
	ЧастьОбъединения.ПоляВыбораПостроителя = ПоляВыбораПостроителя.СкопироватьКолонки();
	ЧастьОбъединения.ПоляОтбораПостроителя = ПоляОтбораПостроителя.СкопироватьКолонки();
	ЧастьОбъединения.ОпцияРазличные = Ложь;
	ЧастьОбъединения.Автогруппировки = Истина;
	//ЧастьОбъединения.Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
	ЧастьОбъединения.Условие = ЧастьОбъединения.Компоновщик.Настройки;
	ОбновитьНаименованиеЧасти(ЧастьОбъединения);
	Возврат ЧастьОбъединения;

КонецФункции

Функция ДобавитьЗапросПакета(Пакет = Неопределено, Позиция = Неопределено)

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
	КонецЕсли; 
	Если Позиция = Неопределено Тогда
		ЗапросПакета = Пакет.Добавить();
	Иначе
		ЗапросПакета = Пакет.Вставить(Позиция);
	КонецЕсли; 
	ЗапросПакета.ИД = Новый УникальныйИдентификатор();
	ЗапросПакета.Индекс = ЗапросыПакета.Количество() - 1;
	ЗапросПакета.ЧастиОбъединения = ЧастиОбъединения.СкопироватьКолонки();
	ЗапросПакета.ПоляОбъединения = ПоляОбъединения.СкопироватьКолонки();
	ЗапросПакета.ГруппирующиеПоляИтогов = ГруппирующиеПоляИтогов.СкопироватьКолонки();
	ЗапросПакета.ГруппируемыеПоляИтогов = ГруппируемыеПоляИтогов.СкопироватьКолонки();
	ЗапросПакета.ПоляПорядкаПостроителя = ПоляПорядкаПостроителя.СкопироватьКолонки();
	ЗапросПакета.ПоляИтоговПостроителя = ПоляИтоговПостроителя.СкопироватьКолонки();
	ЗапросПакета.ОпцияОбщиеИтоги = Ложь;
	ЗапросПакета.ОпцияПервые = Ложь;
	ЗапросПакета.ОпцияРазрешенные = Ложь;
	ЗапросПакета.ОпцияАвтоупорядочивание = Ложь;
	ЗапросПакета.ПервыеКоличество = 0;
	ЗапросПакета.ИмяВременнойТаблицы = "";
	ЗапросПакета.ПоляПорядка = ПоляПорядка.СкопироватьКолонки();
	ЗапросПакета.ПоляИндекса = ПоляИндекса.СкопироватьКолонки();
	ЗапросПакета.ТипЗапроса = 0;
	ОбновитьНаименованиеЗапроса(ЗапросПакета);
	Возврат ЗапросПакета;

КонецФункции

Функция ДобавитьВыбраннуюТаблицу(ЧастьОбъединения = Неопределено)
	
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Добавить();
	ВыбраннаяТаблица.Параметры = ПараметрыТаблицы.СкопироватьКолонки();
	Возврат ВыбраннаяТаблица;
	
КонецФункции

Функция ПолучитьИмяБезКвадратныхСкобок(Имя)
	
	Результат = Имя;
	Если Лев(Результат, 1) = "[" Тогда
		Результат = Сред(Результат, 2, СтрДлина(Результат) - 2);
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ОпуститьсяДоПервогоЗначимогоТокена(Токен)

	Если Токен.Kind = 0 Тогда
		Возврат Токен;
	КонецЕсли; 
	Данные = Токен.Data;
	ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
	Если ИмяПравила = "<Brackets>" Тогда
		ЗначимыйТокен = ОпуститьсяДоПервогоЗначимогоТокена(Данные.Tokens(1));
		Возврат ЗначимыйТокен;
	ИначеЕсли Данные.TokenCount > 1  Тогда
		Возврат Токен;
	Иначе
		ПервыйТокен = Данные.Tokens(0);
		Если ПервыйТокен.Kind <> 0 Тогда
			Возврат Токен;
		Иначе
			Возврат ОпуститьсяДоПервогоЗначимогоТокена(ПервыйТокен);
		КонецЕсли; 
	КонецЕсли;
	
КонецФункции

Процедура ПостроитьДеревоЛогическогоВыражения(ГруппаОтбора, Токен, ЗапросПакета, ЧастьОбъединения)

	#Если _ Тогда
	    ОтборКомпоновки1 = Новый НастройкиКомпоновкиДанных;
		ГруппаОтбора = ОтборКомпоновки1.Отбор;
	#КонецЕсли
	Если Токен = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если Токен.Kind = 1 Тогда
		ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбора.ПравоеЗначение = Токен;
		Если Ложь
			Или Токен.Name = "TRUE"
			Или Токен.Name = "FALSE"
		Тогда
			ЭлементОтбора.Представление = ПолучитьСловоЯзыкаЗапросов(Токен.Name);
		Иначе
			ЭлементОтбора.Представление = Токен.Data;
		КонецЕсли; 
		Возврат;
	КонецЕсли; 
	Данные = Токен.Data;
	Если Данные.TokenCount = 0 Тогда
		Возврат;
	ИначеЕсли Данные.TokenCount = 1 Тогда
		ПостроитьДеревоЛогическогоВыражения(ГруппаОтбора, Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
	Иначе
		ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
		Если ИмяПравила = "<OrExpr>" Тогда
			Если Истина
				И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
				И ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
			Тогда
				ГруппаИли = ГруппаОтбора;
			Иначе
				ГруппаИли = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
				ГруппаИли.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
			КонецЕсли; 
			ПостроитьДеревоЛогическогоВыражения(ГруппаИли, Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
			ПостроитьДеревоЛогическогоВыражения(ГруппаИли, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ИначеЕсли ИмяПравила = "<AndExpr>" Тогда
			Если Истина
				И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
				И ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
			Тогда
				ГруппаИ = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
				ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
			Иначе
				ГруппаИ = ГруппаОтбора;
			КонецЕсли; 
			ПостроитьДеревоЛогическогоВыражения(ГруппаИ, Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
			ПостроитьДеревоЛогическогоВыражения(ГруппаИ, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ИначеЕсли ИмяПравила = "<NotExpr>" Тогда
			ГруппаИ = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
			ПостроитьДеревоЛогическогоВыражения(ГруппаИ, Данные.Tokens(1), ЗапросПакета, ЧастьОбъединения)
		ИначеЕсли Ложь
			Или ИмяПравила = "<CheckNULL>"
			Или ИмяПравила = "<CheckNotNULL>"
			Или ИмяПравила = "<CheckValueIn>"
			Или ИмяПравила = "<CompareExpr>"
			Или ИмяПравила = "<CheckLIKE>"
			//Или ИмяПравила = "<CheckExpr>"
		Тогда
			ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЛевоеЗначение = ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
			ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение;
			Если ЛевоеЗначение = Неопределено Тогда
				ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен, , ЧастьОбъединения);
			//ИначеЕсли ИмяПравила = "<CheckNULL>" Тогда
			//	ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
			//ИначеЕсли ИмяПравила = "<CheckNotNULL>" Тогда
			//	ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
			Иначе
				ТокенИерархии = Неопределено;
				Если ИмяПравила = "<CheckValueIn>" Тогда
					ПравыйТокен = Данные.Tokens(1).Data.Tokens(0);
					ТокенИерархии = ПравыйТокен.Data.Tokens(1);
					Если ПравыйТокен.Text = "<InExprs>" Тогда
						ПравыйТокен = ПравыйТокен.Data.Tokens(3);
					Иначе//Если ПравыйТокен.Text = "<InUnion>" Тогда
						ПравыйТокен = ПравыйТокен.Data.Tokens(2);
					КонецЕсли; 
				//ИначеЕсли ИмяПравила = "<CompareExpr>" Тогда
				//	ПравыйТокен = Данные.Tokens(2);
				//ИначеЕсли ИмяПравила = "<CheckExpr>" Тогда
				//	ПравыйТокен = Данные.Tokens(3);
				Иначе
					ПравыйТокен = Данные.Tokens(2);
				КонецЕсли; 
				ПравоеЗначение = ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(ПравыйТокен, ЗапросПакета, ЧастьОбъединения);
				ЭлементОтбора.ПравоеЗначение = ПравоеЗначение;
				Если ПравоеЗначение = Неопределено Тогда
					ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен, , ЧастьОбъединения);
				ИначеЕсли ИмяПравила = "<CompareExpr>" Тогда
					ОператорСравнения = Данные.Tokens(1).Data;
					Если ОператорСравнения = "=" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
					ИначеЕсли ОператорСравнения = "<>" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно;
					ИначеЕсли ОператорСравнения = ">" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.Больше;
					ИначеЕсли ОператорСравнения = "<" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.Меньше;
					ИначеЕсли ОператорСравнения = "<=" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно;
					ИначеЕсли ОператорСравнения = ">=" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно;
					Иначе
						ВызватьИсключение "Неизвестный вид сравнения """ + ОператорСравнения + """";
					КонецЕсли; 
					ЭлементОтбора.ВидСравнения = лВидСравнения;
				ИначеЕсли ИмяПравила = "<CheckLIKE>" Тогда
					ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит;
				ИначеЕсли ИмяПравила = "<CheckValueIn>" Тогда
					Если ТокенИерархии.Data.Tokens(0) = Неопределено Тогда
						ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
					Иначе
						ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии;
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли;
		ИначеЕсли ИмяПравила = "<Brackets>" Тогда
			//Если Истина
			//	И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
			//	И ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
			//Тогда
			//	ГруппаИ = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			//	ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
			//Иначе
			//	ГруппаИ = ГруппаОтбора;
			//КонецЕсли; 
			ПостроитьДеревоЛогическогоВыражения(ГруппаОтбора, Данные.Tokens(1), ЗапросПакета, ЧастьОбъединения);
		Иначе
			ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЗначимыйТокен = ОпуститьсяДоПервогоЗначимогоТокена(Токен);
			ЭлементОтбора.Представление = СобратьВыражениеЗапроса(ЗначимыйТокен,, ЗапросПакета, ЧастьОбъединения);
			ЭлементОтбора.ПравоеЗначение = Токен;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОсновныеДействияФормыОК(Кнопка = Неопределено)
	
	Если мРежимРедактированияТекста Тогда
		ПереключитьРежимРедактированияТекста();
	КонецЕсли; 
	Если мРежимРедактированияТекста Тогда
		Возврат;
	КонецЕсли; 
	ЭтаФорма.Модифицированность = Ложь;
	// Возвращаем текст всегда на диалекте источника
	Если Ложь
		Или мДиалектSQL <> ДиалектSQL 
	Тогда
		ДиалектSQL = мДиалектSQL;
		ОбновитьВсеВыраженияСИндикацией();
	КонецЕсли; 
	СобратьПолныйТекст(, Истина);
	Закрыть(Истина);
	
КонецПроцедуры

Функция ПолучитьОпределениеТаблицы(ИмяИлиСтрокаВыбраннойТаблицы, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, Смещение = "")
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Если ТипЗнч(ИмяИлиСтрокаВыбраннойТаблицы) = Тип("Строка") Тогда
		СтрокаВыбраннойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(ИмяИлиСтрокаВыбраннойТаблицы), "НИмя");
	Иначе
		СтрокаВыбраннойТаблицы = ИмяИлиСтрокаВыбраннойТаблицы;
	КонецЕсли; 
	Если ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.ПолноеИмя) Тогда
		ПолноеИмя = СтрокаВыбраннойТаблицы.ПолноеИмя;
		Если Найти(ПолноеИмя, ".") = 0 Тогда
			Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмя);
			Результат = "";
			Для Каждого Фрагмент Из Фрагменты Цикл
				Если Результат <> "" Тогда
					Результат = Результат + ".";
				КонецЕсли; 
				Если Истина
					И Не ирОбщий.ЛиИмяПеременнойЛкс(Фрагмент) 
					И Не (Истина
						И Лев(Фрагмент, 1) = ПараметрыДиалектаSQL.ПрефиксПараметра
						И ирОбщий.ЛиИмяПеременнойЛкс(Сред(Фрагмент, 2)))
				Тогда
					Фрагмент = "[" + Фрагмент + "]";
				КонецЕсли; 
				Результат = Результат + Фрагмент;
			КонецЦикла;
		Иначе
			Результат = ПолноеИмя;
		КонецЕсли; 
		ТекстПараметров = "";
		Индекс = 0;
		Для каждого ПараметрТаблицы Из СтрокаВыбраннойТаблицы.Параметры Цикл
			Если Индекс > 0 Тогда
				ТекстПараметров = ТекстПараметров + ",";
			КонецЕсли; 
			ТекстПараметров = ТекстПараметров + Символы.ПС + Смещение + Символы.Таб;
			ТекстВыражения = ОбновитьВыражениеЗапроса(ПараметрТаблицы, ЭлементыФормы.ПараметрыТаблицы, ЗапросПакета, ЧастьОбъединения,,, Истина,, Ложь, 0);
			Если ЗначениеЗаполнено(ПараметрТаблицы.ТекстРасширения) Тогда
				Если ЗначениеЗаполнено(ТекстВыражения) Тогда
					ТекстВыражения = ТекстВыражения + " ";
				КонецЕсли; 
				ТекстВыражения = ТекстВыражения + "{" + ПараметрТаблицы.ТекстРасширения + "}";
			КонецЕсли; 
			ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПараметров, ТекстВыражения, Смещение + Символы.Таб);
			Индекс = Индекс + 1;
		КонецЦикла;
		Если ЗначениеЗаполнено(ТекстПараметров) Тогда
			Результат = Результат + "(" + ТекстПараметров + ")";
		КонецЕсли; 
	ИначеЕсли СтрокаВыбраннойТаблицы.ВложенныйПакет <> Неопределено Тогда
		лТекстПакета = СобратьТекстПакета(СтрокаВыбраннойТаблицы.ВложенныйПакет, Смещение);
		Результат = "(" + СокрЛ(лТекстПакета) + ")";
	Иначе
		ВызватьИсключение "У выбранной таблицы отсутствует определение"; 
	КонецЕсли; 
	Если Истина
		И ПараметрыДиалектаSQL.МногоТаблиц
		И ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.Имя) 
	Тогда
		Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаВыбраннойТаблицы.Имя);
	КонецЕсли; 
	КомментарийТаблицы = ПолучитьКомментарийДляВставки(СтрокаВыбраннойТаблицы.Комментарий, Смещение);
	Если ЗначениеЗаполнено(КомментарийТаблицы) Тогда
		Результат = КомментарийТаблицы + Результат;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьИмяСНеобходимымиСкобками(Имя)
	
	Результат = Имя;
	Если Не ирОбщий.ЛиИмяПеременнойЛкс(Имя) Тогда
		Результат = "[" + Имя + "]";
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Параметры:
//   ЛиСобратьПакет - Булево, *Неопределено - собирать пакет, иначе только текущего запроса пакета
//
Функция СобратьПолныйТекст(Смещение = "", ЛиСобратьПакет = Неопределено) Экспорт 
	
	Если ЛиСобратьПакет = Неопределено Тогда
		ЛиСобратьПакет = ПолеТекстаОтображаетПакет;
	КонецЕсли; 
	ЗакончитьРедактированиеСвязанныхПолей();
	Если ЛиСобратьПакет Тогда
		Текст = СобратьТекстПакета();
	Иначе
		Состояние("Сборка текста запроса пакета...");
		Текст = СобратьТекстЗапросаПакета();
	КонецЕсли; 
	Состояние();
	Возврат Текст;
	
КонецФункции

Функция СобратьТекстПакета(Пакет = Неопределено, Смещение = "")

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
		Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(Пакет.Количество(), "Сборка текста пакета");
	КонецЕсли; 
	Результат = "";
	ИндексЗапроса = 0;
	Для Каждого ЗапросПакета Из Пакет Цикл
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		ТекстЗапроса = СобратьТекстЗапросаПакета(ЗапросПакета, Смещение);
		Если Результат <> "" Тогда
			Результат = Результат + "
			|;
			|";
			//Если Истина
			//	И Лев(ТекстЗапроса, СтрДлина(ПараметрыДиалектаSQL.СтрочныйКомментарий)) <> ПараметрыДиалектаSQL.СтрочныйКомментарий
			//Тогда
				Результат = Результат + "//" + мМаркерИндексаЗапросаПакета + ИндексЗапроса + " " + ирОбщий.ПолучитьСтрокуПовторомЛкс(ПараметрыДиалектаSQL.СтрочныйКомментарий, 20) + "}
				|";
			//КонецЕсли; 
		КонецЕсли; 
		Результат = Результат + ТекстЗапроса;
		ИндексЗапроса = ИндексЗапроса + 1;
	КонецЦикла; 
	Если Индикатор <> Неопределено Тогда
		ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция СобратьТекстЗапросаПакета(ЗапросПакета = Неопределено, Смещение = "")

	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Результат = "";
	Если ирОбщий.СтрокиРавныЛкс(ЗапросПакета.ТипЗапроса, 2) Тогда
		Результат = Результат + ПолучитьКомментарийДляВставки(ЗапросПакета.Комментарий, Смещение);
		Если ЗначениеЗаполнено(Результат) Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		Результат = Результат + ПолучитьСловоЯзыкаЗапросов("DROP") + " ";
		Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
			Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
		КонецЕсли; 
		Результат = Результат + XMLСтрока(ЗапросПакета.ИмяВременнойТаблицы);
		Возврат Результат;
	КонецЕсли; 
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		ТекстЧасти = СобратьТекстЧастиОбъединения(ЗапросПакета, ЧастьОбъединения, Смещение);
		Если Результат <> "" Тогда
			Результат = Результат + "
			|" + Смещение + ПолучитьСловоЯзыкаЗапросов("UNION");
			Если Не ЧастьОбъединения.БезДублей Тогда
				Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("ALL");
			КонецЕсли; 
			Результат = Результат + Символы.ПС + Смещение;
		КонецЕсли; 
		Результат = Результат + ТекстЧасти;
	КонецЦикла;
	
	// ORDER BY
	ТекстПорядок = "";
	Для Каждого ЭлементПорядка Из ЗапросПакета.ПоляПорядка Цикл
		Если ТекстПорядок <> "" Тогда
			ТекстПорядок = ТекстПорядок + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстПорядок = ТекстПорядок + ПолучитьКомментарийДляВставки(ЭлементПорядка.Комментарий, Смещение + Символы.Таб);
		ТекстВыражения = ОбновитьВыражениеЗапроса(ЭлементПорядка, ЭлементыФормы.ПоляПорядка, ЗапросПакета,,,,,, Ложь, 0);
		ТекстПорядок = ТекстПорядок + ТекстВыражения;
		Если ЭлементПорядка.Иерархия Тогда
			ТекстПорядок = ТекстПорядок + " " + ПолучитьСловоЯзыкаЗапросов("HIERARCHY");
		КонецЕсли; 
		Если ЭлементПорядка.Направление = НаправлениеСортировки.Убыв Тогда
			ТекстПорядок = ТекстПорядок + " " + ПолучитьСловоЯзыкаЗапросов("DESC");
		КонецЕсли; 
	КонецЦикла;
	Если ТекстПорядок <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("ORDER") + " " + ПолучитьСловоЯзыкаЗапросов("BY") 
			+ Символы.ПС + Смещение + Символы.Таб + ТекстПорядок;
	КонецЕсли; 
	
	ДобавитьТекстПредложенияПостроителя(Результат, ПолучитьСловоЯзыкаЗапросов("ORDER") + " " + ПолучитьСловоЯзыкаЗапросов("BY"),
		ЗапросПакета.ПоляПорядкаПостроителя, ЭлементыФормы.ПоляПорядкаПостроителя, ЗапросПакета, , Смещение);
	
	Если ПараметрыДиалектаSQL.INTOпослеORDER Тогда
		Если ирОбщий.СтрокиРавныЛкс(ЗапросПакета.ТипЗапроса, 1) Тогда
			Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("INTO") + " ";
			Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
				Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
			КонецЕсли; 
			Результат = Результат + XMLСтрока(ЗапросПакета.ИмяВременнойТаблицы);
		КонецЕсли; 
	КонецЕсли; 
	
	// INDEX BY
	ТекстИндекс = "";
	Для Каждого ЭлементИндекса Из ЗапросПакета.ПоляИндекса Цикл
		Если ТекстИндекс <> "" Тогда
			ТекстИндекс = ТекстИндекс + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстИндекс = ТекстИндекс + ПолучитьКомментарийДляВставки(ЭлементИндекса.Комментарий, Смещение + Символы.Таб);
		ТекстИндекс = ТекстИндекс + ЭлементИндекса.Определение;
	КонецЦикла;
	Если ТекстИндекс <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("INDEX") 
			+ " " + ПолучитьСловоЯзыкаЗапросов("BY") + Символы.ПС + Смещение + Символы.Таб + ТекстИндекс;
	КонецЕсли; 
		
	// TOTALS
	ТекстГруппирующиеПоля = "";
	Если ЗапросПакета.ОпцияОбщиеИтоги Тогда
		ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + ПолучитьСловоЯзыкаЗапросов("OVERALL");
	КонецЕсли; 
	Для Каждого СтрокаПоля Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
		Если ТекстГруппирующиеПоля <> "" Тогда
			ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + ПолучитьКомментарийДляВставки(СтрокаПоля.Комментарий, Смещение + Символы.Таб);
		ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + СтрокаПоля.Определение;
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц
			И ЗначениеЗаполнено(СтрокаПоля.Имя) 
		Тогда
			ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаПоля.Имя);
		КонецЕсли; 
		Если ирОбщий.СтрокиРавныЛкс(СтрокаПоля.ТипИтогов, "Иерархия") Тогда
			ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + " " + ПолучитьСловоЯзыкаЗапросов("HIERARCHY");
		КонецЕсли; 
	КонецЦикла;
	ТекстИтоговыеПоля = "";
	Для Каждого СтрокаПоля Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
		Если ТекстИтоговыеПоля <> "" Тогда
			ТекстИтоговыеПоля = ТекстИтоговыеПоля  + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстИтоговыеПоля = ТекстИтоговыеПоля + ПолучитьКомментарийДляВставки(СтрокаПоля.Комментарий, Смещение + Символы.Таб);
		ТекстИтоговыеПоля = ТекстИтоговыеПоля + СтрокаПоля.Определение;
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц 
			И ЗначениеЗаполнено(СтрокаПоля.Имя) 
		Тогда
			ТекстИтоговыеПоля = ТекстИтоговыеПоля + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаПоля.Имя);
		КонецЕсли; 
	КонецЦикла;
	Если Ложь
		Или ТекстГруппирующиеПоля <> ""
		Или ТекстИтоговыеПоля <> ""
	Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("TOTALS");
		Если ЗначениеЗаполнено(ТекстИтоговыеПоля) Тогда
			Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ТекстИтоговыеПоля;
		КонецЕсли; 
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("BY");
		Если ЗначениеЗаполнено(ТекстГруппирующиеПоля) Тогда
			Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ТекстГруппирующиеПоля;
		КонецЕсли; 
	КонецЕсли; 
	
	ДобавитьТекстПредложенияПостроителя(Результат, ПолучитьСловоЯзыкаЗапросов("TOTALS") + " " + ПолучитьСловоЯзыкаЗапросов("BY"),
		ЗапросПакета.ПоляИтоговПостроителя, ЭлементыФормы.ПоляИтоговПостроителя, ЗапросПакета, , Смещение);
	
	Если Истина
		И ПараметрыДиалектаSQL.Это1С
		И ЗапросПакета.ОпцияАвтоупорядочивание 
	Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("AUTOORDER");
	КонецЕсли; 

	//Если ЗначениеЗаполнено(ЗапросПакета.ТекстРасширения) Тогда
	//	Результат = Результат + Символы.ПС + "{" + ЗапросПакета.ТекстРасширения + "}";
	//КонецЕсли; 
	
	Возврат Результат;

КонецФункции

Процедура ДобавитьТекстПредложенияПостроителя(ОбщийТекст, ПредложениеПостроителя, ТаблицаПолейПостроителя, ТабличноеПолеПостроителя, ЗапросПакета,
	ЧастьОбъединения = Неопределено, Смещение = "")
	
	ТекстПостроителя = "";
	Для Каждого ПолеПостроителя Из ТаблицаПолейПостроителя Цикл
		ТекстВыражения = ПолучитьОбновитьВыражениеПоляПостроителя(ПолеПостроителя, ТабличноеПолеПостроителя, ЗапросПакета, ЧастьОбъединения);
		ТекстКомментария = ПолучитьКомментарийДляВставки(ПолеПостроителя.Комментарий, Смещение + Символы.Таб);
		Если ТекстПостроителя <> "" Тогда
			ТекстПостроителя = ТекстПостроителя + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстПостроителя = ТекстПостроителя + ТекстКомментария;
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПостроителя, ТекстВыражения, Смещение + Символы.Таб);
		ПсевдонимПоля = ПолеПостроителя.Имя;
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц
			И ЗначениеЗаполнено(ПсевдонимПоля) 
		Тогда
			ТекстПостроителя = ТекстПостроителя + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(ПолеПостроителя.Имя);
		КонецЕсли;
	КонецЦикла;
	Если ТекстПостроителя <> "" Тогда
		ОбщийТекст = ОбщийТекст + Символы.ПС + Смещение + "{" + ПредложениеПостроителя + Символы.ПС + Смещение + Символы.Таб + ТекстПостроителя + "}"; 
	КонецЕсли; 

КонецПроцедуры

Функция ПолучитьОбновитьВыражениеПоляПостроителя(ПолеПостроителя, ТабличноеПоле, Знач ЗапросПакета, Знач ЧастьОбъединения = Неопределено)

	ТекстВыражения = ОбновитьВыражениеЗапроса(ПолеПостроителя, ТабличноеПоле, ЗапросПакета, ЧастьОбъединения,,,,,, 0);
	Если ПолеПостроителя.ИспользоватьДочерние Тогда
		Если Лев(ТекстВыражения, 1) <> "(" Тогда
			ТекстВыражения = "(" + ТекстВыражения + ")";
		КонецЕсли; 
		ТекстВыражения = ТекстВыражения + ".*";
	КонецЕсли; 
	Возврат ТекстВыражения;

КонецФункции

Функция ПолучитьКомментарийДляВставки(Комментарий, Смещение = "")
	
	Результат = "";
	Если Не ЗначениеЗаполнено(Комментарий) Тогда
		Возврат Результат;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ПараметрыДиалектаSQL.СтрочныйКомментарий) Тогда
		ирОбщий.СообщитьСУчетомМодальностиЛкс("Проигнорирован комментарий (не поддерживается диалектом SQL): " + Комментарий, , СтатусСообщения.Внимание);
		Возврат Результат;
	КонецЕсли; 
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(Комментарий);
	Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		Если Результат <> "" Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		Результат = Результат + ПараметрыДиалектаSQL.СтрочныйКомментарий + ТекстовыйДокумент.ПолучитьСтроку(Счетчик) + Символы.ПС;
	КонецЦикла;
	Результат = Результат + Смещение;
	Возврат Результат;
	
КонецФункции

Функция СобратьТекстЧастиОбъединения(ЗапросПакета, ЧастьОбъединения, Смещение = "")

	Результат = "";
	
	// SELECT
	Результат = Результат + ПолучитьКомментарийДляВставки(ЧастьОбъединения.Комментарий, Смещение);
	Если ЗначениеЗаполнено(Результат) Тогда
		Результат = Результат + Смещение;
	КонецЕсли; 
	Результат = Результат + ПолучитьСловоЯзыкаЗапросов("SELECT");
	Если ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[0] Тогда
		Если Истина
			И ПараметрыДиалектаSQL.Это1С
			И ЗапросПакета.ОпцияРазрешенные 
		Тогда
			Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("ALLOWED");
		КонецЕсли; 
		Если ЗапросПакета.ОпцияПервые Тогда
			Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("TOP") + " " + XMLСтрока(ЗапросПакета.ПервыеКоличество);
		КонецЕсли; 
	КонецЕсли; 
	Если ЧастьОбъединения.ОпцияРазличные Тогда
		Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("DISTINCT");
	КонецЕсли; 
	ТекстПоляВыбора = "";
	ДобавленныеТаблицыВсеПоля = Новый Массив();
	Для Каждого СтрокаПоляОбъединения Из ЗапросПакета.ПоляОбъединения Цикл
		ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(СтрокаПоляОбъединения["_" + ЧастьОбъединения.Номер], "ИД");
		ПсевдонимПоля = СтрокаПоляОбъединения.Имя;
		ТекстКомментария = "";
		Если ВыбранноеПоле = Неопределено Тогда
			ТекстВыражения = ПолучитьСловоЯзыкаЗапросов("NULL");
		ИначеЕсли ВыбранноеПоле.Автополе Тогда
			ПсевдонимПоля = "";
			ТекстВыражения = "*";
			Если ЧастьОбъединения.ВыбранныеТаблицы.Количество() > 1 Тогда
				ИмяТаблицы = ирОбщий.ПолучитьПервыйФрагментЛкс(ВыбранноеПоле.Определение);
				ТекстВыражения = ИмяТаблицы + "." + ТекстВыражения;
				КлючТаблицы = НРег(ИмяТаблицы);
			Иначе
				КлючТаблицы = "";
			КонецЕсли; 
			Если ДобавленныеТаблицыВсеПоля.Найти(КлючТаблицы) = Неопределено Тогда
				ДобавленныеТаблицыВсеПоля.Добавить(КлючТаблицы);
			Иначе
				Продолжить;
			КонецЕсли; 
		Иначе
			ТекстВыражения = ОбновитьВыражениеЗапроса(ВыбранноеПоле, ЭлементыФормы.ВыбранныеПоля, ЗапросПакета, ЧастьОбъединения,,,,,, 0);
			ТекстКомментария = ПолучитьКомментарийДляВставки(ВыбранноеПоле.Комментарий, Смещение + Символы.Таб);
		КонецЕсли; 
		Если ТекстПоляВыбора <> "" Тогда
			ТекстПоляВыбора = ТекстПоляВыбора + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстПоляВыбора = ТекстПоляВыбора + ТекстКомментария;
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПоляВыбора, ТекстВыражения, Смещение + Символы.Таб);
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц
			И ЗначениеЗаполнено(ПсевдонимПоля) 
		Тогда
			ТекстПоляВыбора = ТекстПоляВыбора + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаПоляОбъединения.Имя);
		КонецЕсли;
	КонецЦикла;
	Если Не ЗначениеЗаполнено(ТекстПоляВыбора) Тогда
		ТекстПоляВыбора = "*";
	КонецЕсли; 
	Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ТекстПоляВыбора;
	
	ДобавитьТекстПредложенияПостроителя(Результат, ПолучитьСловоЯзыкаЗапросов("SELECT"),
		ЧастьОбъединения.ПоляВыбораПостроителя, ЭлементыФормы.ПоляВыбораПостроителя, ЗапросПакета, ЧастьОбъединения, Смещение);
		
	Если Не ПараметрыДиалектаSQL.INTOпослеORDER Тогда
		Если ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[0] Тогда
			Если ирОбщий.СтрокиРавныЛкс(ЗапросПакета.ТипЗапроса, 1) Тогда
				Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("INTO") + " ";
				Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
					Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
				КонецЕсли; 
				Результат = Результат + XMLСтрока(ЗапросПакета.ИмяВременнойТаблицы);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
	ТекстИЗ = СобратьТекстИЗ(ЗапросПакета, ЧастьОбъединения, Смещение);
	Результат = Результат + ТекстИЗ;
	
	// WHERE
	ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Условие.Отбор, 1, 1,, ЧастьОбъединения.Компоновщик.Настройки);
	Если ТекстУсловия <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("WHERE");
		Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ПолучитьКомментарийДляВставки(ЧастьОбъединения.КомментарийОтбора, Смещение + Символы.Таб);
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(Результат, ТекстУсловия, Смещение);
	КонецЕсли; 
	
	ДобавитьТекстПредложенияПостроителя(Результат, ПолучитьСловоЯзыкаЗапросов("WHERE"),
		ЧастьОбъединения.ПоляОтбораПостроителя, ЭлементыФормы.ПоляОтбораПостроителя, ЗапросПакета, ЧастьОбъединения, Смещение);
	
	// GROUP BY
	ТекстГруппировки = "";
	Для Каждого Группировка Из ЧастьОбъединения.Группировки Цикл
		Если ТекстГруппировки <> "" Тогда
			ТекстГруппировки = ТекстГруппировки + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстГруппировки = ТекстГруппировки + ПолучитьКомментарийДляВставки(Группировка.Комментарий, Смещение + Символы.Таб);
		ТекстВыражения = ОбновитьВыражениеЗапроса(Группировка, ЭлементыФормы.Группировки, ЗапросПакета, ЧастьОбъединения,,,,,, 0);
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстГруппировки, ТекстВыражения, Смещение + Символы.Таб);
	КонецЦикла;
	Если ТекстГруппировки <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("GROUP") 
			+ " " + ПолучитьСловоЯзыкаЗапросов("BY") + Символы.ПС + Смещение + Символы.Таб + ТекстГруппировки;
	КонецЕсли; 
	
	// HAVING
	ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Условие.Отбор, 1, 2,, ЧастьОбъединения.Компоновщик.Настройки);
	Если ТекстУсловия <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("HAVING");
		Результат = Результат + Символы.ПС + Смещение + Символы.Таб;
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(Результат, ТекстУсловия, Смещение);
	КонецЕсли; 
	
	//Если ЗначениеЗаполнено(ЧастьОбъединения.ТекстРасширения) Тогда
	//	Результат = Результат + Символы.ПС + "{" + ЧастьОбъединения.ТекстРасширения + "}";
	//КонецЕсли; 
	
	Возврат Результат;

КонецФункции

// Текст FROM
Функция СобратьТекстИЗ(ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, Смещение = "")

	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Результат = "";
	ТекстТаблицы = "";
	ТаблицаГрупп = ЧастьОбъединения.ВыбранныеТаблицы.Скопировать(, "НомерГруппы");
	ТаблицаГрупп.Свернуть("НомерГруппы");
	ТаблицаГрупп.Сортировать("НомерГруппы");
	ГруппыТаблиц = ТаблицаГрупп.ВыгрузитьКолонку(0);
	Для Каждого НомерГруппыТаблиц Из ГруппыТаблиц Цикл
		ГруппаОткрыта = Ложь;
		ГруппыСвязей = ЧастьОбъединения.СвязиТаблиц.Строки;
		Для Каждого ГруппаСвязей Из ГруппыСвязей Цикл
			СоединяемаяТаблица = ГруппаСвязей.Таблица;
			СтрокаВыбраннойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(СоединяемаяТаблица), "НИмя");
			Если Истина
				И СтрокаВыбраннойТаблицы.НомерГруппы = НомерГруппыТаблиц
			Тогда
				Если ТекстТаблицы <> "" Тогда
					ТекстТаблицы = ТекстТаблицы + ",";
				КонецЕсли; 
				ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб + ПолучитьОпределениеТаблицы(ГруппаСвязей.Таблица, ЗапросПакета, ЧастьОбъединения, Смещение + Символы.Таб);
				Если Не ГруппаОткрыта Тогда
				    Если НомерГруппыТаблиц > 0 Тогда
				        ТекстТаблицы = ТекстТаблицы + "{";
				    КонецЕсли; 
				    ГруппаОткрыта = Истина;
				КонецЕсли; 
				СобратьВеткуСвязейТаблиц(ГруппаОткрыта, ГруппаСвязей, ЗапросПакета, НомерГруппыТаблиц, Смещение, ТекстТаблицы, ЧастьОбъединения);
			КонецЕсли; 
		КонецЦикла;
		Если ГруппаОткрыта Тогда
			Если НомерГруппыТаблиц > 0 Тогда
				ТекстТаблицы = ТекстТаблицы + "}";
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Если ТекстТаблицы <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("FROM") + ТекстТаблицы;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура СобратьВеткуСвязейТаблиц(ГруппаОткрыта, Знач ВеткаСвязей, ЗапросПакета, Знач НомерГруппыТаблиц, Знач Смещение, ТекстТаблицы, ЧастьОбъединения)
	
	Для Каждого СтрокаСвязи Из ВеткаСвязей.Строки Цикл
		ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб;
		ТекстТаблицы = ТекстТаблицы + ПолучитьСловоЯзыкаЗапросов(СтрокаСвязи.ТипСвязи);
		ТекстТаблицы = ТекстТаблицы + " " + ПолучитьСловоЯзыкаЗапросов("JOIN") 
		+ " " + ПолучитьОпределениеТаблицы(СтрокаСвязи.Таблица, ЗапросПакета, ЧастьОбъединения, Смещение + Символы.Таб);
		ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(СтрокаСвязи.Условие.Отбор, 2,,, ЧастьОбъединения.Компоновщик.Настройки);
		Если ПустаяСтрока(ТекстУсловия) Тогда
			ТекстУсловия = ПолучитьСловоЯзыкаЗапросов("TRUE");
		КонецЕсли; 
		СобратьВеткуСвязейТаблиц(ГруппаОткрыта, СтрокаСвязи, ЗапросПакета, НомерГруппыТаблиц, Смещение + Символы.Таб, ТекстТаблицы, ЧастьОбъединения);
		ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб + ПолучитьСловоЯзыкаЗапросов("ON") + " ";
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстТаблицы, ТекстУсловия, Смещение);
	КонецЦикла;

КонецПроцедуры

Функция ПоменятьМестамиТаблицыСвязи(СвязьТаблиц)

	// Меняем местами левую и правую стороны
	лЛеваяТаблица = СвязьТаблиц.ЛеваяТаблица;
	СвязьТаблиц.ЛеваяТаблица = СвязьТаблиц.ПраваяТаблица;
	СвязьТаблиц.ПраваяТаблица = лЛеваяТаблица;
	лВсеСтрокиЛевой = СвязьТаблиц.ВсеСтрокиЛевой;
	СвязьТаблиц.ВсеСтрокиЛевой = СвязьТаблиц.ВсеСтрокиПравой;
	СвязьТаблиц.ВсеСтрокиПравой = лВсеСтрокиЛевой;
	Возврат Неопределено;

КонецФункции

Функция ЗакончитьРедактированиеСвязанныхПолей()

	СохранитьЗапросПакета();
	Возврат Неопределено;

КонецФункции

Процедура ВыбранныеТаблицыПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Истина
			//И ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.ДоступныеТаблицы") // В портативной версии нельзя
			И ТипЗнч(ЗначениеПеретаскивания[0]) = ТипЗнч(ЭтотОбъект.ДоступныеТаблицы[0]) 
		Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Истина
			//И ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.ДоступныеТаблицы") // В портативной версии нельзя
			И ТипЗнч(ЗначениеПеретаскивания[0]) = ТипЗнч(ЭтотОбъект.ДоступныеТаблицы[0]) 
		Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступнуюТаблицуВВыбранные(СтрокаПеретаскивания);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДобавитьДоступнуюТаблицуВВыбранные(СтрокаДоступнойТаблицы)

	Если Истина
		И Не ПараметрыДиалектаSQL.МногоТаблиц
		И ВыбранныеТаблицы.Количество() > 0
	Тогда
		Возврат;
	КонецЕсли; 
	ВыбраннаяТаблица = ДобавитьВыбраннуюТаблицу();
	//ОпределениеТаблицы = СтрокаДоступнойТаблицы.Имя;
	//Если ЗначениеЗаполнено(СтрокаДоступнойТаблицы.Схема) Тогда
	//	ОпределениеТаблицы = СтрокаДоступнойТаблицы.Схема + "." + ОпределениеТаблицы;
	//КонецЕсли; 
	//ВыбраннаяТаблица.Определение = ОпределениеТаблицы;
	ВыбраннаяТаблица.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, СтрокаДоступнойТаблицы.Имя);
	ВыбраннаяТаблица.ПолноеИмя = СтрокаДоступнойТаблицы.ПолноеИмя;
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВыбраннаяТаблица);
	ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока = ВыбраннаяТаблица;
	ОбновитьНаименованиеЧасти();
	НайтиДобавитьВыбраннуюТаблицуВСвязи(ВыбраннаяТаблица);

КонецПроцедуры

Процедура ВыбранныеПоляПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Функция РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания)
	
	Результат = Ложь
		Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ДоступноеПолеКомпоновкиДанных")
		Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ДоступноеПолеОтбораКомпоновкиДанных")
		Или (Истина
			И ТипЗнч(ЗначениеПеретаскивания) = Тип("СтрокаТаблицыЗначений")
			//И ПараметрыПеретаскивания.Значение.Владелец() = ДоступныеПоляВыбора // Так не работает
			И ЗначениеПеретаскивания.Владелец().Колонки.Найти("Имя") <> Неопределено);
	Возврат Результат;
	
КонецФункции

Процедура ВыбранныеПоляПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)

	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(СтрокаПеретаскивания);
			КонецЦикла;  
		КонецЕсли;
	ИначеЕсли ТипЗнч(ЗначениеПеретаскивания) = Тип("СтрокаТаблицыЗначений") Тогда
		СтандартнаяОбработка = Ложь;
		Элемент.ДобавитьСтроку();
		НоваяСтрока = Элемент.ТекущаяСтрока;
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ЗначениеПеретаскивания); 
		ЗагрузитьВыбранноеПоле();
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(СтрокаДоступногоПоля, ТабличноеПолеПолей, ЗапросПакета = Неопределено,
	ЧастьОбъединения = Неопределено, СдвигИндексаПослеДобавления = 0, КонтролироватьУникальность = Ложь)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если Истина
		И (Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных"))
		И ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля) 
	Тогда
		Возврат;
	КонецЕсли; 
	Если Истина
		И (Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных"))
		И СтрокаДоступногоПоля.Папка
	Тогда
		// Все дочерние поля
		Если Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступныеПоляКомпоновкиДанных")
			Или Не ирОбщий.СтрокиРавныЛкс("ПараметрыДанных", "" + СтрокаДоступногоПоля.Поле) 
		Тогда
			Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(СтрокаДоступногоПоля.Поле), "НИмя");
			Иначе
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы[0];
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого лСтрокаДоступногоПоля Из СтрокаДоступногоПоля.Элементы Цикл
			ДобавитьДоступноеПолеВТабличноеПоле(лСтрокаДоступногоПоля, ТабличноеПолеПолей, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления);
		КонецЦикла;
	Иначе
		// Одно поле
		ДобавитьДоступноеПолеВТабличноеПоле(СтрокаДоступногоПоля, ТабличноеПолеПолей, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления);
	КонецЕсли; 

КонецПроцедуры

Функция ДобавитьДоступноеПолеВТабличноеПоле(СтрокаДоступногоПоля, ТабличноеПолеПолей, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено,
	СдвигИндексаПослеДобавления = 0, ИмяСвойстваВыраженияВыбранногоПоля = "Имя")

	Если Ложь
		Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
		Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных")
	Тогда
		Если ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля) Тогда
			Возврат Неопределено;
		КонецЕсли; 
		ВыражениеПоля = ПолучитьПолноеИмяДоступногоПоля(СтрокаДоступногоПоля);
		ПроверятьУникальность = Ложь;
	Иначе
		ВыражениеПоля = СтрокаДоступногоПоля[ИмяСвойстваВыраженияВыбранногоПоля];
		СтрокаПоляПостроителя = ТабличноеПолеПолей.Значение.Найти(ВыражениеПоля, "Определение");
		Если СтрокаПоляПостроителя <> Неопределено Тогда
			ТабличноеПолеПолей.ТекущаяСтрока = СтрокаПоляПостроителя;
			Возврат СтрокаПоляПостроителя;
		КонецЕсли;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	СтрокаПоляПостроителя = ТабличноеПолеПолей.Значение.Добавить();
	ТабличноеПолеПолей.Значение.Сдвинуть(СтрокаПоляПостроителя, СдвигИндексаПослеДобавления);
	СтрокаПоляПостроителя.Определение = ВыражениеПоля;
	Если СтрокаПоляПостроителя.Владелец().Колонки.Найти("Имя") <> Неопределено Тогда
		ИмяПоля = ПолучитьАвтоПсевдонимПоля(СтрокаПоляПостроителя, ЧастьОбъединения);
		СтрокаПоляПостроителя.Имя = ИмяПоля;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПоляПостроителя);
	КонецЕсли; 
	ОбновитьСтрокуПоляПостроителя(СтрокаПоляПостроителя, Истина,, СтрокаДоступногоПоля.ТипЗначения);
	
	//ПриИзмененииВыраженияВыбранногоПоля(СтрокаВыбранногоПоля, ЗапросПакета, ЧастьОбъединения, Ложь); // Надо делать после активизации строки
	Возврат СтрокаПоляПостроителя;

КонецФункции

Процедура ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(СтрокаДоступногоПоля, Автополе = Ложь, ЗапросПакета = Неопределено,
	ЧастьОбъединения = Неопределено, СдвигИндексаПослеДобавления = 0, КонтролироватьУникальность = Ложь, ОбновитьПоляОбъединения = Истина)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если Истина
		И (Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных"))
		И ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля) 
	Тогда
		Возврат;
	КонецЕсли; 
	Если Ложь
		Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступныеПоляКомпоновкиДанных")
		Или (Истина
			И (Ложь
				Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
				Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных"))
			И СтрокаДоступногоПоля.Папка)
	Тогда
		//Если ирОбщий.СтрокиРавныЛкс("СистемныеПоля", "" + СтрокаДоступногоПоля.Поле) Тогда
		//	Возврат;
		//КонецЕсли; 
		// Все дочерние поля
		Если Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступныеПоляКомпоновкиДанных")
			Или Не ирОбщий.СтрокиРавныЛкс("ПараметрыДанных", "" + СтрокаДоступногоПоля.Поле) 
		Тогда
			Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(СтрокаДоступногоПоля.Поле), "НИмя");
			Иначе
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы[0];
			КонецЕсли; 
			Если Не ВыбраннаяТаблица.ВсеПоля Тогда
				Ответ = Вопрос("Хотите включить выбор всех полей из таблицы?", РежимДиалогаВопрос.ДаНет);
				Если Ответ = КодВозвратаДиалога.Да Тогда
					ВыбраннаяТаблица.ВсеПоля = Истина;
					Автополе = Истина;
					КонтролироватьУникальность = Истина;
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого лСтрокаДоступногоПоля Из СтрокаДоступногоПоля.Элементы Цикл
			ДобавитьДоступноеПолеВВыбранныеПоля(лСтрокаДоступногоПоля, Автополе, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления,
				КонтролироватьУникальность, Ложь);
		КонецЦикла;
		Если ОбновитьПоляОбъединения Тогда
			ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
		КонецЕсли;
	Иначе
		//Если ирОбщий.СтрокиРавныЛкс("СистемныеПоля", "" + СтрокаДоступногоПоля.Родитель.Поле) Тогда
		//	Возврат;
		//КонецЕсли; 
		// Одно поле
		ДобавитьДоступноеПолеВВыбранныеПоля(СтрокаДоступногоПоля, Автополе, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления,
			КонтролироватьУникальность, ОбновитьПоляОбъединения);
	КонецЕсли; 

КонецПроцедуры

Функция ДобавитьДоступноеПолеВВыбранныеПоля(СтрокаДоступногоПоля, Автополе = Ложь, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено,
	СдвигИндексаПослеДобавления = 0, КонтролироватьУникальность = Ложь, ОбновитьПоляОбъединения = Истина)

	Если ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ОпределениеПоля = ПолучитьПолноеИмяДоступногоПоля(СтрокаДоступногоПоля);
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	//ТабличноеПоле = ЭлементыФормы.ВыбранныеПоля;
	Если КонтролироватьУникальность Тогда
	//Если Автополе Тогда
		СтрокаВыбранногоПоля = ЧастьОбъединения.ВыбранныеПоля.Найти(ОпределениеПоля, "Определение");
	КонецЕсли; 
	Если СтрокаВыбранногоПоля = Неопределено Тогда
		СтрокаВыбранногоПоля = ЧастьОбъединения.ВыбранныеПоля.Добавить();
		Если ЗначениеЗаполнено(СдвигИндексаПослеДобавления) Тогда
			ЧастьОбъединения.ВыбранныеПоля.Сдвинуть(СтрокаВыбранногоПоля, СдвигИндексаПослеДобавления);
		КонецЕсли; 
		СтрокаВыбранногоПоля.Определение = ОпределениеПоля;
		ИмяПоля = ПолучитьАвтоПсевдонимПоля(СтрокаВыбранногоПоля, ЧастьОбъединения);
		СтрокаВыбранногоПоля.Имя = ИмяПоля;
		СтрокаВыбранногоПоля.ИД = Новый УникальныйИдентификатор();
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбранногоПоля);
		//СтрокаВыбранногоПоля.ТипЗначения = СтрокаДоступногоПоля.ТипЗначения;
	КонецЕсли; 
	СтрокаВыбранногоПоля.Автополе = Автополе;
	Если ОбновитьПоляОбъединения Тогда
		ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока = СтрокаВыбранногоПоля;
	КонецЕсли; 
	ПриИзмененииВыраженияВыбранногоПоля(СтрокаВыбранногоПоля, ЗапросПакета, ЧастьОбъединения, Ложь); // Надо делать после активизации строки
	Если ОбновитьПоляОбъединения Тогда
		ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
	КонецЕсли; 
	Возврат СтрокаВыбранногоПоля;

КонецФункции

Функция ПолучитьАвтоПсевдонимПоля(СтрокаПоля, ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	ПозицияТочки = Найти(СтрокаПоля.Определение, ".");
	ИмяПоля = Сред(СтрокаПоля.Определение, ПозицияТочки + 1);
	ИмяПоля = СтрЗаменить(ИмяПоля, ".", "");
	ИмяПоля = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(СтрокаПоля.Владелец(), ИмяПоля);
	Если Ложь
		Или ирОбщий.СтрокиРавныЛкс(ИмяПоля, "ЛОЖЬ")
		Или ирОбщий.СтрокиРавныЛкс(ИмяПоля, "ИСТИНА")
		Или ирОбщий.СтрокиРавныЛкс(ИмяПоля, "НЕОПРЕДЕЛЕНО")
		Или ирОбщий.СтрокиРавныЛкс(ИмяПоля, "NULL")
	Тогда
		ИмяПоля = "_" + ИмяПоля;
	КонецЕсли; 
	Возврат ИмяПоля;

КонецФункции

Процедура ПанельЧастиПриСменеСтраницы(Элемент = Неопределено, ТекущаяСтраница = Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	Если Элемент = Неопределено Тогда
		Элемент = ЭлементыФормы.ПанельЧасти;
	КонецЕсли; 
	Если ТекущаяСтраница = Неопределено Тогда
		ТекущаяСтраница = Элемент.ТекущаяСтраница.Имя;
	КонецЕсли; 
	Если ТипЗапроса <> 2 Тогда
		Если Ложь
			Или мСтараяСтраницаПанелиЧасти = ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеТаблицы 
		Тогда
			ЗагрузитьДоступныеНастройкиКомпоновки();
			СвязиТаблицПриАктивизацииСтроки();
		КонецЕсли; 
	КонецЕсли; 
	ПанельЧастиОбновитьТекущуюСтраницу();
	ЭтаФорма.мСтараяСтраницаПанелиЧасти = Элемент.Страницы[ТекущаяСтраница];
	
КонецПроцедуры

Функция ПанельЧастиОбновитьТекущуюСтраницу()

	лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.ТекущаяСтраница;
	Если лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Группировки Тогда
		//ДоступныеВыбранныеПоля = ВыбранныеПоля.Скопировать();
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Текст Тогда
		ПересобратьВременныйТекстЧасти();
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Построитель Тогда
		ЭтаФорма.ДоступныеВыбранныеПоляЧасти = ВыбранныеПоля.Скопировать();
		ДоступныеВыбранныеПоляЧасти.Сортировать("Имя");
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц Тогда
		ЭлементыФормы.СвязиТаблиц.ОбновитьСтроки();
		Если ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока = Неопределено Тогда
			Если СвязиТаблиц.Строки.Количество() > 0 Тогда
				ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока = СвязиТаблиц.Строки[0];
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Процедура ПересобратьВременныйТекстЧасти()

	Если ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Состояние("Сборка текста части объединения...");
	ТекстЧасти = СобратьТекстЧастиОбъединения(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока, ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока);
	ирОбщий.УстановитьТекстПоляСохраняяПозициюЛкс(ЭлементыФормы.ПолеТекстаЧасти, ТекстЧасти);
	Состояние();

КонецПроцедуры

Процедура ЗагрузитьДоступныеНастройкиКомпоновки()
	
	ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	Если ЧастьОбъединения = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения);
	КомпоновщикУсловияСвязи.Инициализировать(ЧастьОбъединения.ИсточникНастроек);
	Если ЧастиОбъединения.Количество() = 1 Тогда
		КомпоновщикЗапроса.Инициализировать(ЧастьОбъединения.ИсточникНастроек);
	Иначе
		КомпоновщикЗапроса.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(Новый СхемаКомпоновкиДанных));
	КонецЕсли; 
	
КонецПроцедуры

Функция ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	ДоступныеПоляВыбора = Новый ДеревоЗначений;
	ДоступныеПоляВыбора.Колонки.Добавить("Имя");
	ДоступныеПоляВыбора.Колонки.Добавить("ТипЗначения");
	Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
		СтрокаТаблицыВДереве = ДоступныеПоляВыбора.Строки.Добавить();
		ИмяТаблицы = ПолучитьИмяВыбраннойТаблицы(ВыбраннаяТаблица);
		СтрокаТаблицыВДереве.Имя = ИмяТаблицы;
		ДоступныеПоляТаблицы = ПолучитьДоступныеПоляТаблицы(ИмяТаблицы, ЧастьОбъединения);
		Для Каждого ДоступноеПолеТаблицы Из ДоступныеПоляТаблицы Цикл
			СтрокаПоляВДереве = СтрокаТаблицыВДереве.Строки.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаПоляВДереве, ДоступноеПолеТаблицы); 
		КонецЦикла;
	КонецЦикла;
	Если Параметры.Количество() > 0 Тогда
		СтрокаГруппыПараметраВДереве = ДоступныеПоляВыбора.Строки.Добавить();
		СтрокаГруппыПараметраВДереве.Имя = "<Параметры>";
		Для Каждого CтрокаПараметра Из Параметры Цикл
			СтрокаПараметраВДереве = СтрокаГруппыПараметраВДереве.Строки.Добавить();
			СтрокаПараметраВДереве.Имя = CтрокаПараметра.Имя;
			СтрокаПараметраВДереве.ТипЗначения = CтрокаПараметра.ТипЗначения;
		КонецЦикла;
	КонецЕсли; 
	
	СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
	ИсточникДанных = ирОбщий.ДобавитьЛокальныйИсточникДанныхЛкс(СхемаКомпоновки);
	НаборДанных = СхемаКомпоновки.НаборыДанных.Добавить(Тип("НаборДанныхОбъектСхемыКомпоновкиДанных"));
	НаборДанных.ИсточникДанных = ИсточникДанных.Имя;
	Для Каждого СтрокаДоступнойТаблицы Из ДоступныеПоляВыбора.Строки Цикл
		Если СтрокаДоступнойТаблицы.Имя = "<Параметры>" Тогда
			Продолжить;
		КонецЕсли; 
		ПапкаПолей = НаборДанных.Поля.Добавить(Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных"));
		ПапкаПолей.ПутьКДанным = СтрокаДоступнойТаблицы.Имя;
		ПапкаПолей.Заголовок = ПапкаПолей.ПутьКДанным;
		Для Каждого СтрокаДоступногоПоля Из СтрокаДоступнойТаблицы.Строки Цикл
			ПолеНабора = НаборДанных.Поля.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
			ПолеНабора.Поле = СтрокаДоступногоПоля.Имя;
			Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
				ПолеНабора.ПутьКДанным = СтрокаДоступнойТаблицы.Имя + "." + ПолеНабора.Поле;
			Иначе
				ПолеНабора.ПутьКДанным = ПолеНабора.Поле;
			КонецЕсли; 
			ПолеНабора.Заголовок = ПолеНабора.ПутьКДанным;
			ПолеНабора.ТипЗначения = СтрокаДоступногоПоля.ТипЗначения;
		КонецЦикла;
	КонецЦикла;
	Для Каждого Параметр Из Параметры Цикл
		ПараметрСхемы = СхемаКомпоновки.Параметры.Добавить();
		ПараметрСхемы.Имя = Параметр.Имя;
		ПараметрСхемы.ТипЗначения = Параметр.ТипЗначения;
	КонецЦикла;
	ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки);
	ЧастьОбъединения.ИсточникНастроек = ИсточникНастроек;
	ЧастьОбъединения.Компоновщик.Инициализировать(ИсточникНастроек);
	Возврат ИсточникНастроек;

КонецФункции

Процедура ПриОткрытии()
	
	ЭтаФорма.мСтараяСтраницаПанелиЧасти = ЭлементыФормы.ПанельЧасти.ТекущаяСтраница;
	ЭтаФорма.мСтараяСтраницаПанелиОсновная = ЭлементыФормы.ПанельОсновная.ТекущаяСтраница;
	
	// +++.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
	ПолеТекстовогоДокументаСКонтекстнойПодсказкой = Новый Структура;
	
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если _ Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеВыбранногоПоля, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);

	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если _ Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеЭлементаУсловияСвязи, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);

	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если _ Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеЭлементаУсловия, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);
		
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если _ Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеПараметраТаблицы, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);
		
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если _ Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ПолеТекстаЗапроса, , 1,,,, Конфигурация);
		
	// ---.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
	
	ирОбщий.ОбновитьТекстПослеМаркераВСтрокеЛкс(ЭтаФорма.Заголовок,, мДиалектSQL);
	мТекущийДиалектSQL = мДиалектSQL;
	Если ЗапросыПакета.Количество() = 0 Тогда
		УстановитьДанные();
	КонецЕсли; 
	ЭлементыФормы.Параметры.ТолькоПросмотр = ТабличноеПолеКорневогоПакета <> ЭлементыФормы.ЗапросыПакета;
	ИзменитьСвернутостьПанельПакета(ЛиПакетныйЗапрос);

КонецПроцедуры

// Выполняет программный код в контексте.
//
// Параметры:
//  ТекстДляВыполнения – Строка;
//  *ЛиСинтаксическийКонтроль - Булево, *Ложь - признак вызова только для синтаксического контроля.
//
Функция ПроверитьВыражение(ТекстДляПроверки, ЛиСинтаксическийКонтроль = Ложь) Экспорт
	

КонецФункции // ВычислитьВФорме()

Процедура ОбновитьДоступныеВременныеТаблицы() Экспорт
	
	Если ТабличноеПолеКорневогоПакета <> ЭлементыФормы.ЗапросыПакета Тогда
		// Это вложенный запрос
		Возврат;
	КонецЕсли; 
	СтрокиТаблиц = ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип", "ВременнаяТаблица"));
	Если ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока <> Неопределено Тогда
		ИндексТекущегоЗапроса = ЗапросыПакета.Индекс(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);
	Иначе
		ИндексТекущегоЗапроса = ЗапросыПакета.Количество() - 1;
	КонецЕсли; 
	Для Каждого СтрокаКУдалению Из СтрокиТаблиц Цикл
		СтрокаПородившегоЗапроса = ЗапросыПакета.Найти(СтрокаКУдалению.ПородившийЗапрос, "ИД");
		Если Истина
			И СтрокаПородившегоЗапроса <> Неопределено
			И ИндексТекущегоЗапроса <= ЗапросыПакета.Индекс(СтрокаПородившегоЗапроса) 
		Тогда
			ДоступныеТаблицы.Удалить(СтрокаКУдалению);
		КонецЕсли; 
	КонецЦикла;
	СтруктураДобавленныхТаблиц = Новый Структура();
	Для Индекс = 0 По ИндексТекущегоЗапроса - 1 Цикл
		ЗапросПакета = ЗапросыПакета[Индекс];
		Если ЗапросПакета.ТипЗапроса = 1 Тогда
			//Если ДоступныеТаблицы.Найти(НРег(ЗапросПакета.ИмяВременнойТаблицы), "НПолноеИмя") = Неопределено Тогда
				СтруктураДобавленныхТаблиц.Вставить(ЗапросПакета.ИмяВременнойТаблицы, ЗапросПакета.ИД);
			//КонецЕсли; 
		ИначеЕсли ЗапросПакета.ТипЗапроса = 2 Тогда
			Если СтруктураДобавленныхТаблиц.Свойство(ЗапросПакета.ИмяВременнойТаблицы) Тогда
				СтруктураДобавленныхТаблиц.Удалить(ЗапросПакета.ИмяВременнойТаблицы);
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Для Каждого КлючИЗначение Из СтруктураДобавленныхТаблиц Цикл
		ДобавитьДоступнуюТаблицу1С(КлючИЗначение.Ключ, "ВременнаяТаблица", , , КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьДоступныеТаблицы1С()

	//ОчиститьДоступныеНеВременныеТаблицы();
	ДоступныеВременныеТаблицы = ДоступныеТаблицы.Выгрузить(Новый Структура("Тип", "ВременнаяТаблица"));
	ДоступныеТаблицы.Очистить();
	Если ЭтотОбъект.мДоступныеТаблицыКонфигурации <> Неопределено Тогда
		ДоступныеТаблицы.Загрузить(ЭтотОбъект.мДоступныеТаблицыКонфигурации);
		ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ДоступныеВременныеТаблицы, ДоступныеТаблицы);
		Возврат;
	КонецЕсли; 
	ДоступныеТаблицы.Загрузить(ДоступныеВременныеТаблицы);
	Состояние("Подготовка метаданных...");
	ТабличноеПолеДоступныхТаблиц = ЭлементыФормы.ДоступныеТаблицы;
	Если ТабличноеПолеДоступныхТаблиц.ТекущаяСтрока <> Неопределено Тогда
		КлючТекущейСтроки = ТабличноеПолеДоступныхТаблиц.ТекущаяСтрока.ПолноеИмяОбъекта;
	КонецЕсли; 
	КоллекцияКорневыхТипов = Новый Массив;
	СтрокиМетаОбъектов = ирКэш.Получить().ТаблицаТиповМетаОбъектов.НайтиСтроки(Новый Структура("Категория", 0));
	Для Каждого СтрокаТаблицыМетаОбъектов Из СтрокиМетаОбъектов Цикл
		Единственное = СтрокаТаблицыМетаОбъектов.Единственное;
		Если Ложь
			Или Единственное = "Последовательность"
			Или Единственное = "КритерийОтбора"
			Или Единственное = "ЖурналДокументов"
			Или ирОбщий.ЛиКорневойТипОбъектаБДЛкс(Единственное)
			Или ирОбщий.ЛиКорневойТипРегистраБДЛкс(Единственное)
		Тогда
			КоллекцияКорневыхТипов.Добавить(Единственное);
		КонецЕсли;
	КонецЦикла;
	Если ирКэш.Получить().ВерсияПлатформы >= 802014 Тогда
		Для Каждого МетаВнешнийИсточникДанных Из Метаданные.ВнешниеИсточникиДанных Цикл
			КоллекцияКорневыхТипов.Добавить(МетаВнешнийИсточникДанных);
		КонецЦикла; 
	КонецЕсли; 
	ДобавитьДоступнуюТаблицу1С("Константы");
	КоллекцияКорневыхТипов.Добавить("Константа");
	мСтрокаТипаВнешнегоИсточникаДанных = мПлатформа.ПолучитьСтрокуТипаМетаОбъектов("ВнешнийИсточникДанных", , 0);
	Для Каждого КорневойТип Из КоллекцияКорневыхТипов Цикл
		СтрокаКорневогоТипа = мПлатформа.ПолучитьСтрокуТипаМетаОбъектов(КорневойТип);
		Если СтрокаКорневогоТипа = Неопределено Тогда
			СтрокаКорневогоТипа = мСтрокаТипаВнешнегоИсточникаДанных;
			МножественноеКорневогоТипа = СтрокаКорневогоТипа.Множественное;
			КоллекцияМетаданных = Метаданные.ВнешниеИсточникиДанных[КорневойТип.Имя].Таблицы;
			ПредставлениеКатегории = КорневойТип.Представление();
			СхемаТаблиц = "ВнешнийИсточникДанных." + КорневойТип.Имя;
		Иначе
			МножественноеКорневогоТипа = СтрокаКорневогоТипа.Множественное;
			КоллекцияМетаданных = Метаданные[МножественноеКорневогоТипа];
			ПредставлениеКатегории = ирОбщий.ПолучитьПредставлениеИзИдентификатораЛкс(МножественноеКорневогоТипа);
			СхемаТаблиц = "";
		КонецЕсли; 
		Если КоллекцияМетаданных.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		Для Каждого МетаИсточник Из КоллекцияМетаданных Цикл
			ПолноеИмяМД = МетаИсточник.ПолноеИмя();
			//Если ДоступныеОбъектыТипа <> Неопределено Тогда
			//	Если ДоступныеОбъектыТипа[НРег(МетаИсточник.Имя)] = Неопределено Тогда
			//		Продолжить;
			//	КонецЕсли; 
			//КонецЕсли;
			//
			ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД, ирОбщий.ПолучитьПервыйФрагментЛкс(ПолноеИмяМД), МетаИсточник.Имя, СхемаТаблиц);
			Если ирОбщий.ЛиКорневойТипОбъектаБДЛкс(КорневойТип) Тогда
				СтруктураТЧ = ирОбщий.ПолучитьТабличныеЧастиОбъектаЛкс(МетаИсточник);
				Для Каждого КлючИЗначение Из СтруктураТЧ Цикл
					ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + "." + КлючИЗначение.Ключ, "ТабличнаяЧасть");
				КонецЦикла;
			КонецЕсли; 
			Если ирОбщий.ЕстьТаблицаИзмененийОбъектаМетаданных(МетаИсточник) Тогда
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Изменения", "Изменения");
			КонецЕсли;
			Если КорневойТип = "РегистрСведений" Тогда 
				Если МетаИсточник.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
					ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".СрезПоследних", "ВиртуальнаяТаблица");
				КонецЕсли;
			ИначеЕсли КорневойТип = "РегистрНакопления" Тогда 
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Обороты", "ВиртуальнаяТаблица");
				Если МетаИсточник.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
					ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Остатки", "ВиртуальнаяТаблица");
					ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".ОстаткиИОбороты", "ВиртуальнаяТаблица");
				КонецЕсли;
			ИначеЕсли КорневойТип = "РегистрБухгалтерии" Тогда 
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Обороты", "ВиртуальнаяТаблица");
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".ОборотыДтКт", "ВиртуальнаяТаблица");
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".ДвиженияССубконто", "ВиртуальнаяТаблица");
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Остатки", "ВиртуальнаяТаблица");
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".ОстаткиИОбороты", "ВиртуальнаяТаблица");
			ИначеЕсли КорневойТип = "Последовательность" Тогда 
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Границы", "ВиртуальнаяТаблица");
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	ЭлементыФормы.ДоступныеТаблицы.Колонки.Тип.Видимость = Истина;
	ТекущаяСтрокаУстановлена = Ложь;
	Если КлючТекущейСтроки <> Неопределено Тогда
		НоваяТекущаяСтрока = ДоступныеТаблицы.Найти(КлючТекущейСтроки, "ПолноеИмяОбъекта", Истина);
		Если НоваяТекущаяСтрока <> Неопределено Тогда
			ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока = НоваяТекущаяСтрока;
			ТекущаяСтрокаУстановлена = Истина;
		КонецЕсли; 
	КонецЕсли;
	ЭтотОбъект.мДоступныеТаблицыКонфигурации = ДоступныеТаблицы.Выгрузить();
	ОчиститьДоступныеВременныеТаблицы(ЭтотОбъект.мДоступныеТаблицыКонфигурации);
	
КонецПроцедуры

Функция ДобавитьДоступнуюТаблицу1С(ПолноеИмя, ТипТаблицы = "", Имя = "", СхемаТаблицы = "", ПородившийЗапрос = 0)
	
	Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмя);
	Если Фрагменты.Количество() > 1 Тогда
		Если Не ЗначениеЗаполнено(СхемаТаблицы) Тогда
			СхемаТаблицы = Фрагменты[0];
		КонецЕсли; 
		Фрагменты.Удалить(0);
	КонецЕсли;
	СтрокаТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмя), "НПолноеИмя");
	Если СтрокаТаблицы = Неопределено Тогда
		СтрокаТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаТаблицы.Схема = СхемаТаблицы;
		СтрокаТаблицы.ПолноеИмя = ПолноеИмя;
		СтрокаТаблицы.НПолноеИмя = НРег(СтрокаТаблицы.ПолноеИмя);
		Если Не ЗначениеЗаполнено(Имя) Тогда
			СтрокаТаблицы.Имя = ирОбщий.ПолучитьСтрокуСРазделителемИзМассиваЛкс(Фрагменты, ".");
		Иначе
			СтрокаТаблицы.Имя = Имя;
		КонецЕсли; 
		Если Не ЗначениеЗаполнено(ТипТаблицы) Тогда
			ТипТаблицы = ирОбщий.ПолучитьТипТаблицыБДЛкс(ПолноеИмя);
		КонецЕсли; 
		СтрокаТаблицы.Тип = ТипТаблицы;
		//СтрокаТаблицы.Описание = МетаИсточник.Представление();
	КонецЕсли; 
	СтрокаТаблицы.ПородившийЗапрос = ПородившийЗапрос;

КонецФункции

Функция ПолучитьДоступныеПоляТаблицы(ИмяИлиСтрокаВыбраннойТаблицы, ЧастьОбъединения = Неопределено)
	
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Если ТипЗнч(ИмяИлиСтрокаВыбраннойТаблицы) = Тип("Строка") Тогда
		ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(ИмяИлиСтрокаВыбраннойТаблицы), "НИмя");
		Если ВыбраннаяТаблица = Неопределено Тогда
			ВызватьИсключение "Выбранная таблица """ + ИмяИлиСтрокаВыбраннойТаблицы+ """ не найдена";
		КонецЕсли; 
	Иначе
		ВыбраннаяТаблица = ИмяИлиСтрокаВыбраннойТаблицы;
	КонецЕсли; 
	ДоступныеПоляТаблицы = Новый ТаблицаЗначений;
	ДоступныеПоляТаблицы.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ДоступныеПоляТаблицы.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
	ДоступныеПоляТаблицы.Колонки.Добавить("Поле", Новый ОписаниеТипов("Строка"));
	ДоступныеПоляТаблицы.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ВыбраннаяТаблица.ПолноеИмя), "НПолноеИмя");
	Если ВыбраннаяТаблица.ВложенныйПакет <> Неопределено Тогда
		ПоляТаблицы = ВыбраннаяТаблица.ВложенныйПакет[0].ЧастиОбъединения[0].ВыбранныеПоля;
		//СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения; // Здесь еще надо тип вычислять
	ИначеЕсли СтрокаДоступнойТаблицы <> Неопределено Тогда
		ПоляТаблицы = ПолучитьПоляДоступнойТаблицы(СтрокаДоступнойТаблицы);
	Иначе
		ПоляТаблицы = Новый ТаблицаЗначений;
		ПоляТаблицы.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
		ПоляТаблицы.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
		СтрокаВиртуальногоПоля = ПоляТаблицы.Добавить();
		СтрокаВиртуальногоПоля.Имя = "_НеизвестноеПоле_";
	КонецЕсли;
	Если ПоляТаблицы <> Неопределено Тогда
		Для Каждого СтрокаПоля Из ПоляТаблицы Цикл
			СтрокаДоступногоПоля = ДоступныеПоляТаблицы.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаДоступногоПоля, СтрокаПоля); 
			ИмяПоля = СтрокаПоля.Имя;
			Если Не ирОбщий.ЛиИмяПеременнойЛкс(ИмяПоля) Тогда
				ИмяПоля = "[" + ИмяПоля + "]";
			КонецЕсли; 
			СтрокаДоступногоПоля.Имя = СтрокаПоля.Имя;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаДоступногоПоля);
			СтрокаДоступногоПоля.Поле = ИмяПоля;
			Если ЗначениеЗаполнено(ВыбраннаяТаблица.Имя) Тогда
				СтрокаДоступногоПоля.Поле = ВыбраннаяТаблица.Имя + "." + СтрокаДоступногоПоля.Поле;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	Возврат ДоступныеПоляТаблицы;

КонецФункции

Функция ПолучитьПоляДоступнойТаблицы(СтрокаДоступнойТаблицы)
	
	ПолноеИмяТаблицы = СтрокаДоступнойТаблицы.ПолноеИмя;
	ТаблицаПолей = Новый ТаблицаЗначений;
	ТаблицаПолей.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ТаблицаПолей.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	Если СтрокаДоступнойТаблицы.Тип = "ВременнаяТаблица" Тогда
		ПородившийЗапрос = ТабличноеПолеКорневогоПакета.Значение.Найти(СтрокаДоступнойТаблицы.ПородившийЗапрос, "ИД");
		КолонкиРезультата = Новый Массив();
		Если ПородившийЗапрос <> Неопределено Тогда
			КолонкиРезультата = ПородившийЗапрос.ЧастиОбъединения[0].ВыбранныеПоля;
		Иначе
			ТекстЗапроса = "SELECT * FROM " + ПолноеИмяТаблицы + " WHERE FALSE";
			Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
				ВременныйЗапрос = Новый Запрос;
				ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
				ВременныйЗапрос.Текст = ТекстЗапроса;
				РезультатВременногоЗапроса = Неопределено;
				Попытка
					РезультатВременногоЗапроса = ВременныйЗапрос.Выполнить();
				Исключение
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					КолонкиРезультата = РезультатВременногоЗапроса.Колонки;
				КонецЕсли;
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
				//
			Иначе // ADO
				Попытка
					РезультатВременногоЗапроса = Конфигурация.Execute(ТекстЗапроса);
				Исключение
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					РезультатТаблица = Новый ТаблицаЗначений;
					ирОбщий.ПолучитьКолонкиRecordsetADOЛкс(РезультатТаблица, РезультатВременногоЗапроса, Истина);
					КолонкиРезультата = РезультатТаблица.Колонки;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			Если ВыбранноеПоле.Имя = "" Тогда
				ВызватьИсключение "Не определены имена полей таблицы """ + ПолноеИмяТаблицы + """";
			КонецЕсли; 
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация") Тогда
		КомпоновщикТаблицы = ирКэш.ПолучитьКомпоновщикТаблицыМетаданныхЛкс(ПолноеИмяТаблицы, Ложь);
		Если КомпоновщикТаблицы <> Неопределено Тогда
			Для Каждого ДоступноеПоле Из КомпоновщикТаблицы.Настройки.ДоступныеПоляВыбора.Элементы Цикл
				Если ДоступноеПоле.Папка Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаПоля = ТаблицаПолей.Добавить();
				СтрокаПоля.Имя = ДоступноеПоле.Поле;
				СтрокаПоля.ТипЗначения = ДоступноеПоле.ТипЗначения;
			КонецЦикла;
		КонецЕсли; 
	Иначе
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяТаблицы), "НПолноеИмя");
		Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
			wbemFlagUseAmendedQualifiers = 131072; //&H20000
			ОписаниеКласса = Конфигурация.Get(СтрокаДоступнойТаблицы.Имя, wbemFlagUseAmendedQualifiers);
			ТаблицаКласса = Новый ТаблицаЗначений;
			МассивКоллекцийСвойств = Новый Массив();
			МассивКоллекцийСвойств.Добавить(ОписаниеКласса.Properties_);
			//Если СобиратьСистемныеСвойстваWMI Тогда
			//	МассивКоллекцийСвойств.Добавить(ОписаниеКласса.SystemProperties_);
			//КонецЕсли; 
			Для Каждого КоллекцияСвойств Из МассивКоллекцийСвойств Цикл
				Для Каждого Свойство Из КоллекцияСвойств Цикл
					ИмяТипа = ирОбщий.ПолучитьИмяТипаИзКвалификаторовWMIЛкс(Свойство);
					Попытка
						ОписаниеТипов = Новый ОписаниеТипов(ИмяТипа,,,, Новый КвалификаторыСтроки(1024)); // Доделать распознавание типов
					Исключение
						ОписаниеТипов = Новый ОписаниеТипов();
					КонецПопытки;
					ПредставлениеСвойства = ирОбщий.ПолучитьОписаниеЭлементаWMIЛкс(Свойство, "DisplayName");
					ТаблицаКласса.Колонки.Добавить(, ОписаниеТипов, ПредставлениеСвойства);
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = Свойство.Name;
					СтрокаПоля.ТипЗначения = ОписаниеТипов;
					//СтрокаПоля.Описание = ПредставлениеСвойства;
				КонецЦикла;
			КонецЦикла;
		Иначе // ADO
			Фильтры = Новый Массив();
			Фильтры.Добавить(); //TABLE_CATALOG
			Если ЗначениеЗаполнено(СтрокаДоступнойТаблицы.Схема) Тогда //TABLE_SCHEMA
				Фильтры.Добавить(СтрокаДоступнойТаблицы.Схема);
			Иначе
				Фильтры.Добавить(Неопределено);
			КонецЕсли; 
			Фильтры.Добавить(СтрокаДоступнойТаблицы.Имя); // TABLE_NAME
			Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
			Состояние("Запрашиваем поля " + ПолноеИмяТаблицы + "...");
			ОписаниеПолейRecordSet = Конфигурация.OpenSchema(4, Фильтры); //adSchemaColumns
			ADOUtils = мПлатформа.ПолучитьADOUtils();
			Если ADOUtils <> Неопределено Тогда
				ОписаниеПолейТЗ = ADOUtils.ADORecordsetToValueTable(ОписаниеПолейRecordSet);
				Для Каждого СтрокаТЗ Из ОписаниеПолейТЗ Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = СтрокаТЗ.COLUMN_NAME;
					ЧисловаяРазрядность = СтрокаТЗ.NUMERIC_SCALE;
					ДлинаТипа = СтрокаТЗ.CHARACTER_MAXIMUM_LENGTH;
					ЧисловаяТочность = СтрокаТЗ.NUMERIC_PRECISION;
					НомерТипа = СтрокаТЗ.DATA_TYPE;
					FieldADO = ирОбщий.FieldADO(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1C(FieldADO);
				КонецЦикла;
			Иначе
				Пока Не ОписаниеПолейRecordSet.EOF() Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = ОписаниеПолейRecordSet.Fields("COLUMN_NAME").Value;
					ЧисловаяРазрядность = ОписаниеПолейRecordSet.Fields("NUMERIC_SCALE").Value;
					ДлинаТипа = ОписаниеПолейRecordSet.Fields("CHARACTER_MAXIMUM_LENGTH").Value;
					ЧисловаяТочность = ОписаниеПолейRecordSet.Fields("NUMERIC_PRECISION").Value;
					НомерТипа = ОписаниеПолейRecordSet.Fields("DATA_TYPE").Value;
					FieldADO = ирОбщий.FieldADO(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1C(FieldADO);
					ОписаниеПолейRecordSet.MoveNext();
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Состояние();
	КонецЕсли; 
	Возврат ТаблицаПолей;
	
КонецФункции

Процедура ОбновлениеОтображения()
	
	ирОбщий.ОбновитьЗаголовкиСтраницПанелейЛкс(ЭтаФорма);
	Если ПараметрыДиалектаSQL <> Неопределено Тогда
		ЭлементыФормы.ВыбранныеТаблицыПанельЭлемента.Доступность = ЭлементыФормы.ВыбранныеТаблицы.Значение.Количество() > 0;
		ЭлементыФормы.ВыбранныеПоляПанельЭлемента.Доступность = ЭлементыФормы.ВыбранныеПоля.Значение.Количество() > 0;
		ЭлементыФормы.СвязиТаблицПанельЭлемента.Доступность = Истина
			И ЭлементыФормы.СвязиТаблиц.Значение.Строки.Количество() > 0
			И ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока <> СвязиТаблиц.Строки[0];
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.Доступность = ЭлементыФормы.ДеревоУсловияСвязи.Значение.Элементы.Количество() > 0;
		ЭлементыФормы.РежимОбъединения.Доступность = Истина
			И ПараметрыДиалектаSQL.Объединения 
			И ЧастиОбъединения.Количество() = 1;
		ЭлементыФормы.ЛиПакетныйЗапрос.Доступность = Истина
			И ПараметрыДиалектаSQL.Пакет 
			И ЗапросыПакета.Количество() = 1;
		ЭлементыФормы.ИмяВременнойТаблицы.Доступность = Ложь
			Или ТипЗапроса = 1
			Или ТипЗапроса = 2;
		ЭлементыФормы.КомментарийОтбора.Доступность = ТипЗапроса <> 2;
		ЭлементыФормы.ОпцияПервые.Доступность = Истина
			И ПараметрыДиалектаSQL.Первые 
			И ТипЗапроса <> 2;
		ЭлементыФормы.ПервыеКоличество.Доступность = Истина
			И ПараметрыДиалектаSQL.Первые
			И ТипЗапроса <> 2;
		ЭлементыФормы.ОпцияРазрешенные.Доступность = Истина
			И ПараметрыДиалектаSQL.Это1С
			И ТипЗапроса <> 2;
		//Если ТипЗапроса = 2 Тогда
		//	Если Истина
		//		И ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения
		//		И ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ЭлементыФормы.ПанельОсновная.Страницы.Текст
		//	Тогда
		//		ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения;
		//	КонецЕсли; 
		//	Если Истина
		//		И ЭлементыФормы.ПанельЧасти.ТекущаяСтраница <> ЭлементыФормы.ПанельЧасти.Страницы.КомментарийЧасти
		//	Тогда
		//		ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.КомментарийЧасти;
		//	КонецЕсли; 
		//КонецЕсли; 
		ЭлементыФормы.ПанельОсновная.Страницы.ПоляИндекса.Видимость = ТипЗапроса = 1;
		ЭлементыФормы.ПанельОсновная.Страницы.ПоляПорядка.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельОсновная.Страницы.Параметры.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельОсновная.Страницы.Итоги.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения.Видимость = Истина
			И ПараметрыДиалектаSQL.Объединения 
			//И ЧастиОбъединения.Количество() > 1 // Для исправления пользователем пока имеющихся ошибок в сборе полей объединения
			И РежимОбъединения;
		ЭлементыФормы.ПанельОсновная.Страницы.Построитель.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц.Видимость = Истина
			И ТипЗапроса <> 2
			И ВыбранныеТаблицы.Количество() > 1;
		ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеПоля.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеТаблицы.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.ДеревоУсловия.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.Группировки.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.Текст.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.Построитель.Видимость = ТипЗапроса <> 2;
	КонецЕсли; 

КонецПроцедуры

Функция ПриВыводеСтрокиДоступныхТаблицСвязи(ОформлениеСтроки, ДанныеСтроки)

	ТаблицаДобавленаВСвязи = Ложь
		Или СвязиТаблиц.Строки.Найти(ДанныеСтроки.Имя, "Таблица", Истина) <> Неопределено;
	Если ТаблицаДобавленаВСвязи Тогда
		ОформлениеСтроки.ЦветТекста = ирОбщий.ПолучитьЦветСтиляЛкс("ирТекстИнформационнойНадписи");
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Процедура ВыборЛевойТаблицыСвязиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ПриВыводеСтрокиДоступныхТаблицСвязи(ОформлениеСтроки, ДанныеСтроки);
	ВыбранныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ВыборПравойТаблицыСвязиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ПриВыводеСтрокиДоступныхТаблицСвязи(ОформлениеСтроки, ДанныеСтроки);
	ВыбранныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ВыбранныеТаблицыИмяПриИзменении(Элемент)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	мТекущаяСтрокаВыбранныеТаблицы.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(мТекущаяСтрокаВыбранныеТаблицы.Владелец(),
		мТекущаяСтрокаВыбранныеТаблицы,,, ПолучитьСловоЯзыкаЗапросов("Table"));
	ПереименоватьВыбраннуюТаблицу();
	ОбновитьТекущееИмяТаблицы();
	ЗагрузитьВыражениеУсловия();
	ЗагрузитьВыражениеУсловияСвязи();
	ЗагрузитьПараметрТаблицы();
	ЗагрузитьВыбранноеПоле();
	ЗагрузитьСвязьТаблицы();
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(мТекущаяСтрокаВыбранныеТаблицы);
	
КонецПроцедуры

Процедура ПереименоватьВыбраннуюТаблицу()
	
	НовоеИмяТаблицы = мТекущаяСтрокаВыбранныеТаблицы.Имя;
	//Если ирОбщий.СтрокиРавныЛкс(мТекущееИмяВыбраннойТаблицы, НовоеИмяТаблицы)  Тогда
	Если мТекущееИмяВыбраннойТаблицы = НовоеИмяТаблицы Тогда
		Возврат;
	КонецЕсли; 
	ПереименоватьТаблицуИлиПараметр(, мТекущееИмяВыбраннойТаблицы, НовоеИмяТаблицы);

КонецПроцедуры

Процедура ПереименоватьТаблицуИлиПараметр(Пакет = Неопределено, Знач СтароеИмя, Знач НовоеИмя)
    
    Состояние("Обновление выражений...");
	ЭтоПереименованиеПараметра = мПараметрыДиалектаSQL.ПрефиксПараметра = Лев(СтароеИмя, 1);
	Если Пакет = Неопределено Тогда
		Если ЭтоПереименованиеПараметра Тогда
			Пакет = ЗапросыПакета;
		Иначе
			Пакет = Новый Массив;
			Пакет.Добавить(мТекущаяСтрокаЗапросыПакета);
		КонецЕсли; 
	КонецЕсли; 
	Для Каждого ЗапросПакета Из Пакет Цикл
		Если ЭтоПереименованиеПараметра Тогда
			лЧастиОбъединения = ЗапросПакета.ЧастиОбъединения;
		Иначе
			лЧастиОбъединения = Новый Массив;
			лЧастиОбъединения.Добавить(мТекущаяСтрокаЧастиОбъединения);
		КонецЕсли;
		Для Каждого ЧастьОбъединения Из лЧастиОбъединения Цикл
			Если ЭтоПереименованиеПараметра Тогда
				Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
					Для Каждого ПараметрТаблицы Из ВыбраннаяТаблица.Параметры Цикл
						Если ЗначениеЗаполнено(ПараметрТаблицы.Определение) Тогда
					        ОбновитьВыражениеЗапроса(ПараметрТаблицы, ЭлементыФормы.ПараметрыТаблицы, , ЧастьОбъединения, СтароеИмя, НовоеИмя,,,, 0);
							Если мТекущаяСтрокаПараметраТаблицы = ПараметрТаблицы Тогда
								ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст(мТекущаяСтрокаПараметраТаблицы.Определение);
							КонецЕсли; 
						КонецЕсли; 
					КонецЦикла;
					Если ВыбраннаяТаблица.ВложенныйПакет <> Неопределено Тогда
						ПереименоватьТаблицуИлиПараметр(ВыбраннаяТаблица.ВложенныйПакет, СтароеИмя, НовоеИмя);
					КонецЕсли; 
			    КонецЦикла;
			КонецЕсли;
		    Для Каждого ВыбранноеПоле Из ЧастьОбъединения.ВыбранныеПоля Цикл
		        ОбновитьВыражениеЗапроса(ВыбранноеПоле, ЭлементыФормы.ВыбранныеПоля, , ЧастьОбъединения, СтароеИмя, НовоеИмя,,,, 0);
				Если мТекущаяСтрокаВыбранногоПоля = ВыбранноеПоле Тогда
					ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(мТекущаяСтрокаВыбранногоПоля.Определение);
				КонецЕсли; 
		    КонецЦикла;
		    Для Каждого ПолеГруппировки Из ЧастьОбъединения.Группировки Цикл
		        ОбновитьВыражениеЗапроса(ПолеГруппировки, ЭлементыФормы.Группировки, , ЧастьОбъединения, СтароеИмя, НовоеИмя,,,, 0);
		    КонецЦикла;
			Для Каждого СвязьТаблиц Из ирОбщий.ПолучитьВсеСтрокиДереваЗначенийЛкс(ЧастьОбъединения.СвязиТаблиц) Цикл
		        Если ирОбщий.СтрокиРавныЛкс(СвязьТаблиц.Таблица, СтароеИмя) Тогда
		            СвязьТаблиц.Таблица = НовоеИмя;
		        КонецЕсли; 
				Если СвязьТаблиц.Условие = Неопределено Тогда
					Продолжить;
				КонецЕсли; 
		        ОбновитьВыраженияОтбора(СвязьТаблиц.Условие.Отбор, ЭлементыФормы.ДеревоУсловияСвязи, , ЧастьОбъединения, СтароеИмя, НовоеИмя);
		    КонецЦикла;
		    ОбновитьВыраженияОтбора(ЧастьОбъединения.Условие.Отбор, ЭлементыФормы.ДеревоУсловия, , ЧастьОбъединения, СтароеИмя, НовоеИмя);
		    Для Каждого ПолеПорядка Из мТекущаяСтрокаЗапросыПакета.ПоляПорядка Цикл
		        ОбновитьВыражениеЗапроса(ПолеПорядка, ЭлементыФормы.ПоляПорядка,,,,,,, Ложь, 0);
		    КонецЦикла;
		    //Для Каждого ГруппируемоеПолеИтогов Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
		    //	ОбновитьВыражениеЗапроса(ГруппируемоеПолеИтогов);
		    //КонецЦикла;
		    //Для Каждого ГруппирующееПолеИтогов Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
		    //	ОбновитьВыражениеЗапроса(ГруппирующееПолеИтогов);
		    //КонецЦикла;
		    //ОбновитьПоляОбъединенияЗапроса();
		КонецЦикла; 
	КонецЦикла;
    Состояние("");

КонецПроцедуры


Процедура ДоступныеПоляЛевогоПоляПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаУсловияСвязи = ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока;
	Если Истина
		И ТекущаяСтрокаУсловияСвязи <> Неопределено
		И Не Элемент.ТекущаяСтрока.Папка
		И ТипЗнч(ТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных")
	Тогда
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока.ЛевоеЗначение = Элемент.ТекущаяСтрока.Поле;
	КонецЕсли; 

КонецПроцедуры

Процедура ДоступныеПоляПравогоПоляПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаУсловияСвязи = ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока;
	Если Истина
		И ТекущаяСтрокаУсловияСвязи <> Неопределено
		И Не Элемент.ТекущаяСтрока.Папка
		И ТипЗнч(ТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных")
	Тогда
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока.ПравоеЗначение = Элемент.ТекущаяСтрока.Поле;
	КонецЕсли; 

КонецПроцедуры

Процедура ВыборЛевойТаблицыСвязиПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаСвязи = ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока;
	Если ТекущаяСтрокаСвязи <> Неопределено Тогда
		Если ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.Таблица <> Элемент.ТекущаяСтрока.Имя Тогда
			ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.ЛеваяТаблица = Элемент.ТекущаяСтрока.Имя;
			//ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока, "ЛеваяТаблица");
			ПриУстановкеЛевойТаблицыСвязи();
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура ПриУстановкеЛевойТаблицыСвязи()
	
	// Надо раскрыть ветвь ее доступных полей
	
КонецПроцедуры

Процедура ВыборПравойТаблицыСвязиПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаСвязи = ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока;
	Если ТекущаяСтрокаСвязи <> Неопределено Тогда
		Если ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.Таблица <> Элемент.ТекущаяСтрока.Имя Тогда
			ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.Таблица = Элемент.ТекущаяСтрока.Имя;
			//ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока, "ПраваяТаблица");
			ПриУстановкеПравойТаблицыСвязи();
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура ПриУстановкеПравойТаблицыСвязи()
	
	// Надо раскрыть ветвь ее доступных полей
	
КонецПроцедуры

Процедура СвязиТаблицПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ДанныеСтроки.Условие <> Неопределено Тогда
		ОформлениеСтроки.Ячейки.Условие.УстановитьТекст(ДанныеСтроки.Условие.Отбор);
	КонецЕсли; 
	Если ЗначениеЗаполнено(ДанныеСтроки.ТипСвязи) Тогда
		ПредставлениеТипаСвязи = ЭлементыФормы.СвязиТаблиц.Колонки.ТипСвязи.ЭлементУправления.СписокВыбора.НайтиПоЗначению(ДанныеСтроки.ТипСвязи).Представление;
		ОформлениеСтроки.Ячейки.ТипСвязи.УстановитьТекст(ПредставлениеТипаСвязи);
	КонецЕсли; 
	//ОформлениеСтроки.Ячейки.Номер.Значение = СвязиТаблиц.Строки.Индекс(ДанныеСтроки) + 1;
	ОформитьЯчейкуИмениТаблицы(Элемент, ОформлениеСтроки, ДанныеСтроки, "Таблица");
	
КонецПроцедуры

Процедура СохранитьВыбранноеПоле()
	
	Если мТекущаяСтрокаВыбранногоПоля = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ВыбранныеПоля.Индекс(мТекущаяСтрокаВыбранногоПоля) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	мТекущаяСтрокаВыбранногоПоля.Определение = ЭлементыФормы.ВыражениеВыбранногоПоля.ПолучитьТекст();
	ПриИзмененииВыраженияВыбранногоПоля(мТекущаяСтрокаВыбранногоПоля);
	
КонецПроцедуры

Процедура ПриИзмененииВыраженияВыбранногоПоля(ВыбранноеПоле = Неопределено, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено,
	ОбновитьПоляОбъединения = Истина)

	Если ВыбранноеПоле = Неопределено Тогда
		ВыбранноеПоле = мТекущаяСтрокаВыбранногоПоля;
	КонецЕсли; 
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	ЕстьАгрегаты = Ложь;
	ОбновитьВыражениеЗапроса(ВыбранноеПоле,,,,,,, ЕстьАгрегаты);
	ВыбранноеПоле.ТипЗначения = ПолучитьТипЗначенияВыражения(ВыбранноеПоле.Токен, ЧастьОбъединения);
	ВыбранноеПоле.АгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(ВыбранноеПоле.Токен);
	ВыбранноеПоле.ЕстьАгрегаты = ЕстьАгрегаты;
	Если мТекущаяСтрокаВыбранногоПоля = ВыбранноеПоле Тогда
		ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(мТекущаяСтрокаВыбранногоПоля.Определение);
	КонецЕсли; 
	ОбновитьГруппировки();
	Если ОбновитьПоляОбъединения Тогда
		ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьГруппировки()
	
	ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка.ТолькоПросмотр = Автогруппировки;
	ЭлементыФормы.Группировки.ТолькоПросмотр = Автогруппировки;
	Если Автогруппировки Тогда
		КопияГруппировок = Группировки.Скопировать();
		Группировки.Очистить();
		ЕстьАгрегаты = ВыбранныеПоля.Найти(Истина, "ЕстьАгрегаты") <> Неопределено;
		Если ЕстьАгрегаты Тогда
			Для Каждого ВыбранноеПоле Из ВыбранныеПоля Цикл
				Если ВыбранноеПоле.ЕстьАгрегаты Тогда
					Продолжить;
				КонецЕсли; 
				Группировка = Группировки.Найти(ВыбранноеПоле.Определение, "Определение");
				Если Группировка = Неопределено Тогда
					Группировка = Группировки.Добавить();
					Группировка.Определение = ВыбранноеПоле.Определение;
					Группировка.Токен = ВыбранноеПоле.Токен; // !Опасно
					СтрокаКопииГруппировки = КопияГруппировок.Найти(ВыбранноеПоле.Определение, "Определение"); // Чувствительность к регистру!
					Если СтрокаКопииГруппировки <> Неопределено Тогда
						Группировка.Комментарий = СтрокаКопииГруппировки.Комментарий;
					КонецЕсли; 
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура СохранитьВыражениеУсловияСвязи()
	
	Если Ложь 
		Или мТекущаяСтрокаУсловияСвязи = Неопределено 
		Или ТипЗнч(мТекущаяСтрокаУсловияСвязи) = Тип("ОтборКомпоновкиДанных")
	Тогда
		Возврат;
	КонецЕсли; 
	Родитель = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(мТекущаяСтрокаУсловияСвязи, КомпоновщикУсловияСвязи.Настройки.Отбор);
	Если Родитель.Элементы.Индекс(мТекущаяСтрокаУсловияСвязи) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	Если Не ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение.Доступность Тогда
		Возврат;
	КонецЕсли; 
	мТекущаяСтрокаУсловияСвязи.Представление = ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.ПолучитьТекст();
	//ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловияСвязи, ЭлементыФормы.ДеревоУсловияСвязи);
	Если ТипЗнч(мТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловияСвязи);
	КонецЕсли; 
	
КонецПроцедуры

Процедура СохранитьВыражениеУсловия()
	
	Если Ложь 
		Или мТекущаяСтрокаУсловия = Неопределено 
		Или ТипЗнч(мТекущаяСтрокаУсловия) = Тип("ОтборКомпоновкиДанных")
	Тогда
		Возврат;
	КонецЕсли; 
	Родитель = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(мТекущаяСтрокаУсловия, КомпоновщикЧасти.Настройки.Отбор);
	Если Родитель.Элементы.Индекс(мТекущаяСтрокаУсловия) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	Если Не ЭлементыФормы.ВыражениеЭлементаУсловия.Доступность Тогда
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаУсловия.Представление = ЭлементыФормы.ВыражениеЭлементаУсловия.ПолучитьТекст();
	//ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловия, ЭлементыФормы.ДеревоУсловия);
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловия);
	
КонецПроцедуры

Процедура СохранитьУсловиеСвязи()
	
	Если мТекущаяСтрокаСвязи = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Попытка
		Пустышка = мТекущаяСтрокаСвязи.Родитель;
	Исключение
		// Строка была удалена
		Возврат;
	КонецПопытки;
	СохранитьВыражениеУсловияСвязи();
	мТекущаяСтрокаСвязи.Условие = КомпоновщикУсловияСвязи.ПолучитьНастройки();
	
КонецПроцедуры

Процедура ДеревоУсловияСвязиПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьВыражениеУсловияСвязи();
	ЗагрузитьВыражениеУсловияСвязи();
	Если Истина
		И ТипЗнч(ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока) <>  Тип("ЭлементОтбораКомпоновкиДанных")
		И ЭлементыФормы.СвязиТаблиц.ТекущиеДанные <> Неопределено
		И ЭлементыФормы.СвязиТаблиц.ТекущиеДанные.Родитель <> Неопределено 
	Тогда
		ДоступноеПолеЛевойТаблицы = КомпоновщикУсловияСвязи.Настройки.Отбор.ДоступныеПоляОтбора.Элементы.Найти(ЭлементыФормы.СвязиТаблиц.ТекущиеДанные.Родитель.Таблица);
		Если ДоступноеПолеЛевойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = ДоступноеПолеЛевойТаблицы;
			ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.Развернуть(ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока);
		КонецЕсли; 
		ДоступноеПолеПравойТаблицы = КомпоновщикУсловияСвязи.Настройки.Отбор.ДоступныеПоляОтбора.Элементы.Найти(ЭлементыФормы.СвязиТаблиц.ТекущиеДанные.Таблица);
		Если ДоступноеПолеПравойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = ДоступноеПолеПравойТаблицы;
			ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.Развернуть(ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЗагрузитьВыражениеУсловияСвязи()

	мТекущаяСтрокаУсловияСвязи = ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока;
	Если ТипЗнч(мТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Если ТипЗнч(мТекущаяСтрокаУсловияСвязи.ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
			СтрокаВыбораЛевогоПоля = КомпоновщикУсловияСвязи.Настройки.ДоступныеПоляОтбора.НайтиПоле(мТекущаяСтрокаУсловияСвязи.ЛевоеЗначение);
			Если СтрокаВыбораЛевогоПоля <> Неопределено Тогда
				ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = СтрокаВыбораЛевогоПоля;
			КонецЕсли; 
		КонецЕсли; 
		Если ТипЗнч(мТекущаяСтрокаУсловияСвязи.ПравоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
			СтрокаВыбораПравогоПоля = КомпоновщикУсловияСвязи.Настройки.ДоступныеПоляОтбора.НайтиПоле(мТекущаяСтрокаУсловияСвязи.ПравоеЗначение);
			Если СтрокаВыбораПравогоПоля <> Неопределено Тогда
				ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = СтрокаВыбораПравогоПоля;
			КонецЕсли; 
		КонецЕсли; 
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.УстановитьТекст(мТекущаяСтрокаУсловияСвязи.Представление);
		ЭлементыФормы.УсловиеСвязиПанельЭлемента.Доступность = Истина;
		Если мТекущаяСтрокаУсловияСвязи.Представление = "" Тогда
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.ВыборПолей.Доступность = Истина;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение.Доступность = Ложь;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.ТекущаяСтраница = ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.ВыборПолей;
		Иначе
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение.Доступность = Истина;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.ВыборПолей.Доступность = Ложь;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.ТекущаяСтраница = ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение;
		КонецЕсли; 
	Иначе
		ЭлементыФормы.УсловиеСвязиПанельЭлемента.Доступность = Ложь;
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.УстановитьТекст("");
	КонецЕсли; 
	
КонецПроцедуры

Процедура УсловияПриАктивизацииСтроки(Элемент)
	
	СохранитьВыражениеУсловия();
	мТекущаяСтрокаУсловия = Элемент.ТекущаяСтрока;
	Если мТекущаяСтрокаУсловия <> Неопределено Тогда
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст(мТекущаяСтрокаУсловия.Представление);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	//Если Не ОтменаРедактирования Тогда
	//	Элемент.ТекущиеДанные.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение, Элемент.ТекущиеДанные,,, ПолучитьСловоЯзыкаЗапросов("Table"));
	//	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(Элемент.ТекущиеДанные);
	//КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	Если Не ОтменаРедактирования Тогда
		Элемент.ТекущиеДанные.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение, Элемент.ТекущиеДанные,,,
			ПолучитьСловоЯзыкаЗапросов("Field"));
	КонецЕсли; 

КонецПроцедуры

Процедура ПодстрокаФильтраДоступныхТаблицОчистка(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	Элемент.Значение = "";
	
КонецПроцедуры

Процедура ПодстрокаФильтраДоступныхТаблицПриИзменении(Элемент)
	
	ирОбщий.ПолеВводаСИсториейВыбора_ПриИзмененииЛкс(Элемент, Метаданные().Имя);
	ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Имя.ВидСравнения = ВидСравнения.Содержит;
	ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Имя.Использование = Истина;

КонецПроцедуры

Процедура ПодстрокаФильтраДоступныхТаблицНачалоВыбораИзСписка(Элемент, СтандартнаяОбработка)
	
	ирОбщий.ПолеВводаСИсториейВыбора_НачалоВыбораИзСпискаЛкс(Элемент, Метаданные().Имя);

КонецПроцедуры

Процедура ДоступныеТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступнуюТаблицуВВыбранные(ВыбраннаяСтрока);
	
КонецПроцедуры

Процедура ДоступныеПоляВыбораВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(ВыбраннаяСтрока);
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Если Не ПараметрыДиалектаSQL.МногоТаблиц Тогда
		Отказ = Истина;
		Возврат;
	КонецЕсли; 
	Если Не Копирование Тогда
		Отказ = Истина;
		ВложенныйПакет = ОткрытьВложенныйПакет();
		Если ВложенныйПакет <> Неопределено Тогда
			ИмяТаблицы = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, "ВложенныйЗапрос",,, "ВложенныйПакет");
			ВыбраннаяТаблица = ДобавитьВыбраннуюТаблицу();
			ВыбраннаяТаблица.ВложенныйПакет = ВложенныйПакет;
			ВыбраннаяТаблица.Имя = ИмяТаблицы;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВыбраннаяТаблица);
			Элемент.ТекущаяСтрока = ВыбраннаяТаблица;
		КонецЕсли;
	Иначе
		Если Элемент.ТекущаяСтрока.ВложенныйПакет <> Неопределено Тогда
			Отказ = Истина;
			ВложенныйПакет = СкопироватьВложенныйПакетДляРедактирования(Элемент.ТекущаяСтрока.ВложенныйПакет);
			ВложенныйПакет = ОткрытьВложенныйПакет(ВложенныйПакет);
			Если ВложенныйПакет <> Неопределено Тогда
				ВыбраннаяТаблица = ДобавитьВыбраннуюТаблицу();
				ЗаполнитьЗначенияСвойств(ВыбраннаяТаблица, Элемент.ТекущаяСтрока, , "ВложенныйПакет"); 
				ВыбраннаяТаблица.ВложенныйПакет = ВложенныйПакет;
				ВыбраннаяТаблица.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, ВыбраннаяТаблица);
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВыбраннаяТаблица);
				Элемент.ТекущаяСтрока = ВыбраннаяТаблица;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПриАктивизацииСтроки(Элемент)
	
	СохранитьВыбранноеПоле();
	ЗагрузитьВыбранноеПоле();

КонецПроцедуры

Процедура ЗагрузитьВыбранноеПоле()

	мТекущаяСтрокаВыбранногоПоля = ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока;
	Если мТекущаяСтрокаВыбранногоПоля <> Неопределено Тогда
		ВыражениеПоля = мТекущаяСтрокаВыбранногоПоля.Определение;
		РазрешеноИзменение = Не мТекущаяСтрокаВыбранногоПоля.Автополе;
	Иначе
		ВыражениеПоля = "";
		РазрешеноИзменение = Ложь;
	КонецЕсли; 
	ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(ВыражениеПоля);
	ЭлементыФормы.ВыражениеВыбранногоПоля.Доступность = РазрешеноИзменение;

КонецПроцедуры

Процедура ВыбранныеПоляПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ОформлениеСтроки.Ячейки.Группировка.ОтображатьФлажок = Истина;
	СтрокаГруппировки = Группировки.Найти(ДанныеСтроки.Определение, "Определение");
	Если СтрокаГруппировки <> Неопределено Тогда
		ОформлениеСтроки.Ячейки.Группировка.Флажок = Истина;
		ОформлениеСтроки.Ячейки.Группировка.ТолькоПросмотр = Ложь
			Или ДанныеСтроки.ЕстьАгрегаты
			Или ДанныеСтроки.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"));
	КонецЕсли;
	Если ДанныеСтроки.Автополе Тогда
		ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаВычисляемогоЗначения");
	КонецЕсли; 
	ОформлениеСтроки.Ячейки.АгрегатнаяФункция.ТолькоПросмотр = Ложь
		Или ДанныеСтроки.Токен = Неопределено 
		Или ДанныеСтроки.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
		Или (Истина
			И ДанныеСтроки.ЕстьАгрегаты
			И ДанныеСтроки.АгрегатнаяФункция = Неопределено);
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Функция ПолучитьИндексКартинкиВыражения(ВыражениеИлиТокен, ЧастьОбъединения = Неопределено)
	
	ТипЗначения = ПолучитьТипЗначенияВыражения(ВыражениеИлиТокен, ЧастьОбъединения);
	ИндексКартинки = ирОбщий.ПолучитьИндексКартинкиТипаЛкс(ТипЗначения);
	Возврат ИндексКартинки;
	
КонецФункции

Функция ПолучитьТипЗначенияВыражения(ВыражениеИлиТокен, ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если ТипЗнч(ВыражениеИлиТокен) = Тип("Строка") Тогда
		Токен = РазобратьВыражениеЗапроса(ВыражениеИлиТокен);
	Иначе
		Токен = ВыражениеИлиТокен;
	КонецЕсли; 
	Если ТипЗнч(Токен) = Тип("COMОбъект") Тогда
		Если Токен.Kind = 0 Тогда
			ДанныеТокена = Токен.Data;
			ИмяПравила = ДанныеТокена.ParentRule.RuleNonterminal.Text;
			Если ИмяПравила = "<Field>" Тогда
				//ПолноеИмяПоля = ПолучитьТекстИзТокена(Токен);
				ПолноеИмяПоля = СобратьВыражениеЗапроса(Токен,,, ЧастьОбъединения);;
				//ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ПолноеИмяПоля);
				//ДоступноеПоле = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.НайтиПоле(ПолеКомпоновки); // Так очень долго работает особенно для дочерних полей от многотипных полей
				Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмяПоля);
				Если Фрагменты.Количество() = 2 Тогда // Это приемлемая плата за вспомогательную информацию, которой являются типы значений полей
													  // Если убрать это ограничение, то здесь будут большие задержки
					ДоступноеПолеТаблицы = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы.Найти(Фрагменты[0]);
					Если ДоступноеПолеТаблицы <> Неопределено Тогда
						ДоступноеПоле = ДоступноеПолеТаблицы.Элементы.Найти(ПолноеИмяПоля);
						Если ДоступноеПоле <> Неопределено Тогда
							Результат = ДоступноеПоле.ТипЗначения;
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
			ИначеЕсли ИмяПравила = "<Parameter>" Тогда
				//ИмяПараметра = ДанныеТокена.Tokens(1).Data.Tokens(0).Data;
				//ПолеКомпоновки = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Результат);
				//ДоступноеПоле = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.НайтиПоле(ПолноеИмяПоля);
				//Если ДоступноеПоле <> Неопределено Тогда
				//	Результат = ДоступноеПоле.ТипЗначение;
				//КонецЕсли; 
			ИначеЕсли Ложь
				Или ИмяПравила = "<Datetime>"
				Или ИмяПравила = "<DateDiff>"
				Или ИмяПравила = "<DateAdd>"
				Или ИмяПравила = "<BeginOfPeriod>"
				Или ИмяПравила = "<EndOfPeriod>"
			Тогда
				Результат = Новый ОписаниеТипов("Дата");
			ИначеЕсли Ложь
				Или ИмяПравила = "<Substring>"
			Тогда
				Результат = Новый ОписаниеТипов("Строка");
			ИначеЕсли Ложь
				Или ИмяПравила = "<Count>"
			Тогда
				Результат = Новый ОписаниеТипов("Число");
			ИначеЕсли ИмяПравила = "<Cast>" Тогда
				Результат = ПолучитьТипФункцииCast(ДанныеТокена.Tokens(4), ЧастьОбъединения);
			ИначеЕсли Ложь
				Или ИмяПравила = "<Type>"
				Или ИмяПравила = "<ValueType>"
			Тогда
				Результат = Новый ОписаниеТипов("Тип");
			ИначеЕсли ИмяПравила = "<Meaning>" Тогда
				ПолноеИмяПредопределенного = СобратьВыражениеЗапроса(ДанныеТокена.Tokens(2));
				Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмяПредопределенного);
				Фрагменты.Удалить(Фрагменты.ВГраница());
				ИмяСсылочногоТипа = ирОбщий.ПолучитьСтрокуСРазделителемИзМассиваЛкс(Фрагменты, ".");
				ИмяСсылочногоТипа = СтрЗаменить(ИмяСсылочногоТипа, ".", "Ссылка.");
				Попытка
					Результат = Новый ОписаниеТипов(ИмяСсылочногоТипа);
				Исключение
				КонецПопытки; 
			// Далее идут правила, допускающие напрямую вложнные правила
			ИначеЕсли ДанныеТокена.TokenCount = 1 Тогда
				Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(0), ЧастьОбъединения);
			ИначеЕсли Ложь
				Или ИмяПравила = "<AddExpr>" 
			Тогда
				Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(0), ЧастьОбъединения);
			ИначеЕсли Ложь
				Или ИмяПравила = "<MultExpr>" 
			Тогда
				Результат = Новый ОписаниеТипов("Число");
			ИначеЕсли Ложь
				Или ИмяПравила = "<NotExpr>" 
				Или ИмяПравила = "<AndExpr>" 
				Или ИмяПравила = "<OrExpr>" 
				Или ИмяПравила = "<CheckNULL>" 
				Или ИмяПравила = "<CheckNotNULL>" 
				Или ИмяПравила = "<CheckLIKE>" 
				Или ИмяПравила = "<CheckValueIn>" 
				Или ИмяПравила = "<CheckExpr>" 
			Тогда
				Результат = Новый ОписаниеТипов("Булево");
			ИначеЕсли ИмяПравила = "<Brackets>" Тогда
				Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(1), ЧастьОбъединения);
			ИначеЕсли ИмяПравила = "<Agregate>" Тогда
				лИмяТокена = ДанныеТокена.Tokens(0).Name;
				Если Ложь
					Или лИмяТокена = "MAX"
					Или лИмяТокена = "MIN"
				Тогда
					Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(2), ЧастьОбъединения);
				ИначеЕсли Ложь
					Или лИмяТокена = "AVG"
					Или лИмяТокена = "SUM"
				Тогда
					Результат = Новый ОписаниеТипов("Число");
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			ИмяТокена = Токен.Name;
			Если ирОбщий.СтрокиРавныЛкс(ИмяТокена, "numLiteral") Тогда
				Результат = Новый ОписаниеТипов("Число");
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ИмяТокена, "strLiteral") Тогда
				Результат = Новый ОписаниеТипов("Строка");
			ИначеЕсли Ложь
				Или ирОбщий.СтрокиРавныЛкс(ИмяТокена, "TRUE")
				Или ирОбщий.СтрокиРавныЛкс(ИмяТокена, "FALSE")
			Тогда
				Результат = Новый ОписаниеТипов("Булево");
			Иначе
				Результат = Новый ОписаниеТипов();
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	Если Результат = Неопределено Тогда
		Результат = Новый ОписаниеТипов();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ПолучитьТипФункцииCast(ТокенТипа, ЧастьОбъединения)

	ПервыйТокен = ТокенТипа.Data.Tokens(0);
	Если Истина
		И ПервыйТокен.Kind = 1
		И ПервыйТокен.Data = "(" 
	Тогда
		Результат = ПолучитьТипФункцииCast(ТокенТипа.Data.Tokens(1), ЧастьОбъединения);
	ИначеЕсли ПервыйТокен.Kind = 1 Тогда
		Результат = Новый ОписаниеТипов(ПервыйТокен.Data);
	Иначе
		ИмяПравилаТипа = ПервыйТокен.Data.ParentRule.RuleNonterminal.Text;
		Если ИмяПравилаТипа = "<NumericType>" Тогда
			Результат = Новый ОписаниеТипов("Число");
		ИначеЕсли ИмяПравилаТипа = "<StringType>" Тогда
			Результат = Новый ОписаниеТипов("Строка");
		ИначеЕсли ИмяПравилаТипа = "<TableName>" Тогда
			ИмяСсылочногоТипа = СобратьВыражениеЗапроса(ПервыйТокен);
			ИмяСсылочногоТипа = СтрЗаменить(ИмяСсылочногоТипа, ".", "Ссылка.");
			Попытка
				Результат = Новый ОписаниеТипов(ИмяСсылочногоТипа);
			Исключение
			КонецПопытки; 
		ИначеЕсли ИмяПравилаТипа = "<Brackets>" Тогда
		ИначеЕсли ИмяПравилаТипа = "<BinaryType>" Тогда
		Иначе
			ВызватьИсключение "Неизвестный тип " + ИмяПравилаТипа + " в функции CAST";
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(Токен, ЗапросПакета, ЧастьОбъединения)
	
	//Результат = СобратьВыражениеЗапроса(ДанныеТокена);
	ДанныеТокена = Токен.Data;
	Если Токен.Kind = 0 Тогда
		ИмяПравила = ДанныеТокена.ParentRule.RuleNonterminal.Text;
		Если ИмяПравила = "<Field>" Тогда
			//Результат = ПолучитьТекстИзТокена(Токен);
			Результат = СобратьВыражениеЗапроса(Токен,,, ЧастьОбъединения);
			Если Найти(Результат, "(") > 0 Тогда
				Возврат Неопределено;
			КонецЕсли; 
			Результат = ПолучитьПолноеИмяПоляВВыражении(Результат, ЗапросПакета, ЧастьОбъединения);
			Результат = Новый ПолеКомпоновкиДанных(Результат);
			Возврат Результат;
		ИначеЕсли ИмяПравила = "<Parameter>" Тогда
			//Результат = ДанныеТокена.Tokens(1).Data.Tokens(0).Data;
			Результат = Сред(ДанныеТокена.Tokens(0).Data, 2);
			ПроверитьДобавитьПараметр(Результат);
			Результат = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Результат);
			Возврат Результат;
		ИначеЕсли ИмяПравила = "<Datetime>" Тогда
			Год = ДанныеТокена.Tokens(2).Data;
			Месяц = ДанныеТокена.Tokens(4).Data;
			День = ДанныеТокена.Tokens(6).Data;
			Если ДанныеТокена.TokenCount > 8 Тогда
				Час = ДанныеТокена.Tokens(8).Data;
				Минута = ДанныеТокена.Tokens(10).Data;
				Секунда = ДанныеТокена.Tokens(12).Data;
			Иначе
				Час = 0;
				Минута = 0;
				Секунда = 0;
			КонецЕсли; 
			Результат = Дата(Год, Месяц, День, Час, Минута, Секунда);
			Возврат Результат;
		КонецЕсли; 
	Иначе
		ИмяТокена = Токен.Name;
		Если ирОбщий.СтрокиРавныЛкс(ИмяТокена, "numLiteral") Тогда
			Результат = Вычислить(ДанныеТокена);
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(ИмяТокена, "strLiteral") Тогда
			Результат = Токен.Data;
			Результат = Сред(Результат, 2, СтрДлина(Результат) - 2);
			Результат = СтрЗаменить(Результат, """""", """");
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(ИмяТокена, "TRUE") Тогда
			Результат = Истина;
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(ИмяТокена, "FALSE") Тогда
			Результат = Ложь;
		КонецЕсли; 
		Возврат Результат;
	КонецЕсли; 
	Если ДанныеТокена.TokenCount = 1 Тогда
		Результат = ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(ДанныеТокена.Tokens(0), ЗапросПакета, ЧастьОбъединения);
	Иначе
		Результат = Неопределено;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ВыбранныеПоляПриИзмененииФлажка(Элемент, Колонка)
	
	Если ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка = Колонка Тогда
		СтрокаГруппировки = Группировки.Найти(ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока.Определение, "Определение");
		Если СтрокаГруппировки <> Неопределено Тогда
			Группировки.Удалить(СтрокаГруппировки);
		Иначе
			СтрокаГруппировки = Группировки.Добавить();
			СтрокаГруппировки.Определение = ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока.Определение;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПараметрыПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	Если Не ОтменаРедактирования Тогда
		НовоеИмяПараметра = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение, Элемент.ТекущиеДанные,,, ПолучитьСловоЯзыкаЗапросов("Parameter"));
		Элемент.ТекущиеДанные.Имя = НовоеИмяПараметра;
		Элемент.ТекущиеДанные.НИмя = НРег(НовоеИмяПараметра);
		Если мИмяТекущегоПараметра <> НовоеИмяПараметра Тогда
			ПереименоватьТаблицуИлиПараметр(, мПараметрыДиалектаSQL.ПрефиксПараметра + мИмяТекущегоПараметра, мПараметрыДиалектаSQL.ПрефиксПараметра + НовоеИмяПараметра);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДоступныеВыбранныеПоляПорядкаВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	//СтрокаПорядка = ПоляПорядка.Найти(ВыбраннаяСтрока.Имя, "Определение");
	//Если СтрокаПорядка = Неопределено Тогда
	//	СтрокаПорядка = ПоляПорядка.Добавить();
	//	СтрокаПорядка.Определение = ВыбраннаяСтрока.Имя;
	//	ОбновитьВыражениеЗапроса(СтрокаПорядка,,,,,,,, Ложь);
	//КонецЕсли; 
	//ЭлементыФормы.ПоляПорядка.ТекущаяСтрока = СтрокаПорядка;
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляПорядка);
	
КонецПроцедуры

Процедура ДоступныеПоляПорядкаВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	//ПолноеИмяПоля = ПолучитьПолноеИмяДоступногоПоля(ВыбраннаяСтрока);
	//Если ПолноеИмяПоля = Неопределено Тогда
	//	Возврат;
	//КонецЕсли; 
	//СтрокаПорядка = ПоляПорядка.Найти(ПолноеИмяПоля, "Определение");
	//Если СтрокаПорядка = Неопределено Тогда
	//	СтрокаПорядка = ПоляПорядка.Добавить();
	//	СтрокаПорядка.Определение = ПолноеИмяПоля;
	//	ОбновитьВыражениеЗапроса(СтрокаПорядка,,,,,,,, Ложь);
	//КонецЕсли; 
	//ЭлементыФормы.ПоляПорядка.ТекущаяСтрока = СтрокаПорядка;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляПорядка);
	
КонецПроцедуры

Процедура ПорядокВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Колонка = ЭлементыФормы.ПоляПорядка.Колонки.Направление Тогда
		Если ВыбраннаяСтрока.Направление = НаправлениеСортировки.Убыв Тогда
			ВыбраннаяСтрока.Направление = НаправлениеСортировки.Возр;
		Иначе
			ВыбраннаяСтрока.Направление = НаправлениеСортировки.Убыв;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Функция ЭтоПолеПараметра(Поле) 
	
	НрегПервыйФрагмент = ирОбщий.ПолучитьПервыйФрагментЛкс(НРег(Поле));
	Результат = Ложь
		Или НрегПервыйФрагмент = НРег("ПараметрыДанных")
		Или НрегПервыйФрагмент = НРег("DataParameters")
		;
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПолноеИмяДоступногоПоля(ДоступноеПоле)
	
	Если ЭтоПолеПараметра(ДоступноеПоле.Поле) Тогда
		Результат = ПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПолучитьПоследнийФрагментЛкс(ДоступноеПоле.Поле);
	Иначе
		Результат = "" + ДоступноеПоле.Поле;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура УсловияПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если НоваяСтрока Тогда
		Элемент.ТекущиеДанные.Сравнение = "=";
		Элемент.ТекущиеДанные.ЛевоеВыражение = 1;
		Элемент.ТекущиеДанные.ПравоеВыражение = 1;
		//СвязиТаблицПриАктивизацииСтроки();
	КонецЕсли; 

КонецПроцедуры

Процедура ПередЗакрытием(Отказ, СтандартнаяОбработка)
	
	Если Модифицированность Тогда
		Ответ = Вопрос("Хотите сохранить изменения?", РежимДиалогаВопрос.ДаНетОтмена);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			ОсновныеДействияФормыОК();
		ИначеЕсли Ответ = КодВозвратаДиалога.Отмена Тогда
			Отказ = Истина;
		КонецЕсли;
	КонецЕсли; 
	Если Не Отказ Тогда
		ИзменитьСвернутостьПанельЧастей(Истина);
		ИзменитьСвернутостьПанельПакета(Истина);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ИзменитьСвернутостьПанельПакета(Видимость)
	
	ирОбщий.ИзменитьСвернутостьЛкс(Видимость, ЭлементыФормы.ПанельПакета, ЭлементыФормы.вРазделительПанельПакета, Панель, "лево");
	
КонецПроцедуры

Процедура ИзменитьСвернутостьПанельЧастей(Видимость)
	
	ирОбщий.ИзменитьСвернутостьЛкс(Видимость, ЭлементыФормы.ПанельЧастей, ЭлементыФормы.вРазделительПанельЧастей, ЭлементыФормы.ПанельОсновная, "лево");
	
КонецПроцедуры

Процедура ДоступныеТаблицыПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрока = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	ПоляДоступнойТаблицы.Очистить();
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ПолучитьПоляДоступнойТаблицы(ТекущаяСтрока), ПоляДоступнойТаблицы);
	ПоляДоступнойТаблицы.Сортировать("Имя");
	
КонецПроцедуры

Процедура ОткрытьОтладчик(Кнопка)
	
	ВызватьИсключение ирОбщий.ПолучитьПриглашениеОткрытьОтладчикЛкс();
	
КонецПроцедуры

Процедура ДеревоУсловияПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ДанныеСтроки <> Элемент.Значение Тогда
		ЭтоПроизвольноеУсловие = ДанныеСтроки.Представление <> "";
		ОформлениеСтроки.Ячейки.Произвольное.ОтображатьФлажок = Не ЭтоПроизвольноеУсловие И ТипЗнч(ДанныеСтроки) = Тип("ЭлементОтбораКомпоновкиДанных");
		ОформлениеСтроки.Ячейки.Произвольное.Флажок = ЭтоПроизвольноеУсловие;
		Если ЭтоПроизвольноеУсловие Тогда
			ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДеревоУсловияПриИзмененииФлажка(Элемент, Колонка)
	
	Если Элемент.Колонки.Произвольное = Колонка Тогда
		ПереключитьРежимПроизвольногоВыраженияОтбора(Элемент, Колонка);
		ЗагрузитьВыражениеУсловия();
	КонецЕсли; 

КонецПроцедуры

Процедура ПриПолученииДанныхДоступныхПолей(Элемент, ОформленияСтрок)

	ирОбщий.ПриПолученииДанныхДоступныхПолейКомпоновкиЛкс(ОформленияСтрок);

КонецПроцедуры // ПриПолученииДанныхДоступныхПолей()

Процедура УсловияПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		ОбновитьЭлементОтбораПослеИзменения(Элемент);
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст(мТекущаяСтрокаУсловия.Представление);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		Если НоваяСтрока Тогда
			мТекущаяСтрокаВыбранногоПоля.ИД = Новый УникальныйИдентификатор();
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОчиститьДанные() Экспорт
	
	ЗапросыПакета.Очистить();
	ЧастиОбъединения.Очистить();
	ВыбранныеПоля.Очистить();
	ПоляПорядка.Очистить();
	Группировки.Очистить();
	СвязиТаблиц.Строки.Очистить();
	Параметры.Очистить();
	ЭтаФорма.ОпцияПервые = Неопределено;
	ЭтаФорма.ОпцияРазличные = Неопределено;
	ЭтаФорма.ОпцияАвтоупорядочивание = Неопределено;
	ЭтаФорма.ОпцияРазрешенные = Неопределено;
	ЭтаФорма.РежимОбъединения = Ложь;
	ЭтаФорма.ЛиПакетныйЗапрос = Ложь;
	ЭтаФорма.ТипЗапроса = 0;
	КомпоновщикЧасти.Настройки.Отбор.Элементы.Очистить();
	
КонецПроцедуры

Процедура ПереключитьРежимРедактированияТекста()
	
	ЭтаФорма.мРежимРедактированияТекста = Не мРежимРедактированияТекста;
	ЭлементыФормы.ПолеТекстаОтображаетПакет.Доступность = Не мРежимРедактированияТекста;
	ЭлементыФормы.КПТекст.Кнопки.Редактировать.Пометка = мРежимРедактированияТекста;
	ЭлементыФормы.КПТекст.Кнопки.ОтменитьРедактирование.Доступность = мРежимРедактированияТекста;
	ЭлементыФормы.ПолеТекстаЗапроса.ТолькоПросмотр = Не мРежимРедактированияТекста;
	Для Каждого Страница Из ЭлементыФормы.ПанельОсновная.Страницы Цикл
		Если ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> Страница Тогда
			Страница.Доступность = Не мРежимРедактированияТекста;
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры

Процедура КПТекстРедактировать(Кнопка)

	Если мРежимРедактированияТекста Тогда
		Компонента = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ЭлементыФормы.ПолеТекстаЗапроса.Имя];
		Если Компонента.ЗагрузитьТекстВКонструктор(, ЭтаФорма) = Истина Тогда
			ПереключитьРежимРедактированияТекста();
		КонецЕсли; 
	Иначе
		ПереключитьРежимРедактированияТекста();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДиалектSQLОчистка(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ЭтаФорма.ДиалектSQL = мДиалектSQL;
	
КонецПроцедуры

Процедура ОбновитьВсеВыраженияСИндикацией()
	
	Состояние("Обновление выражений...");
	ОбновитьВсеВыраженияПакета();
	Состояние("");
	
КонецПроцедуры

// Параметры:
//   РежимОбновленияВыражений - Число
//		1 - пересобрать
//		2 - очистить токен
Функция ОбновитьВсеВыраженияПакета(Пакет = Неопределено, РежимОбновленияВыражений = 1)

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
	КонецЕсли;
	Для Каждого ЗапросПакета Из Пакет Цикл
		Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
			Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
				Если ВыбраннаяТаблица.ВложенныйПакет <> Неопределено Тогда
					ОбновитьВсеВыраженияПакета(ВыбраннаяТаблица.ВложенныйПакет, РежимОбновленияВыражений);
				КонецЕсли; 
				Для каждого ПараметрТаблицы Из ВыбраннаяТаблица.Параметры Цикл
					Если Не ЗначениеЗаполнено(ПараметрТаблицы.Определение) Тогда
						Продолжить;
					КонецЕсли; 
					ОбновитьВыражениеЗапроса(ПараметрТаблицы, ЭлементыФормы.ПараметрыТаблицы, ЗапросПакета, ЧастьОбъединения,,,,,, РежимОбновленияВыражений);
				КонецЦикла;
			КонецЦикла;
			Для Каждого ВыбранноеПоле Из ЧастьОбъединения.ВыбранныеПоля Цикл
				ОбновитьВыражениеЗапроса(ВыбранноеПоле, ЭлементыФормы.ВыбранныеПоля, ЗапросПакета, ЧастьОбъединения,,,,,, РежимОбновленияВыражений);
			КонецЦикла;
			Для Каждого ПолеГруппировки Из ЧастьОбъединения.Группировки Цикл
				ОбновитьВыражениеЗапроса(ПолеГруппировки, ЭлементыФормы.Группировки, ЗапросПакета, ЧастьОбъединения,,,,,, РежимОбновленияВыражений);
			КонецЦикла;
			Для Каждого СвязьТаблиц Из ирОбщий.ПолучитьВсеСтрокиДереваЗначенийЛкс(ЧастьОбъединения.СвязиТаблиц) Цикл
				Если СвязьТаблиц.Условие <> Неопределено Тогда
					ОбновитьВыраженияОтбора(СвязьТаблиц.Условие.Отбор, ЭлементыФормы.ДеревоУсловияСвязи, ЗапросПакета, ЧастьОбъединения,,, РежимОбновленияВыражений);
				КонецЕсли; 
			КонецЦикла;
			ОбновитьВыраженияОтбора(ЧастьОбъединения.Условие.Отбор, ЭлементыФормы.ДеревоУсловия, ЗапросПакета, ЧастьОбъединения,,, РежимОбновленияВыражений);
		КонецЦикла;
		Для Каждого ПолеПорядка Из ЗапросПакета.ПоляПорядка Цикл
			ОбновитьВыражениеЗапроса(ПолеПорядка, ЭлементыФормы.ПоляПорядка, ЗапросПакета,,,,,,, РежимОбновленияВыражений);
		КонецЦикла;
		Для Каждого ГруппируемоеПолеИтогов Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
			ОбновитьВыражениеЗапроса(ГруппируемоеПолеИтогов, ЭлементыФормы.ГруппируемыеПоляИтогов, ЗапросПакета,,,,,,, РежимОбновленияВыражений);
		КонецЦикла;
		Для Каждого ГруппирующееПолеИтогов Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
			ОбновитьВыражениеЗапроса(ГруппирующееПолеИтогов, ЭлементыФормы.ГруппирующиеПоляИтогов, ЗапросПакета,,,,,,, РежимОбновленияВыражений);
		КонецЦикла;
	КонецЦикла;
	Возврат Неопределено;

КонецФункции

// РежимОбновленияВыражений - Число
//		1 - пересобрать
//		2 - очистить токен
Процедура ОбновитьВыраженияОтбора(ГруппаОтбора, ТабличноеПоле = Неопределено,
	Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено, СтароеИмяТаблицы = "", НовоеИмяТаблицы = "", Знач РежимОбновленияВыражений = 1)
	
	Если РежимОбновленияВыражений < 2 Тогда
		Если ЗначениеЗаполнено(НовоеИмяТаблицы) Тогда
			РежимОбновленияВыражений = 0;
		Иначе
			РежимОбновленияВыражений = 1;
		КонецЕсли; 
	КонецЕсли; 
	Для Каждого ЭлементГруппы Из ГруппаОтбора.Элементы Цикл
		Если ТипЗнч(ЭлементГруппы) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			ОбновитьВыраженияОтбора(ЭлементГруппы, ТабличноеПоле, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, РежимОбновленияВыражений);
		Иначе
			Если ЭлементГруппы.Представление <> "" Тогда
				ОбновитьВыражениеЗапроса(ЭлементГруппы, ТабличноеПоле, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,,,, РежимОбновленияВыражений);
			Иначе
				Если ТипЗнч(ЭлементГруппы.ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
					Если ЭтоПолеПараметра(ЭлементГруппы.ЛевоеЗначение) Тогда
						ВыражениеПараметра = мПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПолучитьПоследнийФрагментЛкс(ЭлементГруппы.ЛевоеЗначение);
						Если ирОбщий.СтрокиРавныЛкс(ВыражениеПараметра, СтароеИмяТаблицы) Тогда
							ЭлементГруппы.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Сред(НовоеИмяТаблицы, 2));
						КонецЕсли; 
					Иначе
						ЭлементГруппы.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(
							ПолучитьПолноеИмяПоляВВыражении("" + ЭлементГруппы.ЛевоеЗначение, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы));
					КонецЕсли; 
				КонецЕсли; 
				Если ТипЗнч(ЭлементГруппы.ПравоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
					Если ЭтоПолеПараметра(ЭлементГруппы.ПравоеЗначение) Тогда
						ВыражениеПараметра = мПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПолучитьПоследнийФрагментЛкс(ЭлементГруппы.ПравоеЗначение);
						Если ирОбщий.СтрокиРавныЛкс(ВыражениеПараметра, СтароеИмяТаблицы) Тогда
							ЭлементГруппы.ПравоеЗначение = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Сред(НовоеИмяТаблицы, 2));
						КонецЕсли; 
					Иначе
						ЭлементГруппы.ПравоеЗначение = Новый ПолеКомпоновкиДанных(
							ПолучитьПолноеИмяПоляВВыражении("" + ЭлементГруппы.ПравоеЗначение, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы));
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьИмяВыбраннойТаблицы(СтрокаВыбраннойТаблицы = Неопределено)

	Если СтрокаВыбраннойТаблицы  = Неопределено Тогда
		СтрокаВыбраннойТаблицы = мТекущаяСтрокаВыбранныеТаблицы;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.Имя) Тогда
		СтрокаВыбраннойТаблицы.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(СтрокаВыбраннойТаблицы.Владелец(), СтрокаВыбраннойТаблицы.ПолноеИмя);
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбраннойТаблицы);
	КонецЕсли;
	Результат = СтрокаВыбраннойТаблицы.Имя;
	Возврат Результат;

КонецФункции

Функция ПолучитьТекстОператораТокена(Данные, НачальныйИндекс, КонечныйИндекс)

	ТекстОператора = "";
	Для Индекс = НачальныйИндекс По КонечныйИндекс Цикл
		Если ТекстОператора <> "" Тогда
			ТекстОператора = ТекстОператора + " " + ТекстОператора;
		КонецЕсли; 
		ИмяТерминала = Данные.Tokens(Индекс).ParentRule.RuleNonterminal.Name;
		ТекстОператора = ТекстОператора + " " + ПолучитьСловоЯзыкаЗапросов(ИмяТерминала);
	КонецЦикла;

	Возврат Неопределено;

КонецФункции

// РежимОбновленияВыражения - Число
//      0 - собрать из готового токена
//		1 - сформировать токен заново и собрать из него 
//		2 - очистить токен
Функция ОбновитьВыражениеЗапроса(СтрокаТаблицыВыражений, ТабличноеПоле = Неопределено, Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено,
	СтароеИмяТаблицы = "", НовоеИмяТаблицы = "", РазрешитьПустое = Ложь, выхЕстьАгрегаты = Истина, РазрешитьНормализациюИмен = Истина, РежимОбновленияВыражений = 1)

	НачальныйТокенВыражения = Неопределено;
	Если ТипЗнч(СтрокаТаблицыВыражений) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ВыражениеЗапроса = СтрокаТаблицыВыражений.Представление;
		Если РежимОбновленияВыражений = 0 Тогда
			НачальныйТокенВыражения = СтрокаТаблицыВыражений.ПравоеЗначение;
		КонецЕсли; 
	Иначе
		ВыражениеЗапроса = СтрокаТаблицыВыражений.Определение;
		Если РежимОбновленияВыражений = 0 Тогда
			НачальныйТокенВыражения = СтрокаТаблицыВыражений.Токен;
		КонецЕсли; 
	КонецЕсли;
	Если РежимОбновленияВыражений = 2 Тогда
		Результат = ВыражениеЗапроса;
	ИначеЕсли Ложь
		Или (Истина
			И РазрешитьПустое 
			И ПустаяСтрока(ВыражениеЗапроса))
		Или (Истина
			И Не ЗначениеЗаполнено(НовоеИмяТаблицы)
			И ЛиВыражениеЯвляетсяПолем(ВыражениеЗапроса))
	Тогда
		Результат = ВыражениеЗапроса;
		НачальныйТокенВыражения = ВыражениеЗапроса;
	Иначе
		Если ЗапросПакета = Неопределено Тогда
			ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
		КонецЕсли; 
		Если ЧастьОбъединения = Неопределено Тогда
			ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
		КонецЕсли; 
		НужноПересобратьТокены = Неопределено;
		Попытка
			Если ТипЗнч(НачальныйТокенВыражения) <> Тип("COMОбъект") Тогда
				НачальныйТокенВыражения = РазобратьВыражениеЗапроса(ВыражениеЗапроса);
			КонецЕсли; 
			Результат = СобратьВыражениеЗапроса(НачальныйТокенВыражения, , ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты, РазрешитьНормализациюИмен,
				НужноПересобратьТокены);
		Исключение
			Если ТабличноеПоле <> Неопределено Тогда
				ЭтаФорма.ТекущийЭлемент = ТабличноеПоле;
				ТабличноеПоле.ТекущаяСтрока = СтрокаТаблицыВыражений;
				ВызватьИсключение;
			КонецЕсли;
			Возврат Неопределено;
		КонецПопытки; 
		Если НужноПересобратьТокены Тогда
			//НачальныйТокенВыражения = Неопределено;
			НачальныйТокенВыражения = РазобратьВыражениеЗапроса(Результат);
		КонецЕсли; 
	КонецЕсли; 
	Если ТипЗнч(СтрокаТаблицыВыражений) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтрокаТаблицыВыражений.Представление = Результат;
		СтрокаТаблицыВыражений.ПравоеЗначение = НачальныйТокенВыражения;
	Иначе
		СтрокаТаблицыВыражений.Определение = Результат;
		СтрокаТаблицыВыражений.Токен = НачальныйТокенВыражения;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ДиалектSQLПриИзменении(Элемент = Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	УстановитьДиалектSQL();
	ОбновитьВсеВыраженияСИндикацией();
	Если ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Текст Тогда
		ПересобратьВременныйПолныйТекст();
	ИначеЕсли Истина
		И ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения 
		И ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Текст
	Тогда
		ПересобратьВременныйТекстЧасти();
	КонецЕсли; 
	
КонецПроцедуры

Процедура УстановитьДиалектSQL(НовыйДиалектSQL = Неопределено) Экспорт
	
	Если НовыйДиалектSQL <> Неопределено Тогда
		ЭтаФорма.ДиалектSQL = НовыйДиалектSQL;
	КонецЕсли; 
	Если ДиалектSQL = Неопределено Тогда
		//ДиалектSQL = "MSSQL";
		ВызватьИсключение "Не указан диалект SQL";
	КонецЕсли; 
	ПараметрыДиалектаSQL = мДиалектыSQL.Найти(ДиалектSQL, "Диалект");
	Если ПараметрыДиалектаSQL = Неопределено Тогда
		ПараметрыДиалектаSQL = мДиалектыSQL
	КонецЕсли; 
	Если НЕ ПараметрыДиалектаSQL.ВременныеТаблицы Тогда
		ЭтаФорма.ТипЗапроса = 0;
	КонецЕсли; 
	ЭлементыФормы.ПанельОсновная.Страницы.Итоги.Видимость = ПараметрыДиалектаSQL.Это1С;
	ЭлементыФормы.ПанельОсновная.Страницы.Параметры.Видимость = ПараметрыДиалектаSQL.Параметры;
	ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения.Видимость = ПараметрыДиалектаSQL.Объединения;
	ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц.Видимость = ПараметрыДиалектаSQL.МногоТаблиц;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Имя.Видимость = ПараметрыДиалектаSQL.МногоТаблиц;
	ЭлементыФормы.ПанельЧасти.Страницы.Группировки.Видимость = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.АгрегатнаяФункция.Видимость = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.АгрегатнаяФункция.ИзменятьНастройку = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка.Видимость = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка.ИзменятьНастройку = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ТипЗапроса.Доступность = ПараметрыДиалектаSQL.ВременныеТаблицы;
	РазрешеныКомментриии = ЗначениеЗаполнено(ПараметрыДиалектаSQL.СтрочныйКомментарий);
	ЭлементыФормы.ПанельЧасти.Страницы.КомментарийЧасти.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ВыбранныеТаблицы.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.Группировки.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ПоляИндекса.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ГруппируемыеПоляИтогов.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ГруппирующиеПоляИтогов.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ОпцияАвтоупорядочивание.Доступность = ПараметрыДиалектаSQL.Это1С;
	ЭлементыФормы.Английский1С.Доступность = ПараметрыДиалектаSQL.Это1С;
	
	АгрегатныеФункции = Новый СписокЗначений();
	АгрегатныеФункции.Добавить("SUM(", ПолучитьСловоЯзыкаЗапросов("SUM"));
	АгрегатныеФункции.Добавить("MAX(", ПолучитьСловоЯзыкаЗапросов("MAX"));
	АгрегатныеФункции.Добавить("MIN(", ПолучитьСловоЯзыкаЗапросов("MIN"));
	АгрегатныеФункции.Добавить("AVG(", ПолучитьСловоЯзыкаЗапросов("AVG"));
	АгрегатныеФункции.Добавить("COUNT(", ПолучитьСловоЯзыкаЗапросов("COUNT"));
	АгрегатныеФункции.Добавить("COUNT(DISTINCT ", ПолучитьСловоЯзыкаЗапросов("COUNT") + " " + ПолучитьСловоЯзыкаЗапросов("DISTINCT"));
	ПоляВвводаАгрегатныхФункций = Новый Массив();
	ПоляВвводаАгрегатныхФункций.Добавить(ЭлементыФормы.ВыбранныеПоля.Колонки.АгрегатнаяФункция.ЭлементУправления);
	ПоляВвводаАгрегатныхФункций.Добавить(ЭлементыФормы.ГруппируемыеПоляИтогов.Колонки.АгрегатнаяФункция.ЭлементУправления);
	Для Каждого ПолеВвводаАгрегатнойФункции Из ПоляВвводаАгрегатныхФункций Цикл
		СписокВыбора = ПолеВвводаАгрегатнойФункции.СписокВыбора;
		СписокВыбора.Очистить();
		Для Каждого АгрегатнаяФункция Из АгрегатныеФункции Цикл
			СписокВыбора.Добавить(АгрегатнаяФункция.Значение, АгрегатнаяФункция.Представление);
		КонецЦикла;
	КонецЦикла;
		
КонецПроцедуры

Процедура ПересобратьВременныйПолныйТекст()
	
	Текст = СобратьПолныйТекст();
	ирОбщий.УстановитьТекстПоляСохраняяПозициюЛкс(ЭлементыФормы.ПолеТекстаЗапроса, Текст);

КонецПроцедуры

Процедура ПанельОсновнаяПриСменеСтраницы(Элемент = Неопределено, ТекущаяСтраница =  Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	Элемент = ЭлементыФормы.ПанельОсновная;
	ТекущаяСтраница = Элемент.Страницы.Индекс(Элемент.ТекущаяСтраница);
	Если ТипЗапроса <> 2 Тогда
		Если Ложь
			Или мСтараяСтраницаПанелиОсновная = ЭлементыФормы.ПанельОсновная.Страницы.Параметры
			Или мСтараяСтраницаПанелиОсновная = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения
		Тогда
			ЗагрузитьДоступныеНастройкиКомпоновки();
		КонецЕсли; 
	КонецЕсли; 
	ПанельОсновнаяОбновитьТекущуюСтраницу();
	ЭтаФорма.мСтараяСтраницаПанелиОсновная = Элемент.Страницы[ТекущаяСтраница];
	
КонецПроцедуры

Процедура ПанельОсновнаяОбновитьТекущуюСтраницу()

	лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.ТекущаяСтраница;
	Если лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Текст Тогда
		ПересобратьВременныйПолныйТекст();
	//ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Итоги Тогда
	//	ЭтаФорма.ДоступныеПоляИтогов = ЧастиОбъединения[0].ВыбранныеПоля;
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения Тогда
		ОбновитьТабличноеПолеПоляОбъединения();
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Построитель Тогда
		ЭтаФорма.ДоступныеВыбранныеПоляЗапроса = ПоляОбъединения.Скопировать();
		ДоступныеВыбранныеПоляЗапроса.Сортировать("Имя");
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьПоляОбъединенияЗапроса(ЗапросПакета = Неопределено)
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли;
	Если ЗапросПакета = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЗапросПакета.ПоляОбъединения.Очистить();
	Пока ЗапросПакета.ПоляОбъединения.Колонки.Количество() > мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей Цикл
		ЗапросПакета.ПоляОбъединения.Колонки.Удалить(мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей);
	КонецЦикла;
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		КолонкаЧастиИД = ЗапросПакета.ПоляОбъединения.Колонки.Добавить("_" + ЧастьОбъединения.Номер);
		КолонкаЧастиОпределение = ЗапросПакета.ПоляОбъединения.Колонки.Добавить("Определение" + ЧастьОбъединения.Номер);
		НачальноеКоличество = ЧастьОбъединения.ВыбранныеПоля.Количество(); 
		Для Счетчик = 1 По НачальноеКоличество Цикл
			ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля[НачальноеКоличество - Счетчик];
			СтрокаПсевдонимаПоля = ЗапросПакета.ПоляОбъединения.Найти(ВыбранноеПоле.Имя, "Имя");
			Если СтрокаПсевдонимаПоля = Неопределено Тогда
				СтрокаПсевдонимаПоля = ЗапросПакета.ПоляОбъединения.Вставить(0);
				СтрокаПсевдонимаПоля.Имя = ВыбранноеПоле.Имя;
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПсевдонимаПоля);
			КонецЕсли; 
			СтрокаПсевдонимаПоля[КолонкаЧастиИД.Имя] = ВыбранноеПоле.ИД;
			СтрокаПсевдонимаПоля[КолонкаЧастиОпределение.Имя] = ВыбранноеПоле.Определение;
			//Если ирОбщий.СтрокиРавныЛкс(ВыбранноеПоле.Определение, "NULL") Тогда
			//	ЧастьОбъединения.ВыбранныеПоля.Удалить(ВыбранноеПоле);
			//КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	//ЗапросПакета.ПоляОбъединения.Сортировать("Имя"); // Лучше это делать вручную
	Для Каждого ПолеОбъединения Из ЗапросПакета.ПоляОбъединения Цикл
		ОбновитьТипЗначенияПоляОбъединения(ЗапросПакета, ПолеОбъединения);
	КонецЦикла;
	ОбновитьРолиИтогов(ЗапросПакета);
	
КонецПроцедуры

Функция ОбновитьТабличноеПолеПоляОбъединения()

	ОбновитьПоляОбъединенияЗапроса();
	Пока ЭлементыФормы.ПоляОбъединения.Колонки.Количество() > мЧислоСтатическихКолонокТППоляПсевдонимовПолей Цикл 
		ЭлементыФормы.ПоляОбъединения.Колонки.Удалить(мЧислоСтатическихКолонокТППоляПсевдонимовПолей);
	КонецЦикла;
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		КолонкаТП = ЭлементыФормы.ПоляОбъединения.Колонки.Добавить("Определение" + ЧастьОбъединения.Номер);
		КолонкаТП.ТекстШапки = ЧастьОбъединения.Имя;
		КолонкаТП.Данные = КолонкаТП.Имя;
		КолонкаТП.КартинкиСтрок = ирОбщий.ПолучитьОбщуюКартинкуЛкс("ирТипыДоступныхПолейКомпоновки");
		КолонкаТП.ТолькоПросмотр = Истина;
	КонецЦикла;

КонецФункции

Процедура СвязиТаблицПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьУсловиеСвязи();
	ЗагрузитьСвязьТаблицы();

КонецПроцедуры

Процедура ЗагрузитьСвязьТаблицы()
	
	Элемент = ЭлементыФормы.СвязиТаблиц;
	мТекущаяСтрокаСвязи = Элемент.ТекущаяСтрока;
	НоваяНастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
	Если Истина
		И мТекущаяСтрокаСвязи <> Неопределено 
		И мТекущаяСтрокаСвязи.Родитель <> Неопределено
	Тогда
		Если мТекущаяСтрокаСвязи.Условие <> Неопределено Тогда
			НоваяНастройкаКомпоновки = мТекущаяСтрокаСвязи.Условие; 
		КонецЕсли; 
	КонецЕсли; 
	КомпоновщикУсловияСвязи.ЗагрузитьНастройки(НоваяНастройкаКомпоновки);
	Если КомпоновщикУсловияСвязи.Настройки.Отбор.Элементы.Количество() > 0 Тогда
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока = КомпоновщикУсловияСвязи.Настройки.Отбор.Элементы[0];
	КонецЕсли; 

КонецПроцедуры

Процедура ДеревоУсловияПриАктивизацииСтроки(Элемент = Неопределено)
		
	СохранитьВыражениеУсловия();
	ЗагрузитьВыражениеУсловия();

КонецПроцедуры

Процедура ЗагрузитьВыражениеУсловия()

	мТекущаяСтрокаУсловия = ЭлементыФормы.ДеревоУсловия.ТекущаяСтрока;
	Если ТипЗнч(мТекущаяСтрокаУсловия) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ЭлементыФормы.ВыражениеЭлементаУсловия.Доступность = мТекущаяСтрокаУсловия.Представление <> "";
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст(мТекущаяСтрокаУсловия.Представление);
	Иначе
		ЭлементыФормы.ВыражениеЭлементаУсловия.Доступность = Ложь;
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст("");
	КонецЕсли; 

КонецПроцедуры

Процедура ДеревоУсловияСвязиПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		ОбновитьЭлементОтбораПослеИзменения(Элемент);
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.УстановитьТекст(мТекущаяСтрокаУсловияСвязи.Представление);
	КонецЕсли; 

КонецПроцедуры

Процедура Английский1СПриИзменении(Элемент)
	
	ДиалектSQLПриИзменении();

КонецПроцедуры

Процедура ОбъединениеПриИзменении(Элемент)
	
	ИзменитьСвернутостьПанельЧастей(РежимОбъединения);
	
КонецПроцедуры

Процедура СохранитьЧастьОбъединения()
	
	Если мТекущаяСтрокаЧастиОбъединения = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ЧастиОбъединения.Индекс(мТекущаяСтрокаЧастиОбъединения) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьВыбраннуюТаблицу();
	СохранитьВыбранноеПоле();
	СохранитьВыражениеУсловия();
	СохранитьУсловиеСвязи();
	//мТекущаяСтрокаЧастиОбъединения.Условие = КомпоновщикЧасти.ПолучитьНастройки();
	мТекущаяСтрокаЧастиОбъединения.ОпцияРазличные = ОпцияРазличные;
	мТекущаяСтрокаЧастиОбъединения.Автогруппировки = Автогруппировки;
	мТекущаяСтрокаЧастиОбъединения.Комментарий = ЭлементыФормы.КомментарийЧасти.ПолучитьТекст();
	мТекущаяСтрокаЧастиОбъединения.КомментарийОтбора = ЭлементыФормы.КомментарийОтбора.ПолучитьТекст();
	ОбновитьНаименованиеЧасти(мТекущаяСтрокаЧастиОбъединения);
	
КонецПроцедуры

Процедура СохранитьЗапросПакета()
	
	Если мТекущаяСтрокаЗапросыПакета = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ЗапросыПакета.Индекс(мТекущаяСтрокаЗапросыПакета) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьЧастьОбъединения();
	//мТекущаяСтрокаЗапросыПакета.ПоляПорядка = ПоляПорядка.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ПоляИндекса = ПоляИндекса.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ГруппирующиеПоляИтогов = ГруппирующиеПоляИтогов.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ЧастиОбъединения = ЧастиОбъединения.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ПоляОбъединения = ПоляОбъединения.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ГруппируемыеПоляИтогов = ГруппируемыеПоляИтогов.Скопировать();
	мТекущаяСтрокаЗапросыПакета.ТипЗапроса = ТипЗапроса;
	Если ТипЗапроса = 2 Тогда
		мТекущаяСтрокаЗапросыПакета.Комментарий = ЭлементыФормы.КомментарийЧасти.ПолучитьТекст();
	Иначе
		мТекущаяСтрокаЗапросыПакета.Комментарий = "";
	КонецЕсли; 
	мТекущаяСтрокаЗапросыПакета.ОпцияОбщиеИтоги = ОпцияОбщиеИтоги;
	мТекущаяСтрокаЗапросыПакета.ОпцияАвтоупорядочивание = ОпцияАвтоупорядочивание;
	мТекущаяСтрокаЗапросыПакета.ОпцияПервые = ОпцияПервые;
	мТекущаяСтрокаЗапросыПакета.ОпцияРазрешенные = ОпцияРазрешенные;
	мТекущаяСтрокаЗапросыПакета.ПервыеКоличество = ПервыеКоличество;
	мТекущаяСтрокаЗапросыПакета.ИмяВременнойТаблицы = ИмяВременнойТаблицы;
	Если Не ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
		мТекущаяСтрокаЗапросыПакета.ИмяВременнойТаблицы = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЗапросыПакета, мТекущаяСтрокаЗапросыПакета, "ИмяВременнойТаблицы");
	КонецЕсли; 
	ОбновитьНаименованиеЗапроса(мТекущаяСтрокаЗапросыПакета);
	
КонецПроцедуры

Процедура ЧастиОбъединенияПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьЧастьОбъединения();
	ЗагрузитьЧастьОбъединения();
	
КонецПроцедуры

Процедура ЗагрузитьЧастьОбъединения()
	
	Элемент = ЭлементыФормы.ЧастиОбъединения;
	мТекущаяСтрокаЧастиОбъединения = Элемент.ТекущаяСтрока;
	мТекущаяСтрокаВыбранногоПоля = Неопределено;
	мТекущаяСтрокаВыбранныеТаблицы = Неопределено;
	мТекущаяСтрокаУсловия = Неопределено;
	мТекущаяСтрокаСвязи = Неопределено;
	мТекущаяСтрокаУсловияСвязи = Неопределено;
	мТекущаяСтрокаПараметраТаблицы = Неопределено;
	мТекущаяСтрокаПараметраТаблицы = Неопределено;
	Если мТекущаяСтрокаЧастиОбъединения <> Неопределено Тогда
		ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст("");
		ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст("");
		ЭлементыФормы.КомментарийЧасти.УстановитьТекст(мТекущаяСтрокаЧастиОбъединения.Комментарий);
		ЭлементыФормы.КомментарийОтбора.УстановитьТекст(мТекущаяСтрокаЧастиОбъединения.КомментарийОтбора);
		//ОбновитьДоступныеВременныеТаблицы();
		ЭтаФорма.ВыбранныеТаблицы = мТекущаяСтрокаЧастиОбъединения.ВыбранныеТаблицы;
		ЭтаФорма.ВыбранныеПоля = мТекущаяСтрокаЧастиОбъединения.ВыбранныеПоля;
		ЭтаФорма.СвязиТаблиц = мТекущаяСтрокаЧастиОбъединения.СвязиТаблиц;
		ЭтаФорма.Группировки = мТекущаяСтрокаЧастиОбъединения.Группировки;
		ЭтаФорма.КомпоновщикЧасти = мТекущаяСтрокаЧастиОбъединения.Компоновщик;
		ЭтаФорма.ПоляВыбораПостроителя = мТекущаяСтрокаЧастиОбъединения.ПоляВыбораПостроителя;
		ЭтаФорма.ПоляОтбораПостроителя = мТекущаяСтрокаЧастиОбъединения.ПоляОтбораПостроителя;
		Если КомпоновщикЧасти.Настройки.Отбор.Элементы.Количество() > 0 Тогда
			ЭлементыФормы.ДеревоУсловия.ТекущаяСтрока = КомпоновщикЧасти.Настройки.Отбор.Элементы[0];
		КонецЕсли; 
		ЗагрузитьДоступныеНастройкиКомпоновки();
		КомпоновщикУсловияСвязи.ЗагрузитьНастройки(Новый НастройкиКомпоновкиДанных);
		ЭтаФорма.ОпцияРазличные = мТекущаяСтрокаЧастиОбъединения.ОпцияРазличные;
		ЭтаФорма.Автогруппировки = мТекущаяСтрокаЧастиОбъединения.Автогруппировки;
		ОбновитьГруппировки();
		ПанельЧастиОбновитьТекущуюСтраницу();
	КонецЕсли; 

КонецПроцедуры

Процедура ЧастиОбъединенияПередУдалением(Элемент, Отказ)
	
	Если Элемент.Значение.Количество() = 1 Тогда
		Отказ = Истина;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЧастиОбъединенияПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	СохранитьЗапросПакета(); // Может уже не надо
	ЧастьОбъединения = ДобавитьЧастьОбъединения(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);
	ЗагрузитьЗапросПакета(); // Может уже не надо
	Элемент.ТекущаяСтрока = ЧастьОбъединения;
	
КонецПроцедуры

Процедура ДоступныеПоляИтоговВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьПолеОбъединенияВГруппирующиеПоля(ВыбраннаяСтрока);

КонецПроцедуры

Процедура ДобавитьПолеОбъединенияВГруппирующиеПоля(ПолеОбъединения)
	
	Если Ложь
		Или ЗначениеЗаполнено(ПолеОбъединения.РольИтога) 
		Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
	Тогда
		Возврат;
	КонецЕсли; 
	ОпределениеПоля = "" + ПолеОбъединения.Имя;
	СтрокаГруппирующегоПоля = ГруппирующиеПоляИтогов.Найти(ОпределениеПоля, "Определение");
	Если СтрокаГруппирующегоПоля = Неопределено Тогда
		СтрокаГруппирующегоПоля = ГруппирующиеПоляИтогов.Добавить();
		СтрокаГруппирующегоПоля.Определение = ОпределениеПоля;
		СтрокаГруппирующегоПоля.ТипИтогов = "Элементы";
		//ПолеОбъединения.РольИтога = 1; // так не будет работать, т.к. при перетаскивании созадается копия строки
		ОбновитьРолиИтогов();
	КонецЕсли; 
	ЭлементыФормы.ГруппирующиеПоляИтогов.ТекущаяСтрока = СтрокаГруппирующегоПоля;

КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если Не ЗначениеЗаполнено(ДанныеСтроки.Имя) Тогда
		ОформлениеСтроки.Ячейки.Имя.УстановитьТекст(ДанныеСтроки.Определение);
		ОформлениеСтроки.Ячейки.Имя.ЦветТекста = Новый Цвет(128, 128, 128);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЛиПакетныйЗапросПриИзменении(Элемент = Неопределено) Экспорт
	
	ИзменитьСвернутостьПанельПакета(ЛиПакетныйЗапрос);

КонецПроцедуры

Процедура ЗапросыПакетаПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	ЗапросПакета = ДобавитьЗапросПакета();
	Элемент.ТекущаяСтрока = ЗапросПакета;

КонецПроцедуры

Процедура ЗапросыПакетаПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьЗапросПакета();
	ЗагрузитьЗапросПакета();

КонецПроцедуры

Процедура ЗагрузитьЗапросПакета()
	
	Элемент = ЭлементыФормы.ЗапросыПакета;
	мТекущаяСтрокаЗапросыПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	мТекущаяСтрокаГруппируемогоПоля = Неопределено;
	Если мТекущаяСтрокаЗапросыПакета <> Неопределено Тогда
		мТекущееИмяВременнойТаблицы = мТекущаяСтрокаЗапросыПакета.ИмяВременнойТаблицы;
		ЭлементыФормы.ВыражениеГруппируемогоПоля.УстановитьТекст("");
		ЭтаФорма.ЧастиОбъединения = мТекущаяСтрокаЗапросыПакета.ЧастиОбъединения;
		ЭтаФорма.ТипЗапроса = мТекущаяСтрокаЗапросыПакета.ТипЗапроса;
		ЭтаФорма.РежимОбъединения = мТекущаяСтрокаЗапросыПакета.ЧастиОбъединения.Количество() > 1;
		ЭтаФорма.ПоляПорядка = мТекущаяСтрокаЗапросыПакета.ПоляПорядка;
		ЭтаФорма.ПоляОбъединения = мТекущаяСтрокаЗапросыПакета.ПоляОбъединения;
		ЭтаФорма.ПоляИндекса = мТекущаяСтрокаЗапросыПакета.ПоляИндекса;
		ЭтаФорма.ГруппируемыеПоляИтогов = мТекущаяСтрокаЗапросыПакета.ГруппируемыеПоляИтогов;
		ЭтаФорма.ГруппирующиеПоляИтогов = мТекущаяСтрокаЗапросыПакета.ГруппирующиеПоляИтогов;
		ЭтаФорма.ОпцияРазрешенные = мТекущаяСтрокаЗапросыПакета.ОпцияРазрешенные;
		ЭтаФорма.ОпцияОбщиеИтоги = мТекущаяСтрокаЗапросыПакета.ОпцияОбщиеИтоги;
		ЭтаФорма.ОпцияПервые = мТекущаяСтрокаЗапросыПакета.ОпцияПервые;
		ЭтаФорма.ОпцияАвтоупорядочивание = мТекущаяСтрокаЗапросыПакета.ОпцияАвтоупорядочивание;
		ЭтаФорма.ИмяВременнойТаблицы = мТекущаяСтрокаЗапросыПакета.ИмяВременнойТаблицы;
		ЭтаФорма.ПервыеКоличество = мТекущаяСтрокаЗапросыПакета.ПервыеКоличество;
		ЭтаФорма.КомпоновщикЗапроса = мТекущаяСтрокаЗапросыПакета.Компоновщик;
		ЭтаФорма.ПоляПорядкаПостроителя = мТекущаяСтрокаЗапросыПакета.ПоляПорядкаПостроителя;
		ЭтаФорма.ПоляИтоговПостроителя = мТекущаяСтрокаЗапросыПакета.ПоляИтоговПостроителя;
		ДоступныеПоляПсевдонима.Очистить();
		ОбновитьДоступныеВременныеТаблицы();
		ОбновитьЗаголовкиСтраницПанелиДоступныхТаблиц();
		ПанельОсновнаяОбновитьТекущуюСтраницу();
		Если ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения Тогда
			ОбновитьТабличноеПолеПоляОбъединения();
		КонецЕсли;
		Если ТипЗапроса = 2 Тогда
			ЭлементыФормы.КомментарийЧасти.УстановитьТекст(мТекущаяСтрокаЗапросыПакета.Комментарий);
			мТекущаяСтрокаЧастиОбъединения = Неопределено;
		Иначе
			Если ЭтаФорма.ЧастиОбъединения.Количество() = 0 Тогда
				ДобавитьЧастьОбъединения(мТекущаяСтрокаЗапросыПакета);
			КонецЕсли; 
			Если Истина
				И ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = Неопределено 
				И ЧастиОбъединения.Количество() > 0
			Тогда
				ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = ЧастиОбъединения[0];
			Иначе
				ЧастиОбъединенияПриАктивизацииСтроки();
			КонецЕсли; 
		КонецЕсли; 
		ИзменитьСвернутостьПанельЧастей(РежимОбъединения);
	КонецЕсли; 

КонецПроцедуры

Процедура ДоступныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Тип = ДанныеСтроки.Тип;
	ИндексКартинки = ирОбщий.ПолучитьИндексКартинкиТипаТаблицыБДЛкс(Тип);
	ОформлениеСтроки.Ячейки.Имя.ОтображатьКартинку = Истина;
	ОформлениеСтроки.Ячейки.Имя.ИндексКартинки = ИндексКартинки;
	
КонецПроцедуры

Процедура ОформитьЯчейкуИмениТаблицы(Элемент, ОформлениеСтроки, ДанныеСтроки, ИмяЯчейкиТаблицы)
	
	ИндексКартинки = Неопределено;
	СтрокаВыбраннойТаблицы = ВыбранныеТаблицы.Найти(ДанныеСтроки[ИмяЯчейкиТаблицы], "Имя");
	Если СтрокаВыбраннойТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ИндексКартинки = ПолучитьИндексКартинкиВыбраннойТаблицы(СтрокаВыбраннойТаблицы);
	ОформлениеСтроки.Ячейки[ИмяЯчейкиТаблицы].ОтображатьКартинку = Истина;
	ОформлениеСтроки.Ячейки[ИмяЯчейкиТаблицы].ИндексКартинки = ИндексКартинки;
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	СтрокаДоступнойТаблицы = Неопределено;
	ИндексКартинки = ПолучитьИндексКартинкиВыбраннойТаблицы(ДанныеСтроки, СтрокаДоступнойТаблицы);
	ОформлениеСтроки.Ячейки.Имя.ОтображатьКартинку = Истина;
	ОформлениеСтроки.Ячейки.Имя.ИндексКартинки = ИндексКартинки;
	Если Истина
		И ДанныеСтроки.ВложенныйПакет = Неопределено
		И СтрокаДоступнойТаблицы = Неопределено 
		И Найти(ДанныеСтроки.ПолноеИмя, ".") > 0
	Тогда
		ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаОшибки");
	КонецЕсли; 
	Если ДанныеСтроки.Обязательная Тогда
		ЯчейкаНомерГруппы = ОформлениеСтроки.Ячейки.Найти("НомерГруппы");
		Если ЯчейкаНомерГруппы <> Неопределено Тогда
			ЯчейкаНомерГруппы.ТолькоПросмотр = Истина;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Функция ПолучитьИндексКартинкиВыбраннойТаблицы(ДанныеСтроки, выхСтрокаДоступнойТаблицы = Неопределено)

	ИндексКартинки = Неопределено;
	Если ДанныеСтроки.ВложенныйПакет <> Неопределено Тогда
		ИндексКартинки = 0;
	КонецЕсли; 
	Если ИндексКартинки = Неопределено Тогда
		выхСтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ДанныеСтроки.ПолноеИмя), "НПолноеИмя");
		Если выхСтрокаДоступнойТаблицы <> Неопределено Тогда
			Тип = выхСтрокаДоступнойТаблицы.Тип;
		КонецЕсли; 
	КонецЕсли; 
	Если ИндексКартинки = Неопределено Тогда
		ИндексКартинки = ирОбщий.ПолучитьИндексКартинкиТипаТаблицыБДЛкс(Тип);
	КонецЕсли;
	Возврат ИндексКартинки;

КонецФункции

Процедура ТипЗапросаПриИзменении(Элемент)
	
	ОбновитьНаименованиеЗапроса(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);

КонецПроцедуры

Процедура ОбновитьНаименованиеЗапроса(ЗапросПакета) Экспорт
	
	Если ЗапросПакета.ТипЗапроса = 0 Тогда
		ЗапросПакета.Имя = "" + ЗапросПакета.Индекс;
		Если ЗапросПакета.ЧастиОбъединения.Количество() > 0 Тогда
			ИмяЧастиОбъединения = Сред(ЗапросПакета.ЧастиОбъединения[0].Имя, СтрДлина("" + ЗапросПакета.ЧастиОбъединения[0].Номер + ",") + 1);
			Если Не ПустаяСтрока(ИмяЧастиОбъединения) Тогда
				ЗапросПакета.Имя = ЗапросПакета.Имя + "," + ИмяЧастиОбъединения;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ЗапросПакета.ТипЗапроса = 1 Тогда
		ЗапросПакета.Имя = "+" + ЗапросПакета.ИмяВременнойТаблицы;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 2 Тогда
		ЗапросПакета.Имя = "-" + ЗапросПакета.ИмяВременнойТаблицы;
	Иначе
		ЗапросПакета.Имя = "" + ЗапросПакета.Индекс;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьНаименованиеЧасти(ЧастьОбъединения = Неопределено)
	
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	ИмяЧасти = "" + ЧастьОбъединения.Номер;
	Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
		Если ИмяЧасти <> "" Тогда
			ИмяЧасти = ИмяЧасти + ",";
		КонецЕсли; 
		ИмяЧасти = ИмяЧасти + СтрокаВыбраннойТаблицы.Имя;
	КонецЦикла;
	ЧастьОбъединения.Имя = ИмяЧасти;
	ЧастьОбъединения.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЧастьОбъединения.Владелец(), ЧастьОбъединения,, Ложь);
	
КонецПроцедуры

Процедура ВыбранныеТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если ВыбраннаяСтрока.ВложенныйПакет <> Неопределено Тогда
		СтандартнаяОбработка = Ложь;
		ОткрытьВложенныйПакет(ВыбраннаяСтрока.ВложенныйПакет, ВыбраннаяСтрока.Имя);
	КонецЕсли; 
	
КонецПроцедуры

Функция _СкопироватьТаблицуВыражений(ТаблицаВыражений)

	КопияТаблицы = ирОбщий.ПолучитьКопиюОбъектаЛкс(ТаблицаВыражений);
	Для Индекс = 0 По КопияТаблицы.Количество() - 1 Цикл
		ЗаполнитьЗначенияСвойств(КопияТаблицы[Индекс], ТаблицаВыражений[Индекс], "Токен"); 
	КонецЦикла;
	Возврат КопияТаблицы;

КонецФункции // СкопироватьТаблицуВыражений()

Функция СкопироватьВложенныйПакетДляРедактирования(Пакет)

	// Удаляем все токены, т.к. для настроек компоновки сериализация всегда выполняется через сериализаторXDTO, который ругается на COM объекты
	ОбновитьВсеВыраженияПакета(Пакет, 2); 
	ПакетКопия = ирОбщий.ПолучитьКопиюОбъектаЛкс(Пакет);
	Для Индекс = 0 По Пакет[0].ЧастиОбъединения.Количество() - 1 Цикл
		ЧастьОбъединенияКопия = ПакетКопия[0].ЧастиОбъединения[Индекс];
		ЧастьОбъединенияКопия.Компоновщик.ЗагрузитьНастройки(Пакет[0].ЧастиОбъединения[Индекс].Компоновщик.Настройки); 
		ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединенияКопия);
	КонецЦикла;
	ОбновитьВсеВыраженияПакета(ПакетКопия);
	Возврат ПакетКопия;
	// Доделать копирования токенов
	//ПараметрыТаблицы.Колонки.Добавить("Токен");
	//ВыбранныеПоля.Колонки.Добавить("Токен");
	//Группировки.Колонки.Добавить("Токен");
	//ПоляПорядка.Колонки.Добавить("Токен");
	//ПоляВыбораПостроителя.Колонки.Добавить("Токен");
	//ПоляОтбораПостроителя.Колонки.Добавить("Токен");
	//ПоляПорядкаПостроителя.Колонки.Добавить("Токен");
	//ПоляИтоговПостроителя.Колонки.Добавить("Токен");
	//ГруппируемыеПоляИтогов.Колонки.Добавить("Токен");
	//ГруппирующиеПоляИтогов.Колонки.Добавить("Токен");

КонецФункции // СкопироватьПакетДляРедактирования()

Функция ОткрытьВложенныйПакет(ВложенныйПакет = Неопределено, Знач ИмяЗапроса = "")
	
	ФормаКонструктора = ПолучитьФорму("КонструкторЗапроса", ЭтаФорма);
	Если Не ЗначениеЗаполнено(ИмяЗапроса) Тогда
		ИмяЗапроса = "<Безымянный>";
	КонецЕсли; 
	ФормаКонструктора.Заголовок = ФормаКонструктора.Заголовок + ". " + ИмяЗапроса;
	ЗаполнитьЗначенияСвойств(ФормаКонструктора, ЭтаФорма, "РасширеннаяПроверка, Английский1С, ТабличноеПолеКорневогоПакета");
	ФормаКонструктора.УстановитьДиалектSQL(ДиалектSQL);
	ФормаКонструктора.Параметры = ЭтаФорма.Параметры;
	Если ВложенныйПакет <> Неопределено Тогда
		ФормаКонструктора.ЗапросыПакета = СкопироватьВложенныйПакетДляРедактирования(ВложенныйПакет);
	КонецЕсли; 
	РезультатФормы = ФормаКонструктора.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВложенныйПакет = ФормаКонструктора.ЗапросыПакета;
	КонецЕсли; 
	ОбновитьДоступныеВременныеТаблицы();
	Возврат ВложенныйПакет;
	
КонецФункции

Процедура ИмяВременнойТаблицыПриИзменении(Элемент)

	НовоеИмя = Элемент.Значение;
	Если мТекущееИмяВременнойТаблицы = НовоеИмя Тогда
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаЗапросыПакета.ИмяВременнойТаблицы = НовоеИмя;
	ОбновитьНаименованиеЗапроса(мТекущаяСтрокаЗапросыПакета);
	Для Индекс = ЗапросыПакета.Индекс(мТекущаяСтрокаЗапросыПакета) + 1 По ЗапросыПакета.Количество() - 1 Цикл
		СтрокаЗапроса = ЗапросыПакета[Индекс];
		Если Истина
			И СтрокаЗапроса.ТипЗапроса = 2 // Удаление временной таблицы
			И СтрокаЗапроса.ИмяВременнойТаблицы = мТекущееИмяВременнойТаблицы
		Тогда
			СтрокаЗапроса.ИмяВременнойТаблицы = НовоеИмя;
			ОбновитьНаименованиеЗапроса(СтрокаЗапроса);
			Прервать;
		КонецЕсли; 
		ПереименоватьДоступнуюТаблицуВЗапросеПакета(СтрокаЗапроса, мТекущееИмяВременнойТаблицы, НовоеИмя);
		ОбновитьНаименованиеЗапроса(СтрокаЗапроса);
	КонецЦикла;
	мТекущееИмяВременнойТаблицы = НовоеИмя;
	
КонецПроцедуры

Процедура ПереименоватьДоступнуюТаблицуВЗапросеПакета(СтрокаЗапроса, СтароеИмя, НовоеИмя)
	
	Для Каждого ЧастьОбъединения Из СтрокаЗапроса.ЧастиОбъединения Цикл
		Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
			Если СтрокаВыбраннойТаблицы.ПолноеИмя = СтароеИмя Тогда
				СтрокаВыбраннойТаблицы.ПолноеИмя = НовоеИмя;
			ИначеЕсли СтрокаВыбраннойТаблицы.ВложенныйПакет <> Неопределено Тогда 
				ПереименоватьДоступнуюТаблицуВЗапросеПакета(СтрокаВыбраннойТаблицы.ВложенныйПакет[0], СтароеИмя, НовоеИмя);
			КонецЕсли; 
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбновитьНомераЗапросов()
	
	Для Каждого ЗапросПакета Из ЗапросыПакета Цикл
		ЗапросПакета.Индекс = ЗапросыПакета.Индекс(ЗапросПакета); 
		ОбновитьНаименованиеЗапроса(ЗапросПакета);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗапросыПакетаПослеУдаления(Элемент)
	
	ОбновитьНомераЗапросов();
	
КонецПроцедуры

Процедура СохранитьВыбраннуюТаблицу()
	
	Если мТекущаяСтрокаВыбранныеТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ВыбранныеТаблицы.Индекс(мТекущаяСтрокаВыбранныеТаблицы) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьПараметрТаблицы();
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПриАктивизацииСтроки(Элемент)
	
	СохранитьВыбраннуюТаблицу();
	ЗагрузитьВыбраннуюТаблицу();
	
КонецПроцедуры

Процедура ЗагрузитьВыбраннуюТаблицу()
	
	Элемент = ЭлементыФормы.ВыбранныеТаблицы;
	мТекущаяСтрокаВыбранныеТаблицы = Элемент.ТекущаяСтрока;
	НоваяДоступностьКнопки = Истина
		И мТекущаяСтрокаВыбранныеТаблицы <> Неопределено
		И мТекущаяСтрокаВыбранныеТаблицы.ВложенныйПакет <> Неопределено;
	//ЭлементыФормы.КПВыбранныеТаблицы.Кнопки.ПреобразоватьВПодзапрос.Доступность = НоваяДоступностьКнопки;
	ЭлементыФормы.КПВыбранныеТаблицы.Кнопки.ПеренестиВоВременнуюТаблицу.Доступность = НоваяДоступностьКнопки;
	мТекущееИмяВыбраннойТаблицы = Неопределено;
	ПараметрыТаблицы = ПараметрыТаблицы.СкопироватьКолонки(); // Тут нельзя очищать сущесвующую таблицу, т.к. она может принадлежать кому то
	ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст("");
	Если мТекущаяСтрокаВыбранныеТаблицы <> Неопределено Тогда
		ОбновитьТекущееИмяТаблицы();
		ЭтаФорма.ПараметрыТаблицы = мТекущаяСтрокаВыбранныеТаблицы.Параметры;
		ДоступнаяТаблица = ДоступныеТаблицы.Найти(НРег(мТекущаяСтрокаВыбранныеТаблицы.ПолноеИмя), "НПолноеИмя");
		КоличествоПараметровДоступнойТаблицы = 0;
		Если ДоступнаяТаблица <> Неопределено Тогда
			Если ДоступнаяТаблица.Тип = "ВиртуальнаяТаблица" Тогда
				//МассивЗащитыОтРекурсии.Очистить();
				ТаблицаСтруктурТиповКонтекста = ОпределитьТипЗначенияКонтекста(Элемент.ТекущаяСтрока.ПолноеИмя);
				Если ТаблицаСтруктурТиповКонтекста.Количество() > 0 Тогда
					СтруктураТипа = ТаблицаСтруктурТиповКонтекста[0];
					ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
					ИмяВиртуальнойТаблицы = ирОбщий.ПолучитьПоследнийФрагментЛкс(ИмяОбщегоТипа);
					ТипКонтекста = Лев(ИмяОбщегоТипа, СтрДлина(ИмяОбщегоТипа) - СтрДлина(ИмяВиртуальнойТаблицы) - 1);
					СтруктураКлюча = Новый Структура("ТипКонтекста, Слово, ЯзыкПрограммы", ТипКонтекста, ИмяВиртуальнойТаблицы, 1);
					НайденныеСтроки = мПлатформа.ТаблицаПараметров.НайтиСтроки(СтруктураКлюча);
					КоличествоПараметровДоступнойТаблицы = НайденныеСтроки.Количество();
					Для Счетчик = 1 По КоличествоПараметровДоступнойТаблицы Цикл
						СтрокаОписанияПараметра = НайденныеСтроки[Счетчик - 1];
						// Защита от двойных параметров для вирт. таблиц регистра бухгалтерии
						СтрокаПараметра = ПараметрыТаблицы.Найти(СтрокаОписанияПараметра.Параметр, "Имя");
						Если СтрокаПараметра <> Неопределено Тогда
							Продолжить;
						КонецЕсли; 
						Если Счетчик > ПараметрыТаблицы.Количество() Тогда
							СтрокаПараметра = ПараметрыТаблицы.Добавить();
							СтрокаПараметра.Номер = Счетчик;
						Иначе
							СтрокаПараметра = ПараметрыТаблицы[Счетчик - 1];
						КонецЕсли; 
						СтрокаПараметра.Имя = СтрокаОписанияПараметра.Параметр;
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Для Индекс = КоличествоПараметровДоступнойТаблицы По ПараметрыТаблицы.Количество() - 1 Цикл
			СтрокаПараметра = ПараметрыТаблицы[Индекс];
			НомерПараметра = Индекс + 1;
			СтрокаПараметра.Имя = "Неизвестный" + (НомерПараметра);
			СтрокаПараметра.Номер = НомерПараметра;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

Функция ОбновитьТекущееИмяТаблицы()

	мТекущееИмяВыбраннойТаблицы = мТекущаяСтрокаВыбранныеТаблицы.Имя;
	Возврат Неопределено;

КонецФункции

Процедура СохранитьПараметрТаблицы()
	
	Если мТекущаяСтрокаПараметраТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ПараметрыТаблицы.Индекс(мТекущаяСтрокаПараметраТаблицы) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаПараметраТаблицы.Определение = ЭлементыФормы.ВыражениеПараметраТаблицы.ПолучитьТекст();
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаПараметраТаблицы,,,,,, Истина);
	
КонецПроцедуры

Процедура ЗагрузитьПараметрТаблицы()
	
	мТекущаяСтрокаПараметраТаблицы = ЭлементыФормы.ПараметрыТаблицы.ТекущаяСтрока;
	Если мТекущаяСтрокаПараметраТаблицы = Неопределено Тогда
		НовыйТекст = "";
	Иначе
		НовыйТекст = мТекущаяСтрокаПараметраТаблицы.Определение;
	КонецЕсли; 
	ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст(НовыйТекст);
	
КонецПроцедуры

Процедура ПараметрыТаблицыПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьПараметрТаблицы();
	ЗагрузитьПараметрТаблицы();
	
КонецПроцедуры

Процедура КППараметрыТаблицыПодсказатьПараметр(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ПараметрыТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЭтотОбъект.мНомерПараметра = ТекущаяСтрока.Номер;
	ОткрытьПоискВСинтаксПомощнике(ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока.ПолноеИмя);
	
КонецПроцедуры

Процедура КПДоступныеТаблицыПерейтиКОпределению(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ТекущаяСтрока.Тип = "ВременнаяТаблица" Тогда
		ПородившаяСтрокаПакета = ЗапросыПакета.Найти(ТекущаяСтрока.ПородившийЗапрос, "ИД");
		Если ПородившаяСтрокаПакета <> Неопределено Тогда
			ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = ПородившаяСтрокаПакета;
		КонецЕсли; 
	Иначе
		ОткрытьПоискВСинтаксПомощнике(ТекущаяСтрока.ПолноеИмя);
	КонецЕсли; 
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыНайтиВСписке(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока <> Неопределено Тогда
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ТекущаяСтрока.ПолноеИмя), "НПолноеИмя");
		Если СтрокаДоступнойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока = СтрокаДоступнойТаблицы;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьТекущуюЧастьПсевдонима()
	
	ТекущаяКолонка = ЭлементыФормы.ПоляОбъединения.ТекущаяКолонка;
	Если ТекущаяКолонка = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ИмяКолонки = ТекущаяКолонка.Данные;
	Если ПоляОбъединения.Колонки.Индекс(ПоляОбъединения.Колонки[ИмяКолонки]) < мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Префикс = "Определение";
	Результат = ЧастиОбъединения.Найти(Число(Сред(ИмяКолонки, СтрДлина(Префикс) + 1)), "Номер");
	Возврат Результат;
	
КонецФункции

Процедура ПсевдонимыПолейПриАктивизацииКолонки(Элемент)
	
	ДоступныеПоляПсевдонима.Очистить();
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	СтрокаДоступногоПоля = ДоступныеПоляПсевдонима.Добавить();
	СтрокаДоступногоПоля.Определение = "<Отсутствует>";
	Для Каждого ВыбранноеПоле Из ВыбраннаяЧасть.ВыбранныеПоля Цикл
		СтрокаДоступногоПоля = ДоступныеПоляПсевдонима.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДоступногоПоля, ВыбранноеПоле); 
	КонецЦикла;
	ПсевдонимыПолейПриАктивизацииСтроки();
	
КонецПроцедуры

Процедура ВыбранныеПоляЧастиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	//Если Истина
	//	И ДанныеСтроки.Имя = "" 
	//	И ДанныеСтроки.Определение <> "<Отсутствует>"
	//Тогда
	//	ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаОшибки");
	//КонецЕсли;
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ПолеОбъединения = ПоляОбъединения.Найти(ДанныеСтроки.Имя, "Имя");
	Если Истина
		И ПолеОбъединения <> Неопределено 
		И ПолеОбъединения.Монополе 
	Тогда
		ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаОшибки");
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДоступныеПоляПсевдонимаПриАктивизацииСтроки(Элемент)
	
	Если Элемент.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	СтароеИмяПоля = Элемент.ТекущаяСтрока.Имя;
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли;
	СтараяСвязьПоля = ПоляОбъединения.Найти(СтароеИмяПоля, "Имя");
	Если СтараяСвязьПоля = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока Тогда
		Возврат;
	КонецЕсли; 
	Если СтараяСвязьПоля <> Неопределено Тогда
		Если Истина
			И Не СтараяСвязьПоля.Монополе
			И Не Автоотвязка 
		Тогда
			Возврат;
		КонецЕсли; 
		СтараяСвязьПоля["_" + ВыбраннаяЧасть.Номер] = Неопределено;
		СтараяСвязьПоля["Определение" + ВыбраннаяЧасть.Номер] = Неопределено; // <Отсутствует>
		УдалитьСтаруюСтроку = Истина;
		Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
			Если ЗначениеЗаполнено(СтараяСвязьПоля["_" + ЧастьОбъединения.Номер]) Тогда
				УдалитьСтаруюСтроку = Ложь;
				Прервать;
			КонецЕсли; 
		КонецЦикла;
		Если УдалитьСтаруюСтроку Тогда
			ПоляОбъединения.Удалить(СтараяСвязьПоля);
		Иначе
			ОбновитьТипЗначенияПоляОбъединения(, СтараяСвязьПоля);
		КонецЕсли; 
	КонецЕсли; 
	Если ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	НовоеИмя = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока.Имя;
	СтрокаДляОтвязки = ДоступныеПоляПсевдонима.Найти(НовоеИмя, "Имя");
	Если СтрокаДляОтвязки <> Неопределено Тогда
		СтрокаНовогоПсевдонима = ПоляОбъединения.Добавить();
		АвтоПсевдонимОтвязанногоПоля = ПолучитьАвтоПсевдонимПоля(СтрокаДляОтвязки, ВыбраннаяЧасть);
		АвтоПсевдонимОтвязанногоПоля = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ПоляОбъединения, АвтоПсевдонимОтвязанногоПоля);
		СтрокаНовогоПсевдонима.Имя = АвтоПсевдонимОтвязанногоПоля;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаНовогоПсевдонима);
		ЗаполнитьЗначенияСвойств(СтрокаНовогоПсевдонима, ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока, "_" + ВыбраннаяЧасть.Номер + "," + "Определение" + ВыбраннаяЧасть.Номер); 
		ВыбранноеПоле = ВыбраннаяЧасть.ВыбранныеПоля.Найти(СтрокаДляОтвязки.ИД, "ИД");
		СтрокаНовогоПсевдонима.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		СтрокаДляОтвязки.Имя = АвтоПсевдонимОтвязанногоПоля;
		ВыбранноеПоле.Имя = АвтоПсевдонимОтвязанногоПоля;
		ОбновитьТипЗначенияПоляОбъединения(, СтрокаНовогоПсевдонима);
	КонецЕсли; 
	Если Элемент.ТекущаяСтрока.Определение <> "<Отсутствует>" Тогда
		Элемент.ТекущаяСтрока.Имя = НовоеИмя; 
	КонецЕсли; 
	СтрокаВыбранногоПоля = ВыбраннаяЧасть.ВыбранныеПоля.Найти(Элемент.ТекущаяСтрока.ИД, "ИД");
	Если СтрокаВыбранногоПоля <> Неопределено Тогда
		СтрокаВыбранногоПоля.Имя = НовоеИмя;
	КонецЕсли; 
	ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока["_" + ВыбраннаяЧасть.Номер] = Элемент.ТекущаяСтрока.ИД;
	ОпределениеПоля = Элемент.ТекущаяСтрока.Определение;
	Если ОпределениеПоля = "<Отсутствует>" Тогда
		ОпределениеПоля = "";
	КонецЕсли; 
	ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока["Определение" + ВыбраннаяЧасть.Номер] = ОпределениеПоля;
	ОбновитьТипЗначенияПоляОбъединения();
	
КонецПроцедуры

Процедура ОбновитьТипЗначенияПоляОбъединения(ЗапросПакета = Неопределено, ПолеОбъединения = Неопределено)
	
	Если ПолеОбъединения = Неопределено Тогда
		ПолеОбъединения = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли;
	Результат = Новый ОписаниеТипов();
	КоличествоНеNullПолей = 0;
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(ПолеОбъединения["_" + ЧастьОбъединения.Номер], "ИД");
		Если ВыбранноеПоле <> Неопределено Тогда
			ТипЗначенияПоляЧасти = ВыбранноеПоле.ТипЗначения;
			Если Не ирОбщий.СтрокиРавныЛкс(ВыбранноеПоле.Определение, "null") Тогда
				КоличествоНеNullПолей = КоличествоНеNullПолей + 1;
			КонецЕсли; 
		Иначе
			ТипЗначенияПоляЧасти = Новый ОписаниеТипов("Null");
		КонецЕсли; 
		Результат = Новый ОписаниеТипов(Результат, ТипЗначенияПоляЧасти.Типы());
	КонецЦикла;
	ПолеОбъединения.ТипЗначения = Результат;
	ПолеОбъединения.Монополе = КоличествоНеNullПолей <= 1;
	
КонецПроцедуры

Процедура ПсевдонимыПолейПриАктивизацииСтроки(Элемент = Неопределено)
	
	Элемент = ЭлементыФормы.ПоляОбъединения;
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если Элемент.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	НоваяДоступность = Истина;
	СтрокаДоступногоПоля = ДоступныеПоляПсевдонима.Найти(Элемент.ТекущаяСтрока.Имя, "Имя");
	ИД = Элемент.ТекущаяСтрока["_" + ВыбраннаяЧасть.Номер];
	Если СтрокаДоступногоПоля <> Неопределено Тогда
		Если СтрокаДоступногоПоля.ИД = ИД Тогда
			ЭлементыФормы.ДоступныеПоляПсевдонима.ТекущаяСтрока = СтрокаДоступногоПоля;
			НоваяДоступность = Не Элемент.ТекущаяСтрока.Монополе;
		КонецЕсли; 
	ИначеЕсли Истина
		И Не ЗначениеЗаполнено(ИД)
		И ДоступныеПоляПсевдонима.Количество() > 0 
	Тогда
		ЭлементыФормы.ДоступныеПоляПсевдонима.ТекущаяСтрока = ДоступныеПоляПсевдонима[0];
	КонецЕсли; 
	ЭлементыФормы.ДоступныеПоляПсевдонима.Доступность = НоваяДоступность;
	
КонецПроцедуры

Процедура ПсевдонимыПолейИмяПриИзменении(Элемент)
	
	ПриИзмененииИмениПоляОбъединения();
	
КонецПроцедуры

Процедура ПриИзмененииИмениПоляОбъединения(ПолеОбъединения = Неопределено)
	
	Если ПолеОбъединения = Неопределено Тогда
		ПолеОбъединения = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока;
	КонецЕсли;
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ПолеОбъединения);
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		ИД = ПолеОбъединения["_" + ЧастьОбъединения.Номер];
		Если ЗначениеЗаполнено(ИД) Тогда
			СтрокаВыбранногоПоля = ЧастьОбъединения.ВыбранныеПоля.Найти(ИД, "ИД");
			СтрокаВыбранногоПоля.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ПоляОбъединения, ПолеОбъединения,, Ложь,
				ПолучитьСловоЯзыкаЗапросов("Field"));
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбранногоПоля);
			//Если ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока Тогда
			//	СтрокаВыбранногоПоля = ВыбранныеПоля.Найти(ИД, "ИД");
			//	СтрокаВыбранногоПоля.Имя = Элемент.Значение;
			//КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры


Процедура ДоступныеПоляИндексаВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	//СтрокаПоля = ПоляИндекса.Найти(ВыбраннаяСтрока.Имя, "Определение");
	//Если СтрокаПоля = Неопределено Тогда
	//	СтрокаПоля = ПоляИндекса.Добавить();
	//	СтрокаПоля.Определение = ВыбраннаяСтрока.Имя;
	//КонецЕсли; 
	//ЭлементыФормы.ПоляИндекса.ТекущаяСтрока = СтрокаПоля;
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляИндекса);
	
КонецПроцедуры

Процедура ПсевдонимыПолейПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		ИмяКолонки = "Определение" + ЧастьОбъединения.Номер;
		ИДПоля = ДанныеСтроки["_" + ЧастьОбъединения.Номер];
		Если Не ЗначениеЗаполнено(ИДПоля) Тогда
			Продолжить;
		КонецЕсли; 
		ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(ИДПоля, "ИД");
		Если ВыбранноеПоле <> Неопределено Тогда
			ИндексКартинки = ирОбщий.ПолучитьИндексКартинкиТипаЛкс(ВыбранноеПоле.ТипЗначения);
			ОформлениеСтроки.Ячейки[ИмяКолонки].ИндексКартинки = ИндексКартинки;
			ОформлениеСтроки.Ячейки[ИмяКолонки].ОтображатьКартинку = Истина;
			Если ВыбранноеПоле.Автополе Тогда
				ОформлениеСтроки.Ячейки[ИмяКолонки].ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаВычисляемогоЗначения");
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Процедура ДеревоУсловияСвязиПриИзмененииФлажка(Элемент, Колонка)
	
	Если Элемент.Колонки.Произвольное = Колонка Тогда
		ПереключитьРежимПроизвольногоВыраженияОтбора(Элемент, Колонка);
		ЗагрузитьВыражениеУсловияСвязи();
	КонецЕсли; 

КонецПроцедуры

////////////
// Отбор

Процедура ПереключитьРежимПроизвольногоВыраженияОтбора(ТабличноеПоле, Колонка)

	ТекущееЗначениеФлажка = ТабличноеПоле.ТекущаяСтрока.Представление <> "";
	Если ТекущееЗначениеФлажка Тогда
		ТабличноеПоле.ТекущаяСтрока.Представление = "";
	Иначе
		ТабличноеПоле.ТекущаяСтрока.Представление = ПолучитьВыражениеЭлементаОтбораЛкс(ТабличноеПоле.ТекущаяСтрока);
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьЭлементОтбораПослеИзменения(Элемент)

	Если ТипЗнч(Элемент.ТекущаяСтрока) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтароеПравоеЗначение = Элемент.ТекущаяСтрока.ПравоеЗначение;
		ПолучитьВыражениеЭлементаОтбораЛкс(Элемент.ТекущаяСтрока);
		Если СтароеПравоеЗначение <> Элемент.ТекущаяСтрока.ПравоеЗначение Тогда
			ОбновитьКомпоновщикЧастиОбъединения(); // Тут дерево доступных полей сбрасывает все развернутости. Возможно лучше отключить
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура КПДоступныеТаблицыОтборБезЗначенияВТекущейКолонке(Кнопка)
	
	ирОбщий.ТабличноеПоле_ОтборБезЗначенияВТекущейКолонке_КнопкаЛкс(ЭлементыФормы.ДоступныеТаблицы);

КонецПроцедуры

Процедура ПараметрыТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ПараметрВиртуальнойТаблицы";
	ФормаКонструктораВыражения.Выражение = ВыбраннаяСтрока.Определение;
	ФормаКонструктораВыражения.ШаблонПолноеИмяТаблицы = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока.ПолноеИмя;
	ФормаКонструктораВыражения.ШаблонНомерПараметра = ВыбраннаяСтрока.Номер;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВыбраннаяСтрока.Определение = РезультатФормы;
		ЗагрузитьПараметрТаблицы();
	КонецЕсли; 
	
КонецПроцедуры

Функция СобратьТекстИЗДляВыраженияУсловия() Экспорт
	
	Результат = "";
	Для Каждого ВыбраннаяТаблица Из ВыбранныеТаблицы Цикл
		Если Результат <> "" Тогда
			Результат = Результат + ",";
		КонецЕсли; 
		ОпределениеТаблицы = ПолучитьОпределениеТаблицы(ВыбраннаяТаблица);
		Результат = Результат + ОпределениеТаблицы;
	КонецЦикла;
	Если ЗначениеЗаполнено(Результат) Тогда
		Результат = "ИЗ " + Результат;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ДеревоУсловияВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если ВыбраннаяСтрока.Представление = "" Тогда
		Возврат;
	КонецЕсли; 
	СохранитьВыражениеУсловия();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "УсловиеОтбора";
	ФормаКонструктораВыражения.Выражение = ВыбраннаяСтрока.Представление;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВыбраннаяСтрока.Представление = РезультатФормы;
		ЗагрузитьВыражениеУсловия();
	КонецЕсли; 

КонецПроцедуры

Процедура ДеревоУсловияСвязиВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если ВыбраннаяСтрока.Представление = "" Тогда
		Возврат;
	КонецЕсли; 
	СохранитьВыражениеУсловияСвязи();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "УсловиеОтбора";
	ФормаКонструктораВыражения.Выражение = ВыбраннаяСтрока.Представление;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВыбраннаяСтрока.Представление = РезультатФормы;
		ЗагрузитьВыражениеУсловияСвязи();
	КонецЕсли; 

КонецПроцедуры

Процедура ПолеТекстаОтображаетПакетПриИзменении(Элемент)
	
	ПересобратьВременныйПолныйТекст();
	ЭлементыФормы.КПТекст.Кнопки.Редактировать.Доступность = ПолеТекстаОтображаетПакет;
	
КонецПроцедуры

Процедура КПТекстОтменитьРедактирование(Кнопка)
	
	ПереключитьРежимРедактированияТекста();
	ПересобратьВременныйПолныйТекст();
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыПеренестиВоВременнуюТаблицу(Кнопка)
	
	ЗапросПакета = ЗапросыПакета.Вставить(ЗапросыПакета.Индекс(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока));
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	ЗаполнитьЗначенияСвойств(ЗапросПакета, ТекущаяСтрока.ВложенныйПакет[0]);
	ЗапросПакета.ИмяВременнойТаблицы = ТекущаяСтрока.Имя;
	ЗапросПакета.ТипЗапроса = 1;
	ОбновитьНаименованиеЗапроса(ЗапросПакета);
	ОбновитьДоступныеВременныеТаблицы();
	ТекущаяСтрока.ПолноеИмя = ТекущаяСтрока.Имя;
	ТекущаяСтрока.ВложенныйПакет = Неопределено;
	ОбновитьРежимПакетногоЗапроса();
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговИмяПриИзменении(Элемент)
	
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ЭлементыФормы.ГруппирующиеПоляИтогов.ТекущаяСтрока);
	
КонецПроцедуры

Процедура ОсновныеДействияФормыПроверить(Кнопка)
	
	СохранитьЧастьОбъединения();
	ОбновитьВсеВыраженияСИндикацией();
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыЗаменитьТаблицу(Кнопка)
	
	//Если мТекущаяСтрокаВыбранныеТаблицы = Неопределено Тогда
	//	Предупреждение("Необходимо активизировать строку выбранной таблицы, в которой заменить", 20);
	//	Возврат;
	//КонецЕсли; 
	ТекущаяДоступнаяТаблица = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	Если ТекущаяДоступнаяТаблица = Неопределено Тогда
		Предупреждение("Необходимо активизировать строку доступной таблицы, на которую заменить", 20);
		Возврат;
	КонецЕсли; 
	Ответ = Вопрос("Вы действительно хотите заменить определение таблицы """ + мТекущаяСтрокаВыбранныеТаблицы.Имя + """
		|с " + мТекущаяСтрокаВыбранныеТаблицы.ПолноеИмя + " на " + ТекущаяДоступнаяТаблица.ПолноеИмя + "?", РежимДиалогаВопрос.ОКОтмена);
	Если Ответ = КодВозвратаДиалога.ОК Тогда
		мТекущаяСтрокаВыбранныеТаблицы.ПолноеИмя = ТекущаяДоступнаяТаблица.ПолноеИмя;
		мТекущаяСтрокаВыбранныеТаблицы.ВложенныйПакет = Неопределено;
		ЗагрузитьВыбраннуюТаблицу();
	КонецЕсли;
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПередУдалением(Элемент, Отказ)

	Ответ = Вопрос("Вы действительно хотите удалить из выбранных таблиц """ + мТекущаяСтрокаВыбранныеТаблицы.Имя + """?", РежимДиалогаВопрос.ОКОтмена);
	Если Ответ <> КодВозвратаДиалога.ОК Тогда
		Отказ = Истина;
	КонецЕсли;
	СтрокаСвязи = СвязиТаблиц.Строки.Найти(мТекущаяСтрокаВыбранныеТаблицы.Имя, "Таблица", Истина);
	УдалитьСтрокуСвязиТаблиц(СтрокаСвязи);
	СтрокиАвтополей = ВыбранныеПоля.НайтиСтроки(Новый Структура("Автополе", Истина));
	Для Каждого СтрокаАвтополя Из СтрокиАвтополей Цикл
		Если ирОбщий.СтрокиРавныЛкс(ирОбщий.ПолучитьПервыйФрагментЛкс(СтрокаАвтополя.Определение), мТекущаяСтрокаВыбранныеТаблицы.Имя) Тогда
			СтрокаПоляОбъединенияПоИмени = ПоляОбъединения.Найти(НРег(СтрокаАвтополя.Имя), "НИмя");
			ПоляОбъединения.Удалить(СтрокаПоляОбъединенияПоИмени);
			ВыбранныеПоля.Удалить(СтрокаАвтополя);
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьСтрокуСвязиТаблиц(СтрокаСвязи)
    
    РодительСтроки = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(СтрокаСвязи);
    Если СтрокаСвязи.Строки.Количество() > 0 Тогда
        ТекущийРодительСтроки = РодительСтроки;
        Для Каждого ДочерняяСтрока Из СтрокаСвязи.Строки Цикл
            НоваяСтрока = ТекущийРодительСтроки.Строки.Добавить();
            СкопироватьСтрокуСвязиТаблиц(ДочерняяСтрока, НоваяСтрока);
 			ОбновитьТипСвязиТаблицПослеИзмененияИерархии(НоваяСтрока);
    	    Если ТекущийРодительСтроки = СвязиТаблиц Тогда
                ТекущийРодительСтроки = НоваяСтрока;
            КонецЕсли; 
        КонецЦикла;
    КонецЕсли; 
    РодительСтроки.Строки.Удалить(СтрокаСвязи);

КонецПроцедуры

Процедура ВыбранныеТаблицыПриИзмененииФлажка(Элемент, Колонка)
	
	Если Колонка = ЭлементыФормы.ВыбранныеТаблицы.Колонки.ВсеПоля Тогда
		Если Элемент.ТекущаяСтрока[Колонка.ДанныеФлажка] Тогда
			ДобавитьВсеПоляТаблицыВВыбранныеПоля(Элемент.ТекущаяСтрока.Имя,,,, Истина);
		Иначе
			Для Каждого ВыбранноеПоле Из ВыбранныеПоля Цикл
				Если Ложь
					Или Не ПараметрыДиалектаSQL.МногоТаблиц 
					Или (Истина
						И ирОбщий.СтрокиРавныЛкс(ирОбщий.ПолучитьПервыйФрагментЛкс(ВыбранноеПоле.Определение), Элемент.ТекущаяСтрока.Имя)
						И ВыбранноеПоле.Автополе)
				Тогда
					ВыбранноеПоле.Автополе = Ложь;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	ИначеЕсли Колонка = ЭлементыФормы.ВыбранныеТаблицы.Колонки.Обязательная Тогда
		Если Элемент.ТекущаяСтрока[Колонка.ДанныеФлажка] Тогда
			Элемент.ТекущаяСтрока.НомерГруппы = 0;
		Иначе
			Элемент.ТекущаяСтрока.НомерГруппы = 1;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПередУдалением(Элемент, Отказ)
	
	Отказ = Элемент.ТекущаяСтрока.Автополе;

КонецПроцедуры

Процедура ВыбранныеПоляПередНачаломИзменения(Элемент, Отказ)
	
	Отказ = Элемент.ТекущаяСтрока.Автополе;

КонецПроцедуры

Процедура ДоступныеПоляВыбораПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ЭтоНедоступноеДоступноеПоле(ДанныеСтроки) Тогда
		ОформлениеСтроки.Ячейки.Заголовок.УстановитьТекст("<Недоступно>");
	КонецЕсли; 

КонецПроцедуры

Функция ЭтоНедоступноеДоступноеПоле(ДоступноеПоле)
	
	Результат = Ложь
		Или ирОбщий.СтрокиРавныЛкс("СистемныеПоля", "" + ДоступноеПоле.Поле)
		Или (Истина
			И ДоступноеПоле.Родитель <> Неопределено
			И ирОбщий.СтрокиРавныЛкс("СистемныеПоля", "" + ДоступноеПоле.Родитель.Поле));
	Возврат Результат;
	
КонецФункции

Процедура ВыбранныеПоляПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	
	
КонецПроцедуры

Процедура ПараметрыТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ТипЗнч(ДанныеСтроки) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Если ДанныеСтроки.Представление <> "" Тогда
			Возврат;
		КонецЕсли; 
		Токен = ДанныеСтроки.ПравоеЗначение;
	ИначеЕсли ТипЗнч(ДанныеСтроки) = Тип("СтрокаТаблицыЗначений") Тогда
		Токен = ДанныеСтроки.Токен;
	Иначе
		Возврат;
	КонецЕсли; 
	Если Токен = Неопределено Тогда
		ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаОшибки");
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппировкиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ПоляПорядкаПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПриАктивизацииСтроки(Элемент)
	
	СохранитьГруппируемоеПоле();
	ЗагрузитьГруппируемоеПоле();
	
КонецПроцедуры

Процедура СохранитьГруппируемоеПоле()
	
	Если мТекущаяСтрокаГруппируемогоПоля = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ГруппируемыеПоляИтогов.Индекс(мТекущаяСтрокаГруппируемогоПоля) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаГруппируемогоПоля.Определение = ЭлементыФормы.ВыражениеГруппируемогоПоля.ПолучитьТекст();
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаГруппируемогоПоля,,,,,,,, Ложь);

КонецПроцедуры

Процедура ЗагрузитьГруппируемоеПоле()
	
	мТекущаяСтрокаГруппируемогоПоля = ЭлементыФормы.ГруппируемыеПоляИтогов.ТекущаяСтрока;
	Если мТекущаяСтрокаГруппируемогоПоля = Неопределено Тогда
		ВыражениеПоля = "";
		РазрешеноИзменение = Ложь;
	Иначе
		ВыражениеПоля = мТекущаяСтрокаГруппируемогоПоля.Определение;
		РазрешеноИзменение = Истина;
	КонецЕсли; 
	ЭлементыФормы.ВыражениеГруппируемогоПоля.УстановитьТекст(ВыражениеПоля);
	ЭлементыФормы.ВыражениеГруппируемогоПоля.Доступность = РазрешеноИзменение;
	
КонецПроцедуры

Процедура ГруппировкиПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		//ЭлементыФормы.ВыражениеГруппируемогоПоля.УстановитьТекст(мТекущаяСтрокаГруппируемогоПоля.Представление);
		ОбновитьВыражениеЗапроса(Элемент.ТекущиеДанные);
	КонецЕсли; 
	
КонецПроцедуры

Процедура АвтогруппировкиПриИзменении(Элемент)
	
	ОбновитьГруппировки();
	
КонецПроцедуры

Процедура ВыбранныеПоляАгрегатнаяФункцияПриИзменении(Элемент)
	
	ТокенАргументаФункции = Неопределено;
	ТекущаяАгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(мТекущаяСтрокаВыбранногоПоля.Токен, ТокенАргументаФункции); 
	ВыражениеПоля = СобратьВыражениеЗапроса(ТокенАргументаФункции);
	Если ЗначениеЗаполнено(Элемент.Значение) Тогда
		ВыражениеПоля = Элемент.Значение + ВыражениеПоля + ")";
	КонецЕсли; 
	мТекущаяСтрокаВыбранногоПоля.Определение = ВыражениеПоля;
	ВыбранныеПоляОпределениеПриИзменении();
	
КонецПроцедуры

Процедура ВыбранныеПоляОпределениеПриИзменении(Элемент = Неопределено)
	
	ПриИзмененииВыраженияВыбранногоПоля();
	
КонецПроцедуры

Процедура ОсновныеДействияФормыКонструкторЗапроса(Кнопка)
	
	Если Не мРежимРедактированияТекста Тогда
		ПереключитьРежимРедактированияТекста();
	КонецЕсли; 
	Компонента = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ЭлементыФормы.ПолеТекстаЗапроса.Имя];
	Компонента.ВызватьКонструкторЗапросов(Истина);
	
КонецПроцедуры

Процедура ГруппируемыеПоляИтоговАгрегатнаяФункцияПриИзменении(Элемент = Неопределено)
	
	ТокенАргументаФункции = Неопределено;
	ТекущаяАгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(мТекущаяСтрокаГруппируемогоПоля.Токен, ТокенАргументаФункции); 
	ВыражениеПоля = СобратьВыражениеЗапроса(ТокенАргументаФункции,,,,,,, Ложь);
	Если ЗначениеЗаполнено(мТекущаяСтрокаГруппируемогоПоля.АгрегатнаяФункция) Тогда
		ВыражениеПоля = мТекущаяСтрокаГруппируемогоПоля.АгрегатнаяФункция + ВыражениеПоля + ")";
	КонецЕсли; 
	мТекущаяСтрокаГруппируемогоПоля.Определение = ВыражениеПоля;
	ПриИзмененииВыраженияГруппируемогоПоля();

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговОпределениеПриИзменении(Элемент)
	
	ПриИзмененииВыраженияГруппируемогоПоля();

КонецПроцедуры

Процедура ПриИзмененииВыраженияГруппируемогоПоля(ГруппируемоеПоле = Неопределено, ЗапросПакета = Неопределено)

	Если ГруппируемоеПоле = Неопределено Тогда
		ГруппируемоеПоле = мТекущаяСтрокаГруппируемогоПоля;
	КонецЕсли; 
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	ЕстьАгрегаты = Ложь;
	ОбновитьВыражениеЗапроса(ГруппируемоеПоле,,,,,,, ЕстьАгрегаты, Ложь);
	//ВыбранноеПоле.ТипЗначения = ПолучитьТипЗначенияВыражения(ГруппируемоеПоле.Токен);
	ГруппируемоеПоле.АгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(ГруппируемоеПоле.Токен);
	//ГруппируемоеПоле.ЕстьАгрегаты = ЕстьАгрегаты;
	ЗагрузитьГруппируемоеПоле();

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)

	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступноеПолеВГруппируемыеПоля(СтрокаПеретаскивания);
			КонецЦикла;  
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьДоступноеПолеВГруппируемыеПоля(ПолеОбъединения)

	Если Ложь
		Или ЗначениеЗаполнено(ПолеОбъединения.РольИтога) 
		Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
	Тогда
		Возврат;
	КонецЕсли; 
	ТабличноеПоле = ЭлементыФормы.ГруппируемыеПоляИтогов;
	СтрокаГруппируемогоПоля = ГруппируемыеПоляИтогов.Найти(ПолеОбъединения.Имя, "Имя");
	Если СтрокаГруппируемогоПоля = Неопределено Тогда
		СтрокаГруппируемогоПоля = ГруппируемыеПоляИтогов.Добавить();
		АгрегатнаяФункция = "COUNT(DISTINCT ";
		Если ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Число")) Тогда
			АгрегатнаяФункция = "SUM(";
		ИначеЕсли Ложь
			Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Булево"))
			Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Строка"))
			Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Дата"))
		Тогда
			АгрегатнаяФункция = "MAX(";
		КонецЕсли; 
		СтрокаГруппируемогоПоля.Определение = АгрегатнаяФункция + ПолеОбъединения.Имя + ")";
		СтрокаГруппируемогоПоля.Имя = ПолеОбъединения.Имя;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаГруппируемогоПоля);
		//ПолеОбъединения.РольИтога = 2; // так не будет работать, т.к. при перетаскивании созадается копия строки
		ОбновитьРолиИтогов();
	КонецЕсли; 
	ТабличноеПоле.ТекущаяСтрока = СтрокаГруппируемогоПоля;
	ПриИзмененииВыраженияГруппируемогоПоля(); // Надо делать после активизации строки

КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПослеУдаления(Элемент)
	
	ОбновитьРолиИтогов();
	
КонецПроцедуры

Процедура ОбновитьРолиИтогов(ЗапросПакета = Неопределено)
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	ЗапросПакета.ПоляОбъединения.ЗаполнитьЗначения(Неопределено, "РольИтога");
	Для Каждого ГруппирующееПоле Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
		ПолеОбъединения = ЗапросПакета.ПоляОбъединения.Найти(Нрег(ГруппирующееПоле.Определение), "НИмя");
		Если ПолеОбъединения <> Неопределено Тогда
			ПолеОбъединения.РольИтога = 1;
		КонецЕсли; 
	КонецЦикла;
	Для Каждого ГруппируемоеПоле Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
		ПолеОбъединения = ЗапросПакета.ПоляОбъединения.Найти(НРег(ГруппируемоеПоле.Имя), "НИмя");
		Если ПолеОбъединения <> Неопределено Тогда
			ПолеОбъединения.РольИтога = 2;
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Процедура ДоступныеПоляИтоговПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ЗначениеЗаполнено(ДанныеСтроки.РольИтога) Тогда
		ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаЧередованияСтрок");
	КонецЕсли; 
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьПолеОбъединенияВГруппирующиеПоля(СтрокаПеретаскивания);
			КонецЦикла;  
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Процедура ДоступныеПоляГруппировокВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеВГруппировки(ВыбраннаяСтрока);
	
КонецПроцедуры

Процедура ДобавитьДоступноеПолеВГруппировки(ДоступноеПоле)
	
	Если Автогруппировки Тогда
		Возврат;
	КонецЕсли; 
	//Если ЭтоНедоступноеДоступноеПоле(ВыбраннаяСтрока) Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ДоступноеПоле.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения")) Тогда
		Возврат;
	КонецЕсли; 
	СтандартнаяОбработка = Ложь;
	ОпределениеПоля = ПолучитьПолноеИмяДоступногоПоля(ДоступноеПоле);
	СтрокаГруппировки = Группировки.Найти(ОпределениеПоля, "Определение");
	Если СтрокаГруппировки = Неопределено Тогда
		СтрокаГруппировки = Группировки.Добавить();
		СтрокаГруппировки.Определение = ОпределениеПоля;
		ОбновитьВыражениеЗапроса(СтрокаГруппировки, ЭлементыФормы.Группировки);
	КонецЕсли; 
	ЭлементыФормы.Группировки.ТекущаяСтрока = СтрокаГруппировки;

КонецПроцедуры

Процедура ВыбранныеПоляОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьВыбранноеПоле();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ВыбранноеПоле";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПриИзмененииВыраженияВыбранногоПоля();
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьГруппируемоеПоле();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ПолеИтога";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЗапроса; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПриИзмененииВыраженияГруппируемогоПоля();
	КонецЕсли; 

КонецПроцедуры

Процедура ВыбранныеПоляПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если Не НоваяСтрока Тогда
		СохранитьВыбранноеПоле();
	КонецЕсли;
	Если НоваяСтрока Тогда
		Элемент.ТекущаяСтрока.ИД = Новый УникальныйИдентификатор;
		ЗагрузитьВыбранноеПоле();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если Не НоваяСтрока Тогда
		СохранитьГруппируемоеПоле();
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура ПоляПорядкаПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура КомментарийНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	ирОбщий.ПолеВводаТекста_НачалоВыбораЛкс(Элемент, СтандартнаяОбработка);
	
КонецПроцедуры

Процедура ВыбранныеПоляИмяПриИзменении(Элемент)
	
	СтрокаПоляОбъединенияПоИмени = ПоляОбъединения.Найти(НРег(мТекущаяСтрокаВыбранногоПоля.Имя), "НИмя");
	СтрокаПоляОбъединенияПоИД = ПоляОбъединения.Найти(мТекущаяСтрокаВыбранногоПоля.ИД, "_" + мТекущаяСтрокаЧастиОбъединения.Номер);
	Если СтрокаПоляОбъединенияПоИмени <> СтрокаПоляОбъединенияПоИмени Тогда
		Если СтрокаПоляОбъединенияПоИмени = Неопределено Тогда
			// Разделение полей
			СтрокаПоляОбъединенияПоИД.Имя = мТекущаяСтрокаВыбранногоПоля.Имя;
			ПриИзмененииИмениПоляОбъединения(СтрокаПоляОбъединенияПоИД);
		Иначе
			// Склеивание полей
			СтрокаПоляОбъединенияПоИмени["_" + мТекущаяСтрокаЧастиОбъединения.Номер] = мТекущаяСтрокаВыбранногоПоля.ИД;
			ОбновитьТипЗначенияПоляОбъединения(, СтрокаПоляОбъединенияПоИмени);
			Если СтрокаПоляОбъединенияПоИД.Монополе Тогда
				ПоляОбъединения.Удалить(СтрокаПоляОбъединенияПоИД);
			Иначе
				СтрокаПоляОбъединенияПоИД["_" + мТекущаяСтрокаЧастиОбъединения.Номер] = Неопределено;
				ОбновитьТипЗначенияПоляОбъединения(, СтрокаПоляОбъединенияПоИД);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура СвязиТаблицПослеУдаления(Элемент)
	
	ЗагрузитьСвязьТаблицы();
	
КонецПроцедуры

// Параметры:
//  Тип - Число -
//           0 - Элемент
//           1 - Выражение
//           2 - Группа-И
//           3 - Группа-Или
//           4 - Группа-Не
//
Процедура ДобавитьСтрокуВТабличноеПолеОтбора(ТабличноеПолеОтбора, Тип = 0)
	
	ТекущаяСтрокаОтбора = ТабличноеПолеОтбора.ТекущаяСтрока;
	Если Тип > 1 Тогда
		ТипСтроки = Тип("ГруппаЭлементовОтбораКомпоновкиДанных");
	Иначе
		ТипСтроки = Тип("ЭлементОтбораКомпоновкиДанных");
	КонецЕсли; 
	Если ТекущаяСтрокаОтбора = Неопределено Тогда
		ТекущаяСтрокаОтбора = ТабличноеПоле.Значение;
	КонецЕсли; 
	Если Ложь
		Или ТипЗнч(ТекущаяСтрокаОтбора) = Тип("ОтборКомпоновкиДанных") 
		Или ТипЗнч(ТекущаяСтрокаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
	Тогда
		НоваяСтрока = ТекущаяСтрокаОтбора.Элементы.Добавить(ТипСтроки);
		Если Тип = 2 Тогда
			НоваяСтрока.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
		ИначеЕсли Тип = 3 Тогда
			НоваяСтрока.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
		ИначеЕсли Тип = 4 Тогда
			НоваяСтрока.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
		КонецЕсли; 
	Иначе
		Родитель = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(ТекущаяСтрокаОтбора, ТабличноеПолеОтбора.Значение);
		НоваяСтрока = Родитель.Элементы.Добавить(ТипСтроки);
	КонецЕсли; 
	Если Тип = 1 Тогда
		НоваяСтрока.Представление = " ";
	КонецЕсли; 
	ТабличноеПолеОтбора.ТекущаяСтрока = НоваяСтрока;
	ТабличноеПолеОтбора.ИзменитьСтроку();

КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьЭлемент(Кнопка)
	
	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 0);

КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьГруппуИ(Кнопка)
	
	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 2);
	
КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьГруппуИли(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 3);
	
КонецПроцедуры

Процедура КПДеревоУсловияДобавитьЭлемент(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 0);
	
КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьВыражение(Кнопка)
	
	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 1);
	
КонецПроцедуры

Процедура КПДеревоУсловияДобавитьВыражение(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 1);

КонецПроцедуры

Процедура КПДеревоУсловияДобавитьГруппуИ(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 2);

КонецПроцедуры

Процедура КПДеревоУсловияДобавитьГруппуИли(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 3);

КонецПроцедуры

Процедура ПараметрыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Колонка = ЭлементыФормы.Параметры.Колонки.Значение Тогда
		ирОбщий.ЯчейкаТабличногоПоляРасширенногоЗначения_ВыборЛкс(Элемент, СтандартнаяОбработка);
	КонецЕсли; 
	
КонецПроцедуры

Процедура СтруктураКоманднойПанелиНажатие(Кнопка)
	
	ирОбщий.ОткрытьСтруктуруКоманднойПанелиЛкс(ЭтаФорма, Кнопка);
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыПреобразоватьВПодзапрос(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЗапросыВложенногоПакета = ЗапросыПакета.СкопироватьКолонки();
	ВложенныйЗапрос = ДобавитьЗапросПакета(ЗапросыВложенногоПакета);
	ВложеннаяЧастьОбъединения = ДобавитьЧастьОбъединения(ВложенныйЗапрос);
	СтрокаВыбраннойТаблицы = ВложеннаяЧастьОбъединения.ВыбранныеТаблицы.Добавить();
	ЗаполнитьЗначенияСвойств(СтрокаВыбраннойТаблицы, ТекущаяСтрока); // Опасно. Копируем ссылку на таблицу Параметры
	НайтиДобавитьВыбраннуюТаблицуВСвязи(СтрокаВыбраннойТаблицы, ВложеннаяЧастьОбъединения);
	ОбновитьКомпоновщикЧастиОбъединения(ВложеннаяЧастьОбъединения);
	СтрокаВыбраннойТаблицы.ВсеПоля = Истина;
	ДобавитьВсеПоляТаблицыВВыбранныеПоля(ТекущаяСтрока.Имя, ВложенныйЗапрос, ВложеннаяЧастьОбъединения);
	ТекущаяСтрока.ВложенныйПакет = ЗапросыВложенногоПакета;
	ТекущаяСтрока.ПолноеИмя = "";
	ТекущаяСтрока.Комментарий = "";
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущаяСтрока);
	ТекущаяСтрока.Параметры = ПараметрыТаблицы.СкопироватьКолонки();
	ЗагрузитьВыбраннуюТаблицу();
	ОткрытьВложенныйПакет(ТекущаяСтрока.ВложенныйПакет, ТекущаяСтрока.Имя);
	
КонецПроцедуры

Процедура КПДоступныеТаблицыДобавить(Кнопка)

	ИмяДоступнойТаблицы = "";
	Если ВвестиСтроку(ИмяДоступнойТаблицы, "Укажите имя временной таблицы") Тогда
		СтрокаДоступнойТаблицы = НайтиДобавитьДоступнуюВременнуюТаблицу(ИмяДоступнойТаблицы);
		ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока = СтрокаДоступнойТаблицы;
		ОбновитьЗаголовкиСтраницПанелиДоступныхТаблиц();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОбновитьЗаголовкиСтраницПанелиДоступныхТаблиц()
	
	ЭлементФормы = ЭлементыФормы.ПанельДоступныеТаблицы;
	Для Каждого Страница Из ЭлементФормы.Страницы Цикл
		Если Страница.Имя = "Все" Тогда
			Продолжить;
		КонецЕсли; 
		СтруктураОтбора = Новый Структура("Тип", Страница.Имя);
		Количество = ДоступныеТаблицы.НайтиСтроки(СтруктураОтбора).Количество();
		ирОбщий.ОбновитьТекстПослеМаркераВСтрокеЛкс(Страница.Заголовок, , "" + Количество + ")", "(");
	КонецЦикла;

КонецПроцедуры

Процедура ПанельДоступныеТаблицыПриСменеСтраницы(Элемент, ТекущаяСтраница)
	
	ОбновитьОтборПоСтраницеДоступныхТаблиц();
	
КонецПроцедуры

Процедура ОбновитьОтборПоСтраницеДоступныхТаблиц()
	
	ЭлементОтбора = ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Тип;
	ЭлементОтбора.Установить(ЭлементыФормы.ПанельДоступныеТаблицы.ТекущаяСтраница.Имя);
	ЭлементОтбора.Использование = ЭлементыФормы.ПанельДоступныеТаблицы.ТекущаяСтраница <> ЭлементыФормы.ПанельДоступныеТаблицы.Страницы.Все;
	
КонецПроцедуры

Процедура ДоступныеПоляВыбораПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляВыбораПостроителя);

КонецПроцедуры

Процедура ДоступныеПоляУсловияПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляОтбораПостроителя);

КонецПроцедуры

Процедура ДоступныеВыбранныеПоляИтоговПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляИтоговПостроителя);

КонецПроцедуры

Процедура ДоступныеВыбранныеПоляПорядкаПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляПорядкаПостроителя);

КонецПроцедуры

Процедура ДоступныеВыбранныеПоляВыбораПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляВыбораПостроителя);

КонецПроцедуры

Процедура ДоступныеВыбранныеПоляОтбораПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляОтбораПостроителя,,,, "Определение");
	
КонецПроцедуры

Процедура ОбновитьСтрокуПоляПостроителя(СтрокаПоляПостроителя, ЭтоНоваяСтрока = Ложь, РазрешитьНормализациюИмен = Ложь, ТипЗначения = Неопределено)
	
	ОбновитьВыражениеЗапроса(СтрокаПоляПостроителя,,,,,,,, РазрешитьНормализациюИмен);
	Если СтрокаПоляПостроителя.Владелец().Колонки.Найти("ТипЗначения") <> Неопределено Тогда
		Если ТипЗначения = Неопределено Тогда
			ТипЗначения = ПолучитьТипЗначенияВыражения(СтрокаПоляПостроителя.Токен);
		КонецЕсли; 
		СтрокаПоляПостроителя.ТипЗначения = ТипЗначения;
		Если СтрокаПоляПостроителя.Владелец().Колонки.Найти("ИспользоватьДочерние") <> Неопределено Тогда
			Если ЭтоНоваяСтрока Тогда
				Для Каждого Тип Из ТипЗначения.Типы() Цикл
					Если мПлатформа.мМетаданные.НайтиПоТипу(Тип) <> Неопределено Тогда
						СтрокаПоляПостроителя.ИспользоватьДочерние = Истина;
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
		
КонецПроцедуры

Процедура ПоляВыбораПостроителяОпределениеПриИзменении(Элемент)
	
	ОбновитьСтрокуПоляПостроителя(ЭлементыФормы.ПоляВыбораПостроителя.ТекущаяСтрока);
	//Если мТекущаяСтрокаВыбранногоПоля = СтрокаПоля Тогда
	//	ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(мТекущаяСтрокаВыбранногоПоля.Определение);
	//КонецЕсли; 
	
КонецПроцедуры

Процедура ПоляПостроителяПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Процедура ДоступныеПоляИтоговПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляИтоговПостроителя);

КонецПроцедуры

Процедура ДоступныеПоляПорядкаПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляПорядкаПостроителя);

КонецПроцедуры

Процедура ПоляПостроителяПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(СтрокаПеретаскивания, Элемент);
			КонецЦикла;  
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Процедура ПоляВыбораПостроителяПриАктивизацииСтроки(Элемент)
	
	ЭлементыФормы.ВыражениеВыбранногоПоляПостроителя.УстановитьТекст(Элемент.ТекущаяСтрока.Определение);
	
КонецПроцедуры

Процедура ПоляОтбораПостроителяПриАктивизацииСтроки(Элемент)
	
	ЭлементыФормы.ВыражениеУсловияПостроителя.УстановитьТекст(Элемент.ТекущаяСтрока.Определение);

КонецПроцедуры

Процедура ПоляОтбораПостроителяОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьВыражениеУсловия();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "УсловиеОтбора";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПоляОтбораПостроителяОпределениеПриИзменении(Элемент);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПоляВыбораПостроителяОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьВыбранноеПоле();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ВыбранноеПоле";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПоляВыбораПостроителяОпределениеПриИзменении(Элемент);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПоляОтбораПостроителяОпределениеПриИзменении(Элемент)
	
	ОбновитьСтрокуПоляПостроителя(ЭлементыФормы.ПоляОтбораПостроителя.ТекущаяСтрока);
	
КонецПроцедуры

Процедура КПТекстСравнить(Кнопка)
	
	ирОбщий.СравнитьСодержимоеЭлементаУправленияЛкс(мСравнительТабличныхДокументов, ЭлементыФормы.ПолеТекстаЗапроса);

КонецПроцедуры

Процедура ПриЗакрытии()
	
	// +++.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
	// Уничтожение всех экземпляров компоненты. Обязательный блок.
	Для Каждого Экземпляр Из ПолеТекстовогоДокументаСКонтекстнойПодсказкой Цикл
		Экземпляр.Значение.Уничтожить();
	КонецЦикла;
	// ---.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой

КонецПроцедуры

Процедура ДеревоУсловияСвязиПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если ТипЗнч(Элемент.ТекущаяСтрока) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Если Элемент.ТекущаяСтрока.ЛевоеЗначение = Неопределено Тогда
			Если ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока <> Неопределено Тогда
				Элемент.ТекущаяСтрока.ЛевоеЗначение = ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока.Поле;
			КонецЕсли; 
		КонецЕсли; 
		Если Элемент.ТекущаяСтрока.ПравоеЗначение = Неопределено Тогда
			Если ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока <> Неопределено Тогда
				Элемент.ТекущаяСтрока.ПравоеЗначение = ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока.Поле;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПараметрыПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	мИмяТекущегоПараметра = Элемент.ТекущиеДанные.Имя;
	
КонецПроцедуры

Процедура ГруппировкиПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	МассивЗначений = Неопределено;
    ТипЗначенияПеретаскивания = Неопределено;
    ирОбщий.ПолучитьМассивЗначенийПеретаскиванияЛкс(ПараметрыПеретаскивания, МассивЗначений, ТипЗначенияПеретаскивания);
	Если РазрешеноПеретаскиваниеВПоля(МассивЗначений[0]) Тогда
		СтандартнаяОбработка = Ложь;
		Для Каждого СтрокаПеретаскивания Из МассивЗначений Цикл
			ДобавитьДоступноеПолеВГруппировки(СтрокаПеретаскивания);
		КонецЦикла;  
	КонецЕсли;

КонецПроцедуры

Процедура ГруппировкиПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	Если Автогруппировки Тогда
		СтандартнаяОбработка = Ложь;
		ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.НеОбрабатывать;
		Возврат;
	КонецЕсли; 
	МассивЗначений = Неопределено;
    ТипЗначенияПеретаскивания = Неопределено;
    ирОбщий.ПолучитьМассивЗначенийПеретаскиванияЛкс(ПараметрыПеретаскивания, МассивЗначений, ТипЗначенияПеретаскивания);
	Если РазрешеноПеретаскиваниеВПоля(МассивЗначений[0]) Тогда
		СтандартнаяОбработка = Ложь;
		ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
	КонецЕсли;

КонецПроцедуры

Процедура СвязиТаблицПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
    ТипЗначенияПеретаскивания = Неопределено;
	МассивЗначений = Неопределено;
    ирОбщий.ПолучитьМассивЗначенийПеретаскиванияЛкс(ПараметрыПеретаскивания, МассивЗначений, ТипЗначенияПеретаскивания);
	Если ТипЗначенияПеретаскивания = Тип("СтрокаДереваЗначений") Тогда
		СтандартнаяОбработка = Ложь;
		ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Перемещение;
		//Если Строка <> Неопределено Тогда
		//	Для Каждого ПеретаскиваемаяСтрока Из МассивЗначений Цикл
		//		ВсеДочениеСтроки = ирОбщий.ПолучитьВсеСтрокиДереваЗначенийЛкс(ПеретаскиваемаяСтрока);
		//		Если ВсеДочениеСтроки.Найти(Строка) <> Неопределено Тогда
		//			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.НеОбрабатывать;
		//			ПараметрыПеретаскивания.Действие = ДействиеПеретаскивания.Отмена;
		//			Прервать;
		//		КонецЕсли; 
		//	КонецЦикла;
		//КонецЕсли; 
	ИначеЕсли ТипЗначенияПеретаскивания = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтандартнаяОбработка = Ложь;
		ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.КопированиеИПеремещение;
	КонецЕсли; 
	
КонецПроцедуры

Процедура СвязиТаблицПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	Элемент = ЭлементыФормы.СвязиТаблиц; // Для подсказки
	//СтандартнаяОбработка = Ложь;
	МассивЗначений = Неопределено;
    ТипЗначенияПеретаскивания = Неопределено;
    ирОбщий.ПолучитьМассивЗначенийПеретаскиванияЛкс(ПараметрыПеретаскивания, МассивЗначений, ТипЗначенияПеретаскивания);
	Если ТипЗначенияПеретаскивания = Тип("СтрокаДереваЗначений") Тогда
		РодительСтроки = Строка;
		Если РодительСтроки = Неопределено Тогда
			РодительСтроки = СвязиТаблиц;
		КонецЕсли; 
		МассивИменТаблиц = Новый Массив;
		Для Каждого ПеретаскиваемаяСтрока Из МассивЗначений Цикл
			МассивИменТаблиц.Добавить(ПеретаскиваемаяСтрока.Таблица);
		КонецЦикла; 
		Для Каждого ИмяПеретаскиваемойТаблицы Из МассивИменТаблиц Цикл
			ПеретаскиваемаяСтрока = СвязиТаблиц.Строки.Найти(ИмяПеретаскиваемойТаблицы, "Таблица", Истина);
			КопияПеретаскиваемойСтроки = СвязиТаблиц.Строки.Добавить();
			//СкопироватьСтрокуСвязиТаблиц(ПеретаскиваемаяСтрока, КопияПеретаскиваемойСтроки, РодительСтроки);
			ЗаполнитьЗначенияСвойств(КопияПеретаскиваемойСтроки, ПеретаскиваемаяСтрока); 
			КлючРодителя = Неопределено;
			Если ТипЗнч(РодительСтроки) = Тип("СтрокаДереваЗначений") Тогда
				КлючРодителя = РодительСтроки.Таблица;
			КонецЕсли; 
			УдалитьСтрокуСвязиТаблиц(ПеретаскиваемаяСтрока);
			Если КлючРодителя = Неопределено Тогда
				РодительСтроки = СвязиТаблиц;
			Иначе
				РодительСтроки = СвязиТаблиц.Строки.Найти(КлючРодителя, "Таблица", Истина);
			КонецЕсли; 
			НоваяСтрока = РодительСтроки.Строки.Добавить();
			//СкопироватьСтрокуСвязиТаблиц(КопияПеретаскиваемойСтроки, НоваяСтрока);
			ЗаполнитьЗначенияСвойств(НоваяСтрока, КопияПеретаскиваемойСтроки); 
			ОбновитьТипСвязиТаблицПослеИзмененияИерархии(НоваяСтрока);
			СвязиТаблиц.Строки.Удалить(КопияПеретаскиваемойСтроки);
			Элемент.ТекущаяСтрока = НоваяСтрока;
		КонецЦикла;
	ИначеЕсли ТипЗначенияПеретаскивания = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Для Каждого ПеретаскиваемыйЭлемент Из МассивЗначений Цикл
			Если Истина
				И Строка <> Неопределено 
				И Строка.Условие <> Неопределено
			Тогда
				НовыйЭлементОтбора = Строка.Условие.Отбор.Элементы.Добавить(ТипЗначенияПеретаскивания);
				ЗаполнитьЗначенияСвойств(НовыйЭлементОтбора, ПеретаскиваемыйЭлемент); 
				//Если ПараметрыПеретаскивания.Действие = ДействиеПеретаскивания.Перемещение Тогда
				//	РодительЭлемента = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(ПеретаскиваемыйЭлемент, ЭлементыФормы.УсловиеСвязиПанельЭлемента.Значение);
				//	РодительЭлемента.Удалить(ДействиеПеретаскивания.Перемещение);
				//КонецЕсли; 
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОбновитьТипСвязиТаблицПослеИзмененияИерархии(Знач НоваяСтрока)
    
    Если НоваяСтрока.Родитель = Неопределено Тогда
        НоваяСтрока.ТипСвязи = "";
    ИначеЕсли Не ЗначениеЗаполнено(НоваяСтрока.ТипСвязи) Тогда
        НоваяСтрока.ТипСвязи = "LEFT";
    КонецЕсли;

КонецПроцедуры

Процедура СкопироватьСтрокуСвязиТаблиц(Знач КопируемаяСтрокаСвязиТаблиц, Знач НоваяСтрока, СтопСтрока = Неопределено)
    
	Для Каждого СвязьТаблиц Из ирОбщий.ПолучитьВсеСтрокиДереваЗначенийЛкс(КопируемаяСтрокаСвязиТаблиц) Цикл
		Если СвязьТаблиц.Условие <> Неопределено Тогда
			ОбновитьВыраженияОтбора(СвязьТаблиц.Условие.Отбор, ЭлементыФормы.ДеревоУсловияСвязи,,,,, 2);
		КонецЕсли; 
	КонецЦикла;
    ирОбщий.СкопироватьСтрокиДереваЛкс(КопируемаяСтрокаСвязиТаблиц, НоваяСтрока, СтопСтрока);

КонецПроцедуры

Процедура СвязиТаблицПередУдалением(Элемент, Отказ)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура КПВыбранныеПоляОчистить(Кнопка)
	
	Для Каждого СтрокаВыбраннойТаблицы Из ВыбранныеТаблицы Цикл
		СтрокаВыбраннойТаблицы.ВсеПоля = Ложь;
	КонецЦикла;
	Пока ВыбранныеПоля.Количество() > 0 Цикл
		ВыбранныеПоля.Удалить(0);
	КонецЦикла; 
	
КонецПроцедуры

ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ВыбранныеПоля);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ПоляДоступнойТаблицы);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ПоляВыбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ПоляОтбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляПсевдонима);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляУсловия);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляПорядкаОбъединения);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляПорядкаЧастиОбъединения);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляИтоговОбъединения);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеВыбранныеПоляПорядкаПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеВыбранныеПоляИтоговПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеВыбранныеПоляВыбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеВыбранныеПоляОтбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляИндекса);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляВыбора);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляГруппировок);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляУсловияПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляВыбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляПорядкаПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляИтоговПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи);
ЭлементыФормы.ДоступныеПоляУсловия.Колонки.Заголовок.КартинкиСтрок = ирОбщий.ПолучитьОбщуюКартинкуЛкс("ирТипыДоступныхПолейКомпоновки");

//ЭлементыФормы.ВыбранныеПоля.Колонки.Определение.КартинкиСтрок = ирОбщий.ПолучитьОбщуюКартинкуЛкс("ирТипыДоступныхПолейКомпоновки");
//ЭлементыФормы.ПоляДоступнойТаблицы.Колонки.Имя.КартинкиСтрок = ирОбщий.ПолучитьОбщуюКартинкуЛкс("ирТипыДоступныхПолейКомпоновки");
ПоляПорядка.Колонки.Добавить("Направление", Новый ОписаниеТипов("НаправлениеСортировки"));
СвязиТаблиц.Колонки.Добавить("Условие");
//СвязиТаблиц.Колонки.Добавить("НТаблица", Новый ОписаниеТипов("Строка"));
ВыбранныеТаблицы.Колонки.Добавить("ВложенныйПакет");
ВыбранныеТаблицы.Колонки.Добавить("Параметры");
//ВыбранныеТаблицы.Колонки.Добавить("Обязательная", Новый ОписаниеТипов("Булево"));
//ВыбранныеТаблицы.Колонки.Добавить("НомерГруппы", Новый ОписаниеТипов("Число"));
ВыбранныеТаблицы.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляОбъединения.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляОбъединения.Колонки.Добавить("Монополе", Новый ОписаниеТипов("Булево"));
ПоляВыбораПостроителя.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляОтбораПостроителя.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляПорядкаПостроителя.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляИтоговПостроителя.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
//Параметры.Колонки.Добавить("Значение");
ПараметрыТаблицы.Колонки.Добавить("Токен");
//ПараметрыТаблицы.Колонки.Добавить("ТекстРасширения");
ВыбранныеПоля.Колонки.Добавить("Токен");
Группировки.Колонки.Добавить("Токен");
ПоляПорядка.Колонки.Добавить("Токен");
ПоляВыбораПостроителя.Колонки.Добавить("Токен");
ПоляОтбораПостроителя.Колонки.Добавить("Токен");
ПоляПорядкаПостроителя.Колонки.Добавить("Токен");
ПоляИтоговПостроителя.Колонки.Добавить("Токен");
ГруппируемыеПоляИтогов.Колонки.Добавить("Токен");
ГруппируемыеПоляИтогов.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ГруппирующиеПоляИтогов.Колонки.Добавить("Токен");
ГруппирующиеПоляИтогов.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ВыбранныеПоля.Колонки.Добавить("ИД");
ВыбранныеПоля.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ДоступныеПоляПсевдонима.Колонки.Добавить("ИД");
ЧастиОбъединения.Колонки.Добавить("ВыбранныеТаблицы");
ЧастиОбъединения.Колонки.Добавить("ВыбранныеПоля");
ЧастиОбъединения.Колонки.Добавить("СвязиТаблиц");
ЧастиОбъединения.Колонки.Добавить("Группировки");
ЧастиОбъединения.Колонки.Добавить("Условие");
ЧастиОбъединения.Колонки.Добавить("ПоляВыбораПостроителя");
ЧастиОбъединения.Колонки.Добавить("ПоляОтбораПостроителя");
ЧастиОбъединения.Колонки.Добавить("ОпцияРазличные", Новый ОписаниеТипов("Булево"));
ЧастиОбъединения.Колонки.Добавить("Автогруппировки", Новый ОписаниеТипов("Булево"));
ЧастиОбъединения.Колонки.Добавить("Компоновщик", Новый ОписаниеТипов("КомпоновщикНастроекКомпоновкиДанных"));
ЧастиОбъединения.Колонки.Добавить("ИсточникНастроек");
ЧастиОбъединения.Колонки.Добавить("ТекстРасширения", Новый ОписаниеТипов("Строка"));
ЗапросыПакета.Колонки.Добавить("ИД", Новый ОписаниеТипов("УникальныйИдентификатор"));
ЗапросыПакета.Колонки.Добавить("ЧастиОбъединения");
ЗапросыПакета.Колонки.Добавить("ПоляОбъединения");
ЗапросыПакета.Колонки.Добавить("ГруппирующиеПоляИтогов");
ЗапросыПакета.Колонки.Добавить("ГруппируемыеПоляИтогов");
ЗапросыПакета.Колонки.Добавить("ПоляПорядкаПостроителя");
ЗапросыПакета.Колонки.Добавить("ПоляИтоговПостроителя");
ЗапросыПакета.Колонки.Добавить("Комментарий", Новый ОписаниеТипов("Строка")); // Используется только для УНИЧТОЖИТЬ, т.к. там нет объединения
ЗапросыПакета.Колонки.Добавить("ТекстРасширения", Новый ОписаниеТипов("Строка"));
ЗапросыПакета.Колонки.Добавить("ПоляПорядка");
ЗапросыПакета.Колонки.Добавить("ПоляИндекса");
ЗапросыПакета.Колонки.Добавить("ОпцияАвтоупорядочивание", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ОпцияОбщиеИтоги", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ОпцияПервые", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ОпцияРазрешенные", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ТипЗапроса", Новый ОписаниеТипов("Число"));
ЗапросыПакета.Колонки.Добавить("ПервыеКоличество", Новый ОписаниеТипов("Число"));
ЗапросыПакета.Колонки.Добавить("ИмяВременнойТаблицы", Новый ОписаниеТипов("Строка"));
ЗапросыПакета.Колонки.Добавить("Компоновщик");
ЭлементыФормы.ПоляПорядка.Колонки.Направление.Данные = "Направление";
ЭтаФорма.ПервыеКоличество = 1;
мРежимРедактированияТекста = Ложь;
ПолеТекстаОтображаетПакет = Истина;
Английский1С = ирОбщий.СтрокиРавныЛкс(ТекущийЯзыкСистемы(), "en");
мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей = ПоляОбъединения.Колонки.Количество();
мЧислоСтатическихКолонокТППоляПсевдонимовПолей = ЭлементыФормы.ПоляОбъединения.Колонки.Количество();
мМаркерИндексаЗапросаПакета = "{// Индекс запроса = ";

СписокВыбораДиалектов = ЭлементыФормы.ДиалектSQL.СписокВыбора;
СписокВыбораДиалектов.Добавить("1С");
СписокВыбораДиалектов.Добавить("WQL");
СписокВыбораДиалектов.Добавить("Oracle");
СписокВыбораДиалектов.Добавить("MSSQL");
СписокВыбораДиалектов.Добавить("DB2");
СписокВыбораДиалектов.Добавить("MSVisualFoxPro");
СписокВыбораДиалектов.Добавить("MSJet");

мТерминалыЯзыкаЗапросов = Новый Соответствие;
ТаблицаТерминалов = ирОбщий.ПолучитьТаблицуИзТабличногоДокументаЛкс(мПлатформа.ПолучитьМакет("ТерминалыЯзыкаЗапросов"));
Для Каждого СтрокаТерминала Из ТаблицаТерминалов Цикл
	мТерминалыЯзыкаЗапросов.Вставить(СтрокаТерминала.Английский, СтрокаТерминала.Русский);
КонецЦикла; 
ДиалектSQL = мДиалектSQL;
ПараметрыДиалектаSQL = мПараметрыДиалектаSQL;

ирОбщий.ИнициализироватьФормуЛкс(ЭтаФорма, "Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Форма.КонструкторЗапроса");

